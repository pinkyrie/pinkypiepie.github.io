<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/pinkypiepie.git.io/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/pinkypiepie.git.io/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="评价算法标准        stability  时间（最好 最坏 平均）  关键字比较次数 数据移动次数   空间（最好 最坏 平均）                       排序分为comparison sorting 和 counting sorting        In computer science, counting sort is an">
<meta property="og:type" content="article">
<meta property="og:title" content="rye is coding">
<meta property="og:url" content="https://github.com/pinkyrie/pinkypiepie.git.io/2022/11/15/15/index.html">
<meta property="og:site_name" content="rye is coding">
<meta property="og:description" content="评价算法标准        stability  时间（最好 最坏 平均）  关键字比较次数 数据移动次数   空间（最好 最坏 平均）                       排序分为comparison sorting 和 counting sorting        In computer science, counting sort is an">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309217.png">
<meta property="og:image" content="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309187.png">
<meta property="og:image" content="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309028.png">
<meta property="og:image" content="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191943514.png">
<meta property="og:image" content="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309764.png">
<meta property="og:image" content="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309924.png">
<meta property="og:image" content="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191945893.png">
<meta property="og:image" content="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309412.png">
<meta property="og:image" content="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309584.png">
<meta property="og:image" content="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309702.png">
<meta property="og:image" content="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309638.png">
<meta property="og:image" content="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309827.png">
<meta property="og:image" content="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152310023.png">
<meta property="og:image" content="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152310505.png">
<meta property="og:image" content="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152310044.png">
<meta property="og:image" content="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309476.png">
<meta property="og:image" content="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152310564.png">
<meta property="og:image" content="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152310697.png">
<meta property="og:image" content="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152310442.png">
<meta property="og:image" content="https://raw.githubusercontent.com/pinkyrie/pic/main/202211192134408.png">
<meta property="article:published_time" content="2022-11-15T15:12:47.531Z">
<meta property="article:modified_time" content="2022-11-19T13:43:30.537Z">
<meta property="article:author" content="rye">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309217.png"><title>[ 文章无标题 ] | rye is coding</title><link ref="canonical" href="https://github.com/pinkyrie/pinkypiepie.git.io/2022/11/15/15/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" type="text/css"><link rel="stylesheet" href="/pinkypiepie.git.io/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/pinkypiepie.git.io/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fa fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">rye is coding</div><div class="header-banner-info__subtitle"></div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">[ 文章无标题 ]</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-11-15</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-11-19</span></span></div></header><div class="post-body">
        <h2 id="评价算法标准"   >
          <a href="#评价算法标准" class="heading-link"><i class="fas fa-link"></i></a><a href="#评价算法标准" class="headerlink" title="评价算法标准"></a>评价算法标准</h2>
      <ul>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43721542/article/details/106001300" >stability</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p>时间（最好 最坏 平均）</p>
<ul>
<li>关键字比较次数</li>
<li>数据移动次数</li>
</ul>
</li>
<li><p>空间（最好 最坏 平均）</p>
</li>
</ul>

        <h3 id="排序分为comparison-sorting-和-counting-sorting"   >
          <a href="#排序分为comparison-sorting-和-counting-sorting" class="heading-link"><i class="fas fa-link"></i></a><a href="#排序分为comparison-sorting-和-counting-sorting" class="headerlink" title="排序分为comparison sorting 和 counting sorting"></a>排序分为comparison sorting 和 counting sorting</h3>
      <ul>
<li>In <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computer_science" >computer science</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>, <strong>counting sort</strong> is an <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Algorithm" >algorithm</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> for <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Sorting_algorithm" >sorting</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> a collection of objects according to keys that are small positive <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Integer" >integers</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>; that is, it is an <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Integer_sorting" >integer sorting</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> algorithm. It operates by counting the number of objects that possess distinct key values, and applying prefix sum on those counts to determine the positions of each key value in the output sequence. Like other algorithms this sorting algorithm is not a comparison-based algorithm, it hashes the value in a temporary count array and uses them for sorting.</li>
</ul>

        <h3 id="排序分为internal-和-external"   >
          <a href="#排序分为internal-和-external" class="heading-link"><i class="fas fa-link"></i></a><a href="#排序分为internal-和-external" class="headerlink" title="排序分为internal 和 external"></a>排序分为internal 和 external</h3>
      
        <h2 id="insertion-sorting"   >
          <a href="#insertion-sorting" class="heading-link"><i class="fas fa-link"></i></a><a href="#insertion-sorting" class="headerlink" title="insertion sorting"></a>insertion sorting</h2>
      <ul>
<li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309217.png" alt="image-20221113163100785"></li>
</ul>

        <h3 id="basics："   >
          <a href="#basics：" class="heading-link"><i class="fas fa-link"></i></a><a href="#basics：" class="headerlink" title="basics："></a>basics：</h3>
      <ul>
<li><p>for small inputs</p>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/insertion-sort.html" >图演示</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
</ul>

        <h3 id="pseudo-code"   >
          <a href="#pseudo-code" class="heading-link"><i class="fas fa-link"></i></a><a href="#pseudo-code" class="headerlink" title="pseudo code"></a>pseudo code</h3>
      <ul>
<li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309187.png" alt="image-20221113163648161"></li>
</ul>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mark the first element as sorted</span><br><span class="line">for each unsorted element x</span><br><span class="line">extract x </span><br><span class="line">for j = lastSortedIndex down to 0</span><br><span class="line">if current element j &gt; x</span><br><span class="line">move sorted element to the right by 1</span><br><span class="line">break the loop and insert x here</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h3 id="C-code"   >
          <a href="#C-code" class="heading-link"><i class="fas fa-link"></i></a><a href="#C-code" class="headerlink" title="C++code"></a>C++code</h3>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insertion_Sort</span><span class="params">(ElementType A[], <span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">		<span class="type">int</span> tmp = A[i]; <span class="comment">//+1</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(A[j]&gt;A[i])&#123;</span><br><span class="line">				A[i]=A[j];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				A[j] = tmp; <span class="comment">//+1 解释了为什么是+2</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> i, key, j;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       key = arr[i];</span><br><span class="line">       j = i<span class="number">-1</span>;</span><br><span class="line">       <span class="comment">/* Move elements of arr[0..i-1], that are</span></span><br><span class="line"><span class="comment">          greater than key, to one position ahead</span></span><br><span class="line"><span class="comment">          of their current position */</span></span><br><span class="line">       <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key)</span><br><span class="line">       &#123;</span><br><span class="line">           arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">           j = j<span class="number">-1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       arr[j+<span class="number">1</span>] = key;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309028.png" alt="image-20221113170531829"></li>
</ul>

        <h3 id="复杂度"   >
          <a href="#复杂度" class="heading-link"><i class="fas fa-link"></i></a><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3>
      
        <h4 id="时间复杂度："   >
          <a href="#时间复杂度：" class="heading-link"><i class="fas fa-link"></i></a><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://cs.stackexchange.com/questions/21455/how-can-i-quantify-the-number-of-swaps-required-for-insertion-sort" >交换次数取决于逆序对的个数</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/time-complexity-insertion-sort-inversions/#:~:text=Therefore%20overall%20time%20complexity%20of,is%20sorted%20in%20reverse%20order." >详细解释时间复杂度与逆序对</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>If we take a closer look at the insertion sort code, we can notice that every iteration of while loop reduces one inversion. The while loop executes only if i &gt; j and arr[i] &lt; arr[j]. Therefore total number of while loop iterations (For all values of i) is same as number of inversions. Therefore overall time complexity of the insertion sort is O(n + f(n)) where f(n) is inversion count. If the inversion count is O(n), then the time complexity of insertion sort is O(n). In worst case, there can be n*(n-1)&#x2F;2 inversions. The worst case occurs when the array is sorted in reverse order. So the worst case time complexity of insertion sort is O(n2).</p>
<ul>
<li>第p趟插入<ul>
<li>最好：比较1次 <strong>移动两次</strong>（腾位置+插入新数）也就是两处+1</li>
<li>最坏：比较p次 移动<strong>p+2</strong>次 while loop里面会进行p次的移动 + 2</li>
</ul>
</li>
</ul>
<p>O(N^2)  最优情况下： O(N)  </p>
<p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191943514.png" alt="image-20221119194308341"></p>

        <h4 id="空间复杂度："   >
          <a href="#空间复杂度：" class="heading-link"><i class="fas fa-link"></i></a><a href="#空间复杂度：" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4>
      <p>O(1)原地排序（in place）</p>

        <h2 id="shell-sort（改进直接插入排序-优化insertion-sort）"   >
          <a href="#shell-sort（改进直接插入排序-优化insertion-sort）" class="heading-link"><i class="fas fa-link"></i></a><a href="#shell-sort（改进直接插入排序-优化insertion-sort）" class="headerlink" title="shell sort（改进直接插入排序 优化insertion sort）"></a>shell sort（改进直接插入排序 优化insertion sort）</h2>
      <ul>
<li><p>希尔排序，也称递减增量排序算法Shellsort is also known as diminishing increment sort.</p>
</li>
<li><p>增量：gap 该子数列相邻元素的下标差</p>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Shellsort" >reference wiki</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309764.png" alt="image-20221113214131923"></p>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://algostructure.com/sorting/shellsort.php" >Shell Sort Algorithm Animation - algostructure.com</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309924.png" alt="image-20221113215111601"></p>
</li>
</ul>

        <h3 id="特别：折半插入"   >
          <a href="#特别：折半插入" class="heading-link"><i class="fas fa-link"></i></a><a href="#特别：折半插入" class="headerlink" title="特别：折半插入"></a>特别：折半插入</h3>
      <ul>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34914588" >折半插入的增量</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><ul>
<li>增量：</li>
<li>增量取法 每次N&#x2F;2 &#x2F;2 &#x2F;2 &#x2F;2（折半）</li>
</ul>
</li>
</ul>

        <h3 id="c-code"   >
          <a href="#c-code" class="heading-link"><i class="fas fa-link"></i></a><a href="#c-code" class="headerlink" title="c++code"></a>c++code</h3>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shell_Sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">// Start with a big gap, then reduce the gap</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> gap = n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="comment">// Do a gapped insertion sort for this gap size.</span></span><br><span class="line">  <span class="comment">// The first gap elements arr[0..gap-1] are already in gapped order</span></span><br><span class="line">  <span class="comment">// keep adding one more element until the entire array is</span></span><br><span class="line">  <span class="comment">// gap sorted</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; n; i += <span class="number">1</span>) &#123;</span><br><span class="line">   <span class="comment">// add arr[i] to the elements that have been gap sorted</span></span><br><span class="line">   <span class="comment">// save arr[i] in temp and make a hole at position i</span></span><br><span class="line">   <span class="type">int</span> temp = arr[i];</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// shift earlier gap-sorted elements up until the correct</span></span><br><span class="line">   <span class="comment">// location for arr[i] is found</span></span><br><span class="line">   <span class="type">int</span> j;</span><br><span class="line">   <span class="keyword">for</span> (j = i; j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp; j -= gap)</span><br><span class="line">    arr[j] = arr[j - gap];</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// put temp (the original arr[i]) in its correct location</span></span><br><span class="line">   arr[j] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="复杂度-1"   >
          <a href="#复杂度-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3>
      
        <h4 id="时间复杂度"   >
          <a href="#时间复杂度" class="heading-link"><i class="fas fa-link"></i></a><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4>
      <ul>
<li><p><strong>Best Case Complexity</strong><br>When the given array list is already sorted the total count of comparisons of each interval is equal to the size of the given array.<br><em>So best case complexity is Ω(n log(n))</em><br><strong>Average Case Complexity</strong></p>
<p>The shell sort Average Case Complexity depends on the interval selected by the programmer.<br><em>θ(n log(n)2)</em>.</p>
<p><em>THE Average Case Complexity: O(n*log n)~O(n1.25)</em></p>
</li>
</ul>

        <h4 id="空间复杂度"   >
          <a href="#空间复杂度" class="heading-link"><i class="fas fa-link"></i></a><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4>
      <ul>
<li>O(1)</li>
</ul>

        <h2 id="bubble-sorting"   >
          <a href="#bubble-sorting" class="heading-link"><i class="fas fa-link"></i></a><a href="#bubble-sorting" class="headerlink" title="bubble sorting"></a>bubble sorting</h2>
      <ul>
<li>适用于链表和数组（因为只按照一个方向进行sort和比较）<ul>
<li>有的算法不一定适用于链表结构</li>
</ul>
</li>
<li>稳定算法</li>
<li>效率和排序序列的初始顺序有关</li>
</ul>

        <h3 id="pseudo-code-1"   >
          <a href="#pseudo-code-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#pseudo-code-1" class="headerlink" title="pseudo code"></a>pseudo code</h3>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.jianshu.com/p/648d87dc4cfc" >加入swapped优化 如果上一次遍历没有交换则已经有序</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Bubble_sort(list):                         // list 表示待排序序列</span><br><span class="line">    for i &lt;- 0 to length(list)-1:          // 对于元素个数为 n 的 list 序列，需遍历 n-1 次，这里用 [0,length(list)-1) 表示。</span><br><span class="line">        for j &lt;- 1 to length(list) - i:    // 从第 1 个元素开始遍历，遍历区间为 [1,length(list)-i)。</span><br><span class="line">            if list[j] &gt; list[j+1]:        // 若进行降序排序，则改成 &lt; 小于号</span><br><span class="line">                 swap(list[j] , list[j+1]) // 交换 2 个相邻元素的位置</span><br><span class="line">    return list                            // 返回排好序的序列</span><br></pre></td></tr></table></div></figure>


        <h3 id="c-code-1"   >
          <a href="#c-code-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#c-code-1" class="headerlink" title="c++ code"></a>c++ code</h3>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bubble_Sort</span><span class="params">(ElementType A[], <span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">1</span>;j&lt;N-i;j++)&#123; <span class="comment">//经过第i趟冒泡 有i个元素已经排好（在队尾）是最大的元素</span></span><br><span class="line">			<span class="keyword">if</span>(A[j]&lt;A[j<span class="number">-1</span>])&#123;</span><br><span class="line">				<span class="built_in">swap</span>(A[j],A[j<span class="number">-1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>优化版本：</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bubble_Sort</span><span class="params">(ElementType A[], <span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">		<span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">1</span>;j&lt;N-i;j++)&#123; <span class="comment">//经过第i趟冒泡 有i个元素已经排好（在队尾）是最大的元素</span></span><br><span class="line">			<span class="keyword">if</span>(A[j]&lt;A[j<span class="number">-1</span>])&#123;</span><br><span class="line">				<span class="built_in">swap</span>(A[j],A[j<span class="number">-1</span>]);</span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="复杂度-2"   >
          <a href="#复杂度-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h3>
      
        <h4 id="稳定性"   >
          <a href="#稳定性" class="heading-link"><i class="fas fa-link"></i></a><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4>
      <ul>
<li>因为每次比较后如果两个相邻元素相等我们并不会将他们交换，所以冒泡不会改变相同元素的下标，所以冒泡排序是一个稳定的排序</li>
</ul>

        <h4 id="时间复杂度-1"   >
          <a href="#时间复杂度-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4>
      <ul>
<li><p>最好情况下的时间复杂度：如果元素本来就是有序的，那么一趟冒泡排序既可以完成排序工作 因此最好情况的时间复杂度为O(n)</p>
<p>比较次数：n-1</p>
<p>移动次数：0</p>
</li>
<li><p>最差情况的时间复杂度：如果数据元素本来就是逆序的 最坏情况子下的时间复杂度为O(n^2)。</p>
<p>比较次数：n(n-1)&#x2F;2</p>
<p>移动次数：3n(n-1)&#x2F;2</p>
</li>
<li><p>平均时间复杂度：O(n^2)</p>
</li>
</ul>

        <h4 id="空间复杂度-1"   >
          <a href="#空间复杂度-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h4>
      <ul>
<li>O(1)</li>
</ul>

        <h2 id="selection-sort"   >
          <a href="#selection-sort" class="heading-link"><i class="fas fa-link"></i></a><a href="#selection-sort" class="headerlink" title="selection sort"></a>selection sort</h2>
      <ul>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zh.khanacademy.org/computing/computer-science/algorithms/sorting-algorithms/a/selection-sort-pseudocode#:~:text=%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E4%BC%AA%E4%BB%A3%E7%A0%81%201%20%E6%89%BE%E5%88%B0%E6%9C%80%E5%B0%8F%E7%9A%84%E5%8D%A1%E7%89%87%E3%80%82%20%E7%94%A8%E7%AC%AC%E4%B8%80%E5%BC%A0%E5%8D%A1%E4%BA%A4%E6%8D%A2%E5%AE%83%E3%80%82%202%20%E6%89%BE%E5%88%B0%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E5%8D%A1%E3%80%82,%E7%94%A8%E7%AC%AC%E4%BA%8C%E5%BC%A0%E5%8D%A1%E4%BA%A4%E6%8D%A2%E5%AE%83%E3%80%82%203%20%E6%89%BE%E5%88%B0%E7%AC%AC%E4%B8%89%E5%B0%8F%E7%9A%84%E5%8D%A1%E3%80%82%20%E7%94%A8%E7%AC%AC%E4%B8%89%E5%BC%A0%E5%8D%A1%E4%BA%A4%E6%8D%A2%E5%AE%83%E3%80%82%204%20%E9%87%8D%E5%A4%8D%E6%9F%A5%E6%89%BE%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9C%80%E5%B0%8F%E7%9A%84%E5%8D%A1%EF%BC%8C%E5%B9%B6%E5%B0%86%E5%85%B6%E4%BA%A4%E6%8D%A2%E5%88%B0%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%8C%E7%9B%B4%E5%88%B0%E5%AE%8C%E6%88%90%E5%AF%B9%E9%98%B5%E5%88%97%E7%9A%84%E6%8E%92%E5%BA%8F%E3%80%82" >演示</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li>类似bubble sort 优点是 交换次数只有n-1 </li>
<li>缺陷：没有利用前一趟比较遍历获取的信息</li>
</ul>

        <h3 id="c-code-2"   >
          <a href="#c-code-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#c-code-2" class="headerlink" title="c++ code"></a>c++ code</h3>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Selection_Sort</span><span class="params">(ElementType A[], <span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> k = i<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;N;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(A[j]&gt;A[i])&#123;</span><br><span class="line">				k=j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(k!=i<span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">swap</span>(A[k],A[i<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, min_idx;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// One by one move boundary of</span></span><br><span class="line">    <span class="comment">// unsorted subarray</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// Find the minimum element in</span></span><br><span class="line">        <span class="comment">// unsorted array</span></span><br><span class="line">        min_idx = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i+<span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; arr[min_idx])</span><br><span class="line">            min_idx = j;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Swap the found minimum element</span></span><br><span class="line">        <span class="comment">// with the first element</span></span><br><span class="line">        <span class="keyword">if</span>(min_idx!=i)</span><br><span class="line">            <span class="built_in">swap</span>(&amp;arr[min_idx], &amp;arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="复杂度-3"   >
          <a href="#复杂度-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#复杂度-3" class="headerlink" title="复杂度"></a>复杂度</h3>
      
        <h4 id="稳定性-1"   >
          <a href="#稳定性-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#稳定性-1" class="headerlink" title="稳定性"></a>稳定性</h4>
      <ul>
<li>不稳定算法（存在非相邻元素的交换）</li>
</ul>

        <h4 id="时间复杂度-2"   >
          <a href="#时间复杂度-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4>
      <ul>
<li><p>选择排序的复杂度分析。第一次内循环比较N - 1次，然后是N-2次，N-3次，……，最后一次内循环比较1次。<br>共比较的次数是 <code>(N - 1) + (N - 2) + ... + 1</code>，求等差数列和，得 <code>(N - 1 + 1)* N / 2 = N^2 / 2</code>。<br>舍去最高项系数，其时间复杂度为 <code>O(N^2)</code>。</p>
<p>虽然选择排序和冒泡排序的时间复杂度一样，但实际上，选择排序进行的交换操作很少，最多会发生 N - 1次交换。</p>
</li>
<li><p>运行时间和输入无关</p>
</li>
<li><p>选择排序的交换操作介于0和(n-1)次之间。选择排序的比较操作为n(n-1)&#x2F;2次之间。选择排序的赋值操作介于0和3(n-1)次之间。</p>
<p>比较次数O(n^2)，比较次数与关键字的初始状态无关，总的比较次数N &#x3D; (n-1) + (n-2) +…+ 1 &#x3D; n x (n-1)&#x2F;2。交换次数O(n)，最好情况是，已经有序，交换0次；最坏情况是，逆序，交换n-1次。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191945893.png" alt="image-20221119194542763"></p>

        <h2 id="heap-sort（优化selection-sort-快速找到最小元）"   >
          <a href="#heap-sort（优化selection-sort-快速找到最小元）" class="heading-link"><i class="fas fa-link"></i></a><a href="#heap-sort（优化selection-sort-快速找到最小元）" class="headerlink" title="heap sort（优化selection sort 快速找到最小元）"></a>heap sort（优化selection sort 快速找到最小元）</h2>
      <ul>
<li>充分利用了每一趟遍历比较的信息</li>
<li>堆分为<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%A4%A7%E6%A0%B9%E5%A0%86&spm=1001.2101.3001.7020" >大根堆</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;&#x3D; A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。<ul>
<li>heap可以用priority queue实现</li>
<li>Heapsort, sorts n numbers in place in O(n lg n) time. It uses an important data structure, called a heap, with which we can also implement a priority queue.</li>
<li>Using this model, we prove a lower bound of Ω(n lg n) on the worst-case running time of any comparison sort on n inputs, thus showing that heapsort and merge sort are asymptotically optimal comparison sorts.</li>
</ul>
</li>
<li>调整heap的时间复杂度（lgn）</li>
<li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309412.png" alt="image-20221027133800119"></li>
</ul>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://visualgo.net/zh/heap?slide=1" >建堆演示</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/u010711495/article/details/117386069" >建堆代码</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ul>
<li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309584.png" alt="image-20221110220027078"></p>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://cs.stackexchange.com/questions/141748/how-is-the-reccurence-of-max-heapify-tn-t2n-3-theta1" >堆的左子树的结点个数的限制</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p>计算父节点或者左右子节点的时候*2 或&#x2F;2 可以用计算机的shift bit进行计算</p>
</li>
</ul>

        <h4 id="max-heapify的时间复杂度（粗略的O-和-更贴合的Ω）"   >
          <a href="#max-heapify的时间复杂度（粗略的O-和-更贴合的Ω）" class="heading-link"><i class="fas fa-link"></i></a><a href="#max-heapify的时间复杂度（粗略的O-和-更贴合的Ω）" class="headerlink" title="max-heapify的时间复杂度（粗略的O 和 更贴合的Ω）"></a>max-heapify的时间复杂度（粗略的O 和 更贴合的Ω）</h4>
      <p>We can compute a simple upper bound on the running time of BUILD-MAX- HEAP as follows. Each call to MAX-HEAPIFY costs O(nlgn) time, and BUILD- MAX-HEAP makes O(n) such calls. Thus, the running time is O(nlgn). This upper bound, though correct, is not asymptotically tight.</p>
<p>We can derive a tighter bound by observing that the time for MAX-HEAPIFY torun at a node varies with the height of the node in the tree, and the heights of most nodes are small. Our tighter analysis relies on the properties that an  n-element heap has height </p>
<p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309702.png" alt="image-20221112091149489"></p>
<p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309638.png" alt="image-20221112203441025"></p>
<p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309827.png" alt="image-20221112203427151"></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/feliciafay/article/details/12869179" >叶子节点开始的下标</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ul>
<li><p>只需要求出叶子节点上一层的结点个数 大概为总结点个数的一半</p>
</li>
<li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152310023.png" alt="image-20221112092704508"></p>
</li>
<li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152310505.png" alt="image-20221112094046683"></p>
</li>
<li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152310044.png" alt="image-20221112203126918"></p>
</li>
</ul>

        <h3 id="time-complexity"   >
          <a href="#time-complexity" class="heading-link"><i class="fas fa-link"></i></a><a href="#time-complexity" class="headerlink" title="time complexity"></a>time complexity</h3>
      <ul>
<li><p>best case(all elements are identical) <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://cs.stackexchange.com/questions/138432/running-time-of-heap-sort-when-all-number-are-identical" >proof</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ul>
<li><p>The best case for heapsort would happen when all elements in the list to be sorted are identical. In such a case, for ‘n’ number of nodes-</p>
</li>
<li><p>Removing each node from the heap would take only a constant runtime, O(1). There would be no need to bring any node down or bring max valued node up, as all items are identical.</p>
</li>
<li><p>Since we do this for every node, the total number of moves would be n * O(1).</p>
<p>Therefore, the runtime in the best case would be O(n).</p>
</li>
</ul>
</li>
</ul>

        <h3 id="code-c"   >
          <a href="#code-c" class="heading-link"><i class="fas fa-link"></i></a><a href="#code-c" class="headerlink" title="code c++"></a>code c++</h3>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> N, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Find largest among root, left child and right child</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Initialize largest as root</span></span><br><span class="line">    <span class="type">int</span> largest = i;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// left = 2*i + 1</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// right = 2*i + 2</span></span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// If left child is larger than root</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; N &amp;&amp; arr[left] &gt; arr[largest])</span><br><span class="line"> </span><br><span class="line">        largest = left;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// If right child is larger than largest</span></span><br><span class="line">    <span class="comment">// so far</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; N &amp;&amp; arr[right] &gt; arr[largest])</span><br><span class="line"> </span><br><span class="line">        largest = right;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Swap and continue heapifying if root is not largest</span></span><br><span class="line">    <span class="comment">// If largest is not root</span></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">swap</span>(&amp;arr[i], &amp;arr[largest]);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Recursively heapify the affected</span></span><br><span class="line">        <span class="comment">// sub-tree</span></span><br><span class="line">        <span class="built_in">heapify</span>(arr, N, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Main function to do heap sort</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Build max heap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = N / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">heapify</span>(arr, N, i);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Heap sort</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">swap</span>(&amp;arr[<span class="number">0</span>], &amp;arr[i]);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Heapify root element to get highest element at</span></span><br><span class="line">        <span class="comment">// root again</span></span><br><span class="line">        <span class="built_in">heapify</span>(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// A utility function to print array of size n</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Driver&#x27;s code</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123; <span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</span><br><span class="line">    <span class="type">int</span> N = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Function call</span></span><br><span class="line">    <span class="built_in">heapSort</span>(arr, N);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sorted array is\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printArray</span>(arr, N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/cpp-program-for-heap-sort/" >reference</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>
        <h2 id="merge-sorting"   >
          <a href="#merge-sorting" class="heading-link"><i class="fas fa-link"></i></a><a href="#merge-sorting" class="headerlink" title="merge sorting"></a>merge sorting</h2>
      <ul>
<li><p>对两个有序的子序列 </p>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/124356219" >basics</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309476.png" alt="image-20221112232227825"></p>
</li>
<li><p>The recursion “bottoms out” when the sequence to be sorted has length 1, in which</p>
<p>case there is no work to be done, since every sequence of length 1 is already in</p>
<p>sorted order.</p>
</li>
</ul>

        <h3 id="merge"   >
          <a href="#merge" class="heading-link"><i class="fas fa-link"></i></a><a href="#merge" class="headerlink" title="merge"></a>merge</h3>
      <p>When merging two sorted arrays into a single larger one, we need space to hold the merged result. Since the arrays we’ll be combining have O(n) items, we’ll need O(n) space in total but because we are doing recursion calls so this extra array is goin to be copied log (n) times so the space complexity is O(n log n) here.</p>
<ul>
<li>merge用两个辅助数组</li>
</ul>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void Merge(T Data[], int start, int mid, int end)&#123;</span><br><span class="line">	int len1 = mid-start+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>merge用一个辅助数组</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = low; <span class="type">int</span> j = mid + <span class="number">1</span>; <span class="type">int</span> k = low;</span><br><span class="line">	<span class="type">int</span>[] auxiliaryArr = <span class="keyword">new</span> <span class="type">int</span>[high+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high)&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] &lt; arr[j])&#123;</span><br><span class="line">			auxiliaryArr[k++] = arr[i++];&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			auxiliaryArr[k++] = arr[j++];&#125;</span><br><span class="line">         &#125;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid)&#123;</span><br><span class="line">		auxiliaryArr[k++] = arr[i++];&#125;</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= high)&#123;</span><br><span class="line">         auxiliaryArr[k++] = arr[j++];&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> r = low; r &lt;= high; r++)&#123;</span><br><span class="line">		arr[r] = auxiliaryArr[r];&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152310564.png" alt="image-20221113111430021"></p>
</li>
<li><p>&#96;&#96;&#96;c++<br>void merge(vector<Comparable>&amp; a, int L, int R, int RightEnd) {<br>int size &#x3D; a.size();<br>int LeftEnd &#x3D; R - 1;<br>int p &#x3D; L;<br>int num &#x3D; RightEnd - L + 1;<br>vector<Comparable> tmp(size);<br>while (L &lt;&#x3D; LeftEnd &amp;&amp; R &lt;&#x3D; RightEnd) {<br>    if (a[L] &lt;&#x3D; a[R])<br>        tmp[p++] &#x3D; a[L++];<br>    else<br>        tmp[p++] &#x3D; a[R++];<br>}<br>while (L &lt;&#x3D; LeftEnd)<br>    tmp[p++] &#x3D; a[L++];<br>while (R &lt;&#x3D; RightEnd)<br>    tmp[p++] &#x3D; a[R++];<br>for (int i &#x3D; 0; i &lt;num; i++,RightEnd–)<br>    a[RightEnd] &#x3D; tmp[RightEnd];<br>}</p>
<p>template <class Comparable><br>void mergeImproved( vector<Comparable> &amp;a ) {<br>int n &#x3D; a.size();<br>int i, s;<br>int t &#x3D; 1;<br>while (t &lt; n) {<br>    s &#x3D; t;<br>    t <em>&#x3D; 2;<br>    i &#x3D; 0;<br>    while (i + t &lt; n) {<br>        merge(a, i, i + s, i + 2</em>s - 1);<br>        i &#x3D; i + t;<br>    }<br>    if (i + s &lt; n) {<br>        merge(a, i, i + s, n - 1);<br>    }<br>}<br>}</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### top-down(recursive)</span><br><span class="line"></span><br><span class="line">- References: http://csg.sph.umich.edu/abecasis/class/2006/615.09.pdf</span><br><span class="line"></span><br><span class="line">### bottom-up(non-recursive)</span><br><span class="line"></span><br><span class="line">- ![image-20221113112739158](https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309346.png)</span><br><span class="line"></span><br><span class="line">### time complexity</span><br><span class="line"></span><br><span class="line">#### 次数分析（时间复杂度）</span><br><span class="line"></span><br><span class="line">- ![image-20221113113901708](https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309672.png)</span><br><span class="line"></span><br><span class="line">[reference](https://zhuanlan.zhihu.com/p/341225128#:~:text=%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E6%9C%80%E5%9D%8F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%3A%20%E6%A0%B8%E5%BF%83%E7%82%B9%3A%E4%B8%A4%E4%B8%AA%E5%BA%8F%E5%88%97%E5%90%84%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%A7%E5%B0%8F%E4%BA%A4%E5%8F%89%E6%8E%92%E5%88%97%EF%BC%8C%E6%AD%A4%E6%97%B6%E9%9C%80%E8%A6%81%20m%2Bn-1%20%E6%AD%A4%E6%AF%94%E8%BE%83%20%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%3A%20%E8%AE%BE%20n%20%E4%B8%BA%E5%BE%85%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0%EF%BC%8C,%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E7%9A%84%E5%BA%8F%E5%88%97%E5%90%88%E5%B9%B6%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%90%AB%E6%9C%89%20n%20%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E7%9A%84%E5%BA%8F%E5%88%97%E6%89%80%E9%9C%80%E8%A6%81%E7%9A%84%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%20%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%3A%20O%20%28n%29%2C%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AA%E9%A2%9D%E5%A4%96%E7%9A%84n%E7%BB%B4%E6%95%B0%E7%BB%84%20I%20%5B%5D)</span><br><span class="line"></span><br><span class="line">[数比较次数](https://math.stackexchange.com/questions/3649182/merge-sort-maximum-comparisons)</span><br><span class="line"></span><br><span class="line">- 例子：</span><br><span class="line">  假设二路归并</span><br><span class="line">  1 2 3 4</span><br><span class="line">  12  34   **2次**</span><br><span class="line">  2&lt;4  2&lt;3  **2次**   不用再继续  共4次</span><br><span class="line">  1 2 3 4 有序</span><br><span class="line"></span><br><span class="line">  2314 </span><br><span class="line">  23  14  **2次**</span><br><span class="line">  3&lt;4  3&gt;1  **2次**   再用2比较</span><br><span class="line">  2&gt;1       **1次**   插入</span><br><span class="line">  1 2 3 4 有序  共5次</span><br><span class="line"></span><br><span class="line">- 极端的例子 1357 2468 ：每一个都要互相比较 m+n-1可以比完一个序列 然后最后一个数字没有比较直接加在尾巴就好</span><br><span class="line"></span><br><span class="line">- [非递归](https://www.cnblogs.com/xing901022/p/3671771.html)</span><br><span class="line"></span><br><span class="line">- [非递归](https://www.cnblogs.com/liushang0419/archive/2011/09/19/2181476.html#:~:text=%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E5%A6%82%E4%B8%8B%EF%BC%8C%E6%80%9D%E6%83%B3%E5%92%8C%E9%80%92%E5%BD%92%E6%AD%A3%E5%A5%BD%E7%9B%B8%E5%8F%8D%EF%BC%8C%E5%8E%9F%E6%9D%A5%E7%9A%84%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B%E6%98%AF%E5%B0%86%E5%BE%85%E6%8E%92%E5%BA%8F%E9%9B%86%E5%90%88%E4%B8%80%E5%88%86%E4%B8%BA%E4%BA%8C%EF%BC%8C%E7%9B%B4%E8%87%B3%E6%8E%92%E5%BA%8F%E9%9B%86%E5%90%88%E5%B0%B1%E5%89%A9%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E4%BD%8D%E7%BD%AE%EF%BC%8C%E7%84%B6%E5%90%8E%E4%B8%8D%E6%96%AD%E7%9A%84%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%A5%BD%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84%E3%80%82,%E6%89%80%E4%BB%A5%E9%9D%9E%E9%80%92%E5%BD%92%E6%80%9D%E6%83%B3%E4%B8%BA%EF%BC%8C%E5%B0%86%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%9B%B8%E9%82%BB%E5%85%83%E7%B4%A0%E4%B8%A4%E4%B8%A4%E9%85%8D%E5%AF%B9%E3%80%82%20%E7%94%A8merge%E5%87%BD%E6%95%B0%E5%B0%86%E4%BB%96%E4%BB%AC%E6%8E%92%E5%BA%8F%EF%BC%8C%E6%9E%84%E6%88%90n%2F2%E7%BB%84%E9%95%BF%E5%BA%A6%E4%B8%BA2%E7%9A%84%E6%8E%92%E5%BA%8F%E5%A5%BD%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%AE%B5%EF%BC%8C%E7%84%B6%E5%90%8E%E5%86%8D%E5%B0%86%E4%BB%96%E4%BB%AC%E6%8E%92%E5%BA%8F%E6%88%90%E9%95%BF%E5%BA%A6%E4%B8%BA4%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%AE%B5%EF%BC%8C%E5%A6%82%E6%AD%A4%E7%BB%A7%E7%BB%AD%E4%B8%8B%E5%8E%BB%EF%BC%8C%E7%9B%B4%E8%87%B3%E6%95%B4%E4%B8%AA%E6%95%B0%E7%BB%84%E6%8E%92%E5%A5%BD%E5%BA%8F%E3%80%82)</span><br><span class="line"></span><br><span class="line">#### every element is same</span><br><span class="line"></span><br><span class="line">- [还是O(nlogn)](https://stackoverflow.com/questions/66921626/running-time-of-merge-sort-all-elements-are-identical)</span><br><span class="line"></span><br><span class="line">### space complexity</span><br><span class="line"></span><br><span class="line">- ![image-20221117230415591](https://raw.githubusercontent.com/pinkyrie/pic/main/202211172318365.png)</span><br><span class="line"></span><br><span class="line">- O(n)</span><br><span class="line"></span><br><span class="line">## redix sort</span><br><span class="line"></span><br><span class="line">- [animation](https://yongdanielliang.github.io/animation/web/RadixSort.html)</span><br><span class="line"></span><br><span class="line">- 次位优先 （least significant digit first</span><br><span class="line"></span><br><span class="line">  ![image-20221027144856339](https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309963.png)</span><br><span class="line"></span><br><span class="line">- ![image-20221112231135913](https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309253.png)</span><br><span class="line"></span><br><span class="line">- ![image-20221119214322667](https://raw.githubusercontent.com/pinkyrie/pic/main/202211192143157.png)</span><br><span class="line"></span><br><span class="line">## heap sort</span><br><span class="line"></span><br><span class="line">- heap可以用priority queue实现</span><br><span class="line">- Heapsort, presented in Chapter 6, sorts n numbers in place in O(n lg n) time. It uses an important data structure, called a heap, with which we can also implement a priority queue.</span><br><span class="line">- Using this model, we prove a lower bound of Ω(n lg n) on the worst-case running time of any comparison sort on n inputs, thus showing that heapsort and merge sort are asymptotically optimal comparison sorts.</span><br><span class="line"></span><br><span class="line">堆总是一棵完全二叉树。</span><br><span class="line"></span><br><span class="line">[建堆演示](https://visualgo.net/zh/heap?slide=1)</span><br><span class="line"></span><br><span class="line">[建堆代码](https://blog.csdn.net/u010711495/article/details/117386069)</span><br><span class="line"></span><br><span class="line">- ![image-20221110220027078](https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309584.png)</span><br><span class="line"></span><br><span class="line">- [堆的左子树的结点个数的限制](https://cs.stackexchange.com/questions/141748/how-is-the-reccurence-of-max-heapify-tn-t2n-3-theta1)</span><br><span class="line"></span><br><span class="line">- 计算父节点或者左右子节点的时候*2 或/2 可以用计算机的shift bit进行计算</span><br><span class="line"></span><br><span class="line">#### max-heapify的时间复杂度（粗略的O 和 更贴合的Ω）</span><br><span class="line"></span><br><span class="line">We can compute a simple upper bound on the running time of BUILD-MAX- HEAP as follows. Each call to MAX-HEAPIFY costs O(nlgn) time, and BUILD- MAX-HEAP makes O(n) such calls. Thus, the running time is O(nlgn). This upper bound, though correct, is not asymptotically tight.</span><br><span class="line"></span><br><span class="line">We can derive a tighter bound by observing that the time for MAX-HEAPIFY torun at a node varies with the height of the node in the tree, and the heights of most nodes are small. Our tighter analysis relies on the properties that an  n-element heap has height </span><br><span class="line"></span><br><span class="line">![image-20221112091149489](https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309702.png)</span><br><span class="line"></span><br><span class="line">![image-20221112203441025](https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309638.png)</span><br><span class="line"></span><br><span class="line">![image-20221112203427151](https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309827.png)</span><br><span class="line"></span><br><span class="line">[叶子节点开始的下标](https://blog.csdn.net/feliciafay/article/details/12869179)</span><br><span class="line"></span><br><span class="line">- 只需要求出叶子节点上一层的结点个数 大概为总结点个数的一半</span><br><span class="line">- ![image-20221112092704508](https://raw.githubusercontent.com/pinkyrie/pic/main/202211152310023.png)</span><br><span class="line">- ![image-20221112094046683](https://raw.githubusercontent.com/pinkyrie/pic/main/202211152310505.png)</span><br><span class="line"></span><br><span class="line">- ![image-20221112203126918](https://raw.githubusercontent.com/pinkyrie/pic/main/202211152310044.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### time complexity </span><br><span class="line"></span><br><span class="line">- best case(all elements are identical) [proof](https://cs.stackexchange.com/questions/138432/running-time-of-heap-sort-when-all-number-are-identical)</span><br><span class="line"></span><br><span class="line">  - The best case for heapsort would happen when all elements in the list to be sorted are identical. In such a case, for &#x27;n&#x27; number of nodes-</span><br><span class="line"></span><br><span class="line">  - Removing each node from the heap would take only a constant runtime, O(1). There would be no need to bring any node down or bring max valued node up, as all items are identical.</span><br><span class="line"></span><br><span class="line">  - Since we do this for every node, the total number of moves would be n * O(1).</span><br><span class="line"></span><br><span class="line">    Therefore, the runtime in the best case would be O(n).</span><br><span class="line"></span><br><span class="line">### code c++</span><br><span class="line"></span><br><span class="line">[reference](https://www.geeksforgeeks.org/cpp-program-for-heap-sort/)</span><br><span class="line"></span><br><span class="line">## quick sort</span><br><span class="line"></span><br><span class="line">- ![image-20221112205348607](https://raw.githubusercontent.com/pinkyrie/pic/main/202211152310677.png)</span><br><span class="line"></span><br><span class="line">### features:</span><br><span class="line"></span><br><span class="line">-  divide-and-conquer</span><br><span class="line"></span><br><span class="line">  - 1. Divide: Partition the list.To partition the list, we first choose some element from the list for which we hope about half the elements will come before and half after. Call this element the pivot. Then we partition the elements so that all those with values less than the pivot come in one sublist and all those with greater values come in another. 2. Recursion: Recursively sort the sublists separately. 3. Conquer: Put the sorted sublists together.</span><br><span class="line"></span><br><span class="line">  - 3 steps</span><br><span class="line"></span><br><span class="line">  - ![image-20221112205710744](https://raw.githubusercontent.com/pinkyrie/pic/main/202211152310063.png)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">  ![image-20221112205746761](https://raw.githubusercontent.com/pinkyrie/pic/main/202211152310327.png)</span><br><span class="line"></span><br><span class="line">### partitioning: </span><br><span class="line"></span><br><span class="line">- ![image-20221112211056367](https://raw.githubusercontent.com/pinkyrie/pic/main/202211152310514.png)</span><br><span class="line"></span><br><span class="line">- The running time of quicksort depends on whether the partitioning is balanced or unbalanced, which in turn depends on which elements are used for partitioning. If the partitioning is balanced, the algorithm runs asymptotically as fast as merge sort. If the partitioning is unbalanced, however, it can run asymptotically as slowly as insertion sort.</span><br><span class="line"></span><br><span class="line">#### wost case partition</span><br><span class="line"></span><br><span class="line">- ![image-20221112212238759](https://raw.githubusercontent.com/pinkyrie/pic/main/202211152310967.png)</span><br><span class="line"></span><br><span class="line">#### bast case partition</span><br><span class="line"></span><br><span class="line">- ![image-20221112212327125](https://raw.githubusercontent.com/pinkyrie/pic/main/202211152310289.png)</span><br><span class="line"></span><br><span class="line">### code</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">template &lt;class Comparable&gt;</span><br><span class="line">void choosePivot( vector&lt;Comparable&gt; &amp;a, int first, int last ) &#123;</span><br><span class="line">	srand(time(NULL));</span><br><span class="line">	int random = first + rand() % (last - first);</span><br><span class="line">	objectSwap(a[random], a[first]);//随机找到第一个数字作为pivot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class Comparable&gt;</span><br><span class="line">void partition( vector&lt;Comparable&gt; &amp;a, int first, int last, int &amp;pivotIndex )&#123;</span><br><span class="line">	choosePivot(a, first, last);</span><br><span class="line">	int i = first, j = last;</span><br><span class="line">	while (i &lt;= j) &#123;</span><br><span class="line">		while (i &lt;= j &amp;&amp; a[i] &lt;= a[pivotIndex])</span><br><span class="line">			i++;</span><br><span class="line">		while (i &lt;= j &amp;&amp; a[j] &gt; a[pivotIndex])</span><br><span class="line">			j--;</span><br><span class="line">		if (i &lt; j) &#123;</span><br><span class="line">			objectSwap(a[j], a[i]);</span><br><span class="line">			i++;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	objectSwap(a[pivotIndex], a[j]);</span><br><span class="line">	pivotIndex = j;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class Comparable&gt;</span><br><span class="line">void quicksort( vector&lt;Comparable&gt; &amp;a, int first, int last ) &#123;</span><br><span class="line">	if (last &lt;= first)</span><br><span class="line">		return;</span><br><span class="line">	if (first &lt; last) &#123;</span><br><span class="line">		int pivotIndex = first;</span><br><span class="line">		partition(a, first, last, pivotIndex);</span><br><span class="line">		quicksort(a, first, pivotIndex - 1);</span><br><span class="line">		quicksort(a, pivotIndex + 1, last);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class Comparable&gt;</span><br><span class="line">void quicksort( vector&lt;Comparable&gt; &amp;a ) &#123;</span><br><span class="line">	int first = 0;</span><br><span class="line">	int last = a.size() - 1;</span><br><span class="line">	quicksort(a, first, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h3 id="比较次数-x2F-移动次数"   >
          <a href="#比较次数-x2F-移动次数" class="heading-link"><i class="fas fa-link"></i></a><a href="#比较次数-x2F-移动次数" class="headerlink" title="比较次数&#x2F;移动次数"></a>比较次数&#x2F;移动次数</h3>
      <ul>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/XueWang1/article/details/78118758" >compare times</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ul>

        <h3 id="time-complexity-1"   >
          <a href="#time-complexity-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#time-complexity-1" class="headerlink" title="time complexity"></a>time complexity</h3>
      
        <h4 id="worst-case"   >
          <a href="#worst-case" class="heading-link"><i class="fas fa-link"></i></a><a href="#worst-case" class="headerlink" title="worst case"></a>worst case</h4>
      <ul>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/when-does-the-worst-case-of-quicksort-occur/" >reference</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p>\1) Array is already sorted in the same order.<br>\2) Array is already sorted in reverse order.<br>\3) All elements are the same (a special case of cases 1 and 2) </p>
</li>
<li><p>演示比较次数和交换次数（worst case）<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://iq.opengenus.org/worst-case-of-quick-sort/" >reference</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
</ul>

        <h3 id="space-complexity"   >
          <a href="#space-complexity" class="heading-link"><i class="fas fa-link"></i></a><a href="#space-complexity" class="headerlink" title="space complexity"></a>space complexity</h3>
      <ul>
<li>Choose a pivot somehow.</li>
<li>Partition the array into two parts (smaller than the pivot, larger than the pivot).</li>
<li>Recursively sort the first part, then recursively sort the second part.</li>
</ul>
<p>Each recursive call uses O(1) words in local variables, hence the total space complexity is proportional to the height of the recursion tree.</p>
<p>The height of the recursion tree is always at least Ω(log⁡n), hence this is a <em>lower bound</em> on the space complexity. If you choose the pivot at random or using a good heuristic, then the recursion tree will have height O(log⁡n), and so the space complexity is Θ(logn)Θ(log⁡n). If the pivot can be chosen adversarially, you can cause the recursion tree to have height Θ(n)Θ(n), causing the worst-case space complexity to be Θ(n).</p>

        <h2 id="decision-tree-model"   >
          <a href="#decision-tree-model" class="heading-link"><i class="fas fa-link"></i></a><a href="#decision-tree-model" class="headerlink" title="decision tree model"></a>decision tree model</h2>
      <p>- </p>

        <h2 id="递归树推算递归的时间复杂度"   >
          <a href="#递归树推算递归的时间复杂度" class="heading-link"><i class="fas fa-link"></i></a><a href="#递归树推算递归的时间复杂度" class="headerlink" title="递归树推算递归的时间复杂度"></a>递归树推算递归的时间复杂度</h2>
      <ul>
<li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152310697.png" alt="image-20221113103554258"></p>
</li>
<li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152310442.png" alt="image-20221113103710337"></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211192134408.png" alt="image-20221119213401509"></p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://github.com/pinkyrie/pinkypiepie.git.io">rye</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://github.com/pinkyrie/pinkypiepie.git.io/2022/11/15/15/">https://github.com/pinkyrie/pinkypiepie.git.io/2022/11/15/15/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-share"><div class="social-share" data-sites="qzone, qq, weibo, wechat, douban, linkedin, facebook, twitter, google">Share to: </div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/pinkypiepie.git.io/2022/11/16/12/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">[ 文章无标题 ]</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/pinkypiepie.git.io/2022/10/16/leetcode/"><span class="paginator-prev__text">1-n的数字中一共出现了多少个1</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%84%E4%BB%B7%E7%AE%97%E6%B3%95%E6%A0%87%E5%87%86"><span class="toc-number">1.</span> <span class="toc-text">
          评价算法标准</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E5%88%86%E4%B8%BAcomparison-sorting-%E5%92%8C-counting-sorting"><span class="toc-number">1.1.</span> <span class="toc-text">
          排序分为comparison sorting 和 counting sorting</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E5%88%86%E4%B8%BAinternal-%E5%92%8C-external"><span class="toc-number">1.2.</span> <span class="toc-text">
          排序分为internal 和 external</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#insertion-sorting"><span class="toc-number">2.</span> <span class="toc-text">
          insertion sorting</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#basics%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">
          basics：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pseudo-code"><span class="toc-number">2.2.</span> <span class="toc-text">
          pseudo code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-code"><span class="toc-number">2.3.</span> <span class="toc-text">
          C++code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.4.</span> <span class="toc-text">
          复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A"><span class="toc-number">2.4.1.</span> <span class="toc-text">
          时间复杂度：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A"><span class="toc-number">2.4.2.</span> <span class="toc-text">
          空间复杂度：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shell-sort%EF%BC%88%E6%94%B9%E8%BF%9B%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-%E4%BC%98%E5%8C%96insertion-sort%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">
          shell sort（改进直接插入排序 优化insertion sort）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%88%AB%EF%BC%9A%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5"><span class="toc-number">3.1.</span> <span class="toc-text">
          特别：折半插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-code"><span class="toc-number">3.2.</span> <span class="toc-text">
          c++code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-1"><span class="toc-number">3.3.</span> <span class="toc-text">
          复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">3.3.1.</span> <span class="toc-text">
          时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">3.3.2.</span> <span class="toc-text">
          空间复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bubble-sorting"><span class="toc-number">4.</span> <span class="toc-text">
          bubble sorting</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pseudo-code-1"><span class="toc-number">4.1.</span> <span class="toc-text">
          pseudo code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-code-1"><span class="toc-number">4.2.</span> <span class="toc-text">
          c++ code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-2"><span class="toc-number">4.3.</span> <span class="toc-text">
          复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-number">4.3.1.</span> <span class="toc-text">
          稳定性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-1"><span class="toc-number">4.3.2.</span> <span class="toc-text">
          时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-1"><span class="toc-number">4.3.3.</span> <span class="toc-text">
          空间复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#selection-sort"><span class="toc-number">5.</span> <span class="toc-text">
          selection sort</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#c-code-2"><span class="toc-number">5.1.</span> <span class="toc-text">
          c++ code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-3"><span class="toc-number">5.2.</span> <span class="toc-text">
          复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%B3%E5%AE%9A%E6%80%A7-1"><span class="toc-number">5.2.1.</span> <span class="toc-text">
          稳定性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-2"><span class="toc-number">5.2.2.</span> <span class="toc-text">
          时间复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#heap-sort%EF%BC%88%E4%BC%98%E5%8C%96selection-sort-%E5%BF%AB%E9%80%9F%E6%89%BE%E5%88%B0%E6%9C%80%E5%B0%8F%E5%85%83%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">
          heap sort（优化selection sort 快速找到最小元）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#max-heapify%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%88%E7%B2%97%E7%95%A5%E7%9A%84O-%E5%92%8C-%E6%9B%B4%E8%B4%B4%E5%90%88%E7%9A%84%CE%A9%EF%BC%89"><span class="toc-number">6.0.1.</span> <span class="toc-text">
          max-heapify的时间复杂度（粗略的O 和 更贴合的Ω）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#time-complexity"><span class="toc-number">6.1.</span> <span class="toc-text">
          time complexity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#code-c"><span class="toc-number">6.2.</span> <span class="toc-text">
          code c++</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#merge-sorting"><span class="toc-number">8.</span> <span class="toc-text">
          merge sorting</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#merge"><span class="toc-number">8.1.</span> <span class="toc-text">
          merge</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E6%AC%A1%E6%95%B0-x2F-%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0"><span class="toc-number">8.2.</span> <span class="toc-text">
          比较次数&#x2F;移动次数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#time-complexity-1"><span class="toc-number">8.3.</span> <span class="toc-text">
          time complexity</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#worst-case"><span class="toc-number">8.3.1.</span> <span class="toc-text">
          worst case</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#space-complexity"><span class="toc-number">8.4.</span> <span class="toc-text">
          space complexity</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#decision-tree-model"><span class="toc-number">9.</span> <span class="toc-text">
          decision tree model</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%A0%91%E6%8E%A8%E7%AE%97%E9%80%92%E5%BD%92%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">10.</span> <span class="toc-text">
          递归树推算递归的时间复杂度</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://github.com/pinkyrie/pic/blob/main/202204272046093.JPG?raw=true" alt="avatar"></div><p class="sidebar-ov-author__text">be happy</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/pinkyrie" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="954365771" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">43</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">6</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">4</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/pinkypiepie.git.io/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2023</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>rye</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><script src="/pinkypiepie.git.io/js/utils.js?v=2.6.2"></script><script src="/pinkypiepie.git.io/js/stun-boot.js?v=2.6.2"></script><script src="/pinkypiepie.git.io/js/scroll.js?v=2.6.2"></script><script src="/pinkypiepie.git.io/js/header.js?v=2.6.2"></script><script src="/pinkypiepie.git.io/js/sidebar.js?v=2.6.2"></script></body></html>