<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/10/28/RAII%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2024/10/28/RAII%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="02-0-RAII内存管理"><a href="#02-0-RAII内存管理" class="headerlink" title="02.0.RAII内存管理"></a>02.0.RAII内存管理</h1><h2 id="不可滥用封装——封装的目的是维护相关属性的不变性"><a href="#不可滥用封装——封装的目的是维护相关属性的不变性" class="headerlink" title="不可滥用封装——封装的目的是维护相关属性的不变性"></a>不可滥用封装——封装的目的是维护相关属性的不变性</h2><p>正面例子：vector</p><ul><li>由于对单个元素的增删操作会影响到vector的size以及资源分配大小，因此需要打包操作作为一个原子（不可分割）来避免程序员疏忽犯错</li></ul><p>反面例子：三元tuple使用封装 (x)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vec3</span>&#123;<br><span class="hljs-type">float</span> x,y,z;<br>&#125;<br><span class="hljs-comment">// struct足够，不需要class和getX setX方法</span><br></code></pre></td></tr></table></figure><ul><li>不需要对一个<code>(x,y,z)</code>写<code>getter</code>和<code>setter</code>因为彼此是独立的</li></ul><h3 id="封装类——构造函数"><a href="#封装类——构造函数" class="headerlink" title="封装类——构造函数"></a>封装类——构造函数</h3><p>成员初始化列表member list initializer: </p><ul><li>const，reference成员必须在类构造之前初始化，必须用成员列表initialize</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> constantValue;       <span class="hljs-comment">// const 成员</span><br>    std::string&amp; referenceMember;  <span class="hljs-comment">// 引用成员</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数，使用成员初始化列表对 const 和引用成员进行初始化</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> value, std::string&amp; ref)<br>        : <span class="hljs-built_in">constantValue</span>(value), <span class="hljs-built_in">referenceMember</span>(ref) &#123;<br>        <span class="hljs-comment">// 构造函数主体</span><br>       <br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>避免重复初始化，更高效</li></ul><p><code>explicit</code>修饰构造函数:</p><ul><li>单参数时：禁止隐式的类型转换</li><li>多参数时：（同单参数）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pig</span> &#123;<br>    std::string m_name;<br>    <span class="hljs-type">int</span> m_weight;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Pig</span><span class="hljs-params">(std::string name, <span class="hljs-type">int</span> weight)</span></span><br><span class="hljs-function">        : m_name(name)</span><br><span class="hljs-function">        , m_weight(weight)</span><br><span class="hljs-function">    &#123;</span>&#125;<br><br>    <span class="hljs-built_in">Pig</span>(Pig <span class="hljs-type">const</span> &amp;other) = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(Pig pig)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;name: &quot;</span> &lt;&lt; pig.m_name &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;weight: &quot;</span> &lt;&lt; pig.m_weight &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">show</span>(&#123;<span class="hljs-string">&quot;pig1&quot;</span>,<span class="hljs-number">20</span>&#125;); <span class="hljs-comment">//编译不通过 如果去掉explicit 可以执行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>注意：并不是绝对的要always加上<code>explicit</code> sometimes需要隐式类型转换带来方便哦</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// QString(const char *str); 没有explicit 所以支持隐式转换</span><br>QString str = <span class="hljs-string">&quot;Hello, world!&quot;</span>; <span class="hljs-comment">// 隐式转换 const char* 到 QString</span><br></code></pre></td></tr></table></figure><p>Ref: <a href="https://en.cppreference.com/w/cpp/language/constructor">构造函数和成员初始值设定项列表 - cppreference.com — Constructors and member initializer lists - cppreference.com</a></p><p>() vs {}——cast类型小心丢失精度:</p><ul><li>()强制类型转换，{}更加安全</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">int</span>(<span class="hljs-number">3.14f</span>) <span class="hljs-comment">//不出错</span><br><span class="hljs-type">int</span>&#123;<span class="hljs-number">3.14f</span>&#125; <span class="hljs-comment">//报错 &#123;&#125;是非强制转换</span><br><span class="hljs-comment">//推荐使用：</span><br><span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">3.14f</span>);<br><span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(<span class="hljs-number">0xb8000</span>);<br></code></pre></td></tr></table></figure><p>使用编译器的对类的默认构造函数时：</p><ul><li>这些成员类型不会被初始化为 0：<ul><li>int, float, double 等基础类型</li><li>void *, Object * 等指针类型</li><li>完全由这些类型组成的类</li></ul></li><li>这些类型被称为 <strong>POD（plain-old-data）</strong></li></ul><p>应用例子——光线追踪函数返回值有多个属性时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">HitRes</span>&#123;<br><span class="hljs-type">bool</span> hit;<br>Vec3 pos;<br>Vec3 normal;<br><span class="hljs-type">float</span> depth;<br>&#125;;<br><span class="hljs-function">HitRes <span class="hljs-title">intersect</span><span class="hljs-params">(Ray r)</span> </span>&#123;<br><span class="hljs-keyword">return</span> &#123;<span class="hljs-literal">true</span>, r.origin, r.direction, <span class="hljs-number">233.0f</span>&#125;<br>&#125;<br><span class="hljs-comment">// or </span><br><span class="hljs-keyword">struct</span> HitRes&#123;<br><span class="hljs-type">bool</span> hit;<br>Vec3 pos;<br>Vec3 normal;<br><span class="hljs-type">float</span> depth;<br>&#125; <span class="hljs-built_in">intersect</span>(Ray r) &#123;<br><span class="hljs-keyword">return</span> &#123;<span class="hljs-literal">true</span>, r.origin, r.direction, <span class="hljs-number">233.0f</span>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-built_in">main</span>()&#123;<br>Ray r;<br><span class="hljs-keyword">auto</span> hit = <span class="hljs-built_in">intersect</span>(r);<br><span class="hljs-keyword">if</span>(hit.hit)&#123;<br>r.origin = hit.pos;<br>r.direction = hit.normal;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>和tuple相比，{}会有名字</li></ul><h3 id="三五法则："><a href="#三五法则：" class="headerlink" title="三五法则："></a>三五法则：</h3><p>适用于管理资源的类（如diy的vector类）</p><ul><li>如果一个类定义了解构函数，那么您必须同时定义或删除拷贝构造函数和拷贝赋值函数，否则出错。</li><li>如果一个类定义了拷贝构造函数，那么您必须同时定义或删除拷贝赋值函数，否则出错，删除可导致低效。</li><li>如果一个类定义了移动构造函数，那么您必须同时定义或删除移动赋值函数，否则出错，删除可导致低效。</li><li>如果一个类定义了拷贝构造函数或拷贝赋值函数，那么您必须最好同时定义移动构造函数或移动赋值函数，否则低效。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span>&#123;<br><span class="hljs-built_in">C</span>();<br><span class="hljs-built_in">C</span>(C <span class="hljs-type">const</span> &amp;c);<br><span class="hljs-built_in">C</span>(C &amp;&amp;c);<br>C &amp;<span class="hljs-keyword">operator</span>=(C <span class="hljs-type">const</span> &amp;c);<br>C &amp;<span class="hljs-keyword">operator</span>=(C &amp;&amp;c);<br>~<span class="hljs-built_in">C</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>由于自动生成的拷贝赋值和构造对于智能指针是浅拷贝 因此下面情况可能会double free 甚至别的情况中，如果vec2提前释放的话，vec1是悬垂指针dangling pointer更加危险</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>Vector vec1;<br><span class="hljs-function">Vector <span class="hljs-title">vec2</span><span class="hljs-params">(vec1)</span></span>;<br>Vector vec3 = vec1;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 自动释放vec1，2，3</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>为了统一拷贝时是深拷贝 移动的时候统一逻辑</p></li><li><p>为了统一拷贝时是深拷贝 移动的时候统一逻辑</p></li><li><p>移动会更高效</p></li></ol><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>不可以被拷贝，如果要作为参数传递给函数可选择：</p><ul><li><code>func(p.get());</code> 用于不改变p的生命周期，不会接管p的ownership<ul><li>但是需要注意不能在func内部去释放掉p指向的资源</li></ul></li><li><code>func(std::move(p));</code> 用于改变p的生命周期，take原本的ownership（此时外部的p已经指向nullptr）</li></ul><h3 id="shared-ptr-和-weak-ptr"><a href="#shared-ptr-和-weak-ptr" class="headerlink" title="shared_ptr 和 weak_ptr"></a>shared_ptr 和 weak_ptr</h3><ul><li><code>C*</code> 理解为 <code>unique_ptr</code> 的弱引用。</li><li><code>weak_ptr</code> 理解为 <code>shared_ptr</code> 的弱引用。但 <code>weak_ptr</code> 能提供失效检测，更安全。</li></ul><p>shared_ptr维护的use_count</p><blockquote><p>In a typical implementation, <code>shared_ptr</code> holds only two pointers:在典型的实现中， <code>shared_ptr</code>仅保存两个指针：</p><ul><li><p>the stored pointer (one returned by <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr/get">get()</a>);</p><p>存储的指针（由<a href="https://en.cppreference.com/w/cpp/memory/shared_ptr/get">get()</a>返回的指针）；</p></li><li><p>a pointer to <em>control block</em>.</p><p>指向<em>控制块的</em>指针。(control block包含：</p><ul><li><p>either a pointer to the managed object or the managed object itself;</p><p>指向托管对象的指针或托管对象本身；</p></li><li><p>the deleter (type-erased);</p><p>删除器（类型擦除）；</p></li><li><p>the allocator (type-erased);</p><p>分配器（类型擦除）；</p></li><li><p>the number of <code>shared_ptr</code>s that own the managed object;</p><p>拥有托管对象的<code>shared_ptr</code>的数量；</p></li><li><p>the number of <code>weak_ptr</code>s that refer to the managed object.</p><p>引用托管对象的<code>weak_ptr</code>的数量。</p><p>）</p></li></ul></li></ul></blockquote><p>Ref: <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr - cppreference.com — std::shared_ptr - cppreference.com</a></p><ul><li>创建自身时: +1</li><li>被其他对象持有或者拷贝给了另一个shared_ptr: +1</li></ul><p>只有当所有指向该对象的 <code>shared_ptr</code> 被销毁，引用计数降为 0 时，控制块才会销毁对象。</p><p><strong>如何让一个weak_ptr指向一个Node的指针</strong></p><ul><li>weak_ptr可以指向shared_ptr</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> node_weak = std::<span class="hljs-built_in">weak_ptr</span>&lt;Node&gt;();<br>node_weak = node1;<br>std::cout &lt;&lt; node_weak.<span class="hljs-built_in">lock</span>()-&gt;value &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><ul><li>weak_ptr不可以指向一个裸object指针</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br><span class="hljs-keyword">auto</span> node = std::<span class="hljs-built_in">make_shared</span>&lt;Node&gt;(val);<br><span class="hljs-comment">// node-&gt;prev = std::shared_ptr&lt;Node&gt;(this); //酱紫会报错</span><br><span class="hljs-comment">// node-&gt;next = this; //酱紫不过编译 No viable operator= matches arguments of type std::shared_ptr&lt;Node&gt; and Node *.</span><br>  node-&gt;next = next;<br>  <span class="hljs-keyword">this</span>-&gt;next = node;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>std::weak_ptr</code> is a smart pointer that holds a non-owning (“weak”) reference to an object that is managed by <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a>. It must be converted to <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a> in order to access the referenced object.</p></blockquote><p>Ref: <a href="https://en.cppreference.com/w/cpp/memory/weak_ptr">std::weak_ptr - cppreference.com — std::weak_ptr - cppreference.com</a></p><blockquote><p>在类内部如果需要获取当前对象的 <code>shared_ptr</code>，应该使类继承 <strong><code>std::enable_shared_from_this</code></strong></p></blockquote><p>Ref: <a href="https://stackoverflow.com/questions/712279/what-is-the-usefulness-of-enable-shared-from-this">c++ - <code>enable_shared_from_this</code> 有什么用处？ - 堆栈溢出 — c++ - What is the usefulness of <code>enable_shared_from_this</code>? - Stack Overflow</a></p><p><a href="https://learn.microsoft.com/en-us/cpp/standard-library/enable-shared-from-this-class?view=msvc-170">启用_shared_from_this 类 |微软学习 — enable_shared_from_this Class | Microsoft Learn</a></p><ul><li>正面例子：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;MyClass&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::shared_ptr&lt;MyClass&gt; <span class="hljs-title">getSharedPtr</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_from_this</span>(); <span class="hljs-comment">// 使用 enable_shared_from_this 的正确方式</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass instance&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 正确方式：使用 std::make_shared 创建 shared_ptr</span><br>    std::shared_ptr&lt;MyClass&gt; obj1 = std::<span class="hljs-built_in">make_shared</span>&lt;MyClass&gt;();<br><br>    <span class="hljs-comment">// 使用成员函数创建另一个共享的 shared_ptr</span><br>    std::shared_ptr&lt;MyClass&gt; obj2 = obj1-&gt;<span class="hljs-built_in">getSharedPtr</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;obj1 address&quot;</span> &lt;&lt; obj1.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl; <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;obj2 address&quot;</span> &lt;&lt; obj2.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl; <span class="hljs-comment">//是一样的</span><br>    <span class="hljs-comment">// 输出引用计数</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;obj1 use_count: &quot;</span> &lt;&lt; obj1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出 2</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;obj2 use_count: &quot;</span> &lt;&lt; obj2.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出 2</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这种东东不会造成循环引用，<code>obj1</code>和<code>obj2</code>的关系并非互相持有，而是共同拥有控制块<ul><li>可以简单的理解为这是<code>shared_ptr</code>发生了拷贝行为</li></ul></li><li>反面例子：(x)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::shared_ptr&lt;MyClass&gt; <span class="hljs-title">getSharedPtr</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">shared_ptr</span>&lt;MyClass&gt;(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// 错误：直接用 this 创建新的 shared_ptr</span><br>&#125;<br><span class="hljs-comment">// 统一用shared_ptr的写法保证了debug视图control block显示的一致</span><br>std::shared_ptr&lt;MyClass&gt; obj1 = std::<span class="hljs-built_in">shared_ptr</span>&lt;MyClass&gt;(<span class="hljs-keyword">new</span> MyClass);<br>std::shared_ptr&lt;MyClass&gt; obj2 = obj1-&gt;<span class="hljs-built_in">getSharedPtr</span>();<br><br>std::cout &lt;&lt; <span class="hljs-string">&quot;obj1 address&quot;</span> &lt;&lt; obj1.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl; <br>std::cout &lt;&lt; <span class="hljs-string">&quot;obj2 address&quot;</span> &lt;&lt; obj2.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl; <span class="hljs-comment">//是一样的</span><br><span class="hljs-comment">// 输出引用计数</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;obj1 use_count: &quot;</span> &lt;&lt; obj1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出 1</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;obj2 use_count: &quot;</span> &lt;&lt; obj2.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出 1</span><br></code></pre></td></tr></table></figure><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>不继承<code>enabled_shared_from_this</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::shared_ptr&lt;MyClass&gt; <span class="hljs-title">getSharedPtr</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">shared_ptr</span>&lt;MyClass&gt;(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// 错误：直接用 this 创建新的 shared_ptr</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass instance&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::shared_ptr&lt;MyClass&gt; obj1 = std::<span class="hljs-built_in">shared_ptr</span>&lt;MyClass&gt;(<span class="hljs-keyword">new</span> MyClass);<br>    <span class="hljs-comment">// 使用成员函数创建另一个共享的 shared_ptr</span><br>    std::shared_ptr&lt;MyClass&gt; obj2 = obj1-&gt;<span class="hljs-built_in">getSharedPtr</span>();<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202411021513951.png" alt="image.png"></p><p><code>_Rep</code>是控制块</p><p>Ref: <a href="https://devblogs.microsoft.com/oldnewthing/20230814-00/?p=108597#:~:text=0x00c%20_Weaks%20%20%20%20%20%20%20%20%20%20%20%3A%201-,Here%E2%80%99s,-how%20the%20names">Inside STL: Smart pointers - The Old New Thing</a></p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202411021513914.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202411021513233.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202411021513442.png" alt="image.png"></p><p>注意到，<code>obj1</code>和<code>obj2</code>的控制块并不相同，彼此并不知道对方的存在。资源<code>_Ptr</code>只有一份，当各自的引用计数&#x3D;0时都会去删除资源，导致double free，铸成大错:(</p><p>多个shared_ptr各自初始化并指向同一个资源违反了rules：</p><blockquote><p>The ownership of an object can <strong>only be</strong> shared with another<code>shared_ptr</code>by copy constructing or copy assigning its value to another<code>shared_ptr</code>. Constructing a new<code>shared_ptr</code>using the raw underlying pointer owned by another<code>shared_ptr</code>leads to undefined behavior.</p><p>对象的所有权只能通过复制构造或复制将其值分配给另一个<code>shared_ptr</code> <code>shared_ptr</code> 。使用另一个<code>shared_ptr</code>拥有的原始底层指针构造一个新的<code>shared_ptr</code>会导致未定义的行为。</p></blockquote><p>Ref: <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr - cppreference.com — std::shared_ptr - cppreference.com</a></p><p><em><strong>Sidenote——double free为什么坏？</strong></em></p><ul><li>大多数内存分配器（例如 GNU C 库的 <code>malloc</code> 实现）中，每个内存块（chunk）的元数据通常存储在块的前面几个字节中，用于记录块的大小、分配状态等信息。一般来说，<code>malloc</code> 会在用户请求的内存块前面保留额外的字节来存储这些元数据，例如块大小和其他标记信息。</li><li>当double free的时候，被free的内存chunk的size假设是存储在ptr的前面几个字节的，例如<code>auto size = *(ptr - 8);</code> 然后第一次free之后这个<code>ptr</code>已经无效了，第二次free时堆ptr-8 的解引用 可能会造成非法内存访问</li></ul><p><strong>不同shared_ptr创建方式→不同的内存布局(layout)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::shared_ptr&lt;MyClass&gt; <span class="hljs-title">getSharedPtr</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">shared_ptr</span>&lt;MyClass&gt;(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// 错误：直接用 this 创建新的 shared_ptr</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass instance&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::shared_ptr&lt;MyClass&gt; obj1 = std::<span class="hljs-built_in">make_shared</span>&lt;MyClass&gt;();<br>    <span class="hljs-comment">// 使用成员函数创建另一个共享的 shared_ptr</span><br>    std::shared_ptr&lt;MyClass&gt; obj2 = obj1-&gt;<span class="hljs-built_in">getSharedPtr</span>();<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202411021513752.png" alt="image.png"></p><ul><li>shared_ptr：分别给control block 和 raw pointer分配</li><li>make_shared：一次性分配堆空间（似乎性能和安全上更好）</li><li>销毁时如何释放？</li></ul><table><thead><tr><th>情况</th><th><code>Dispose()</code></th><th><code>Delete()</code></th></tr></thead><tbody><tr><td>手动创建对象后传给 <code>shared_ptr</code></td><td>销毁 <code>S</code> 对象并释放对象内存</td><td>销毁控制块并释放控制块内存</td></tr><tr><td>使用 <code>make_shared</code> 创建</td><td>运行 <code>S</code> 对象的析构函数（释放对象内部资源）但不释放内存</td><td>销毁控制块并释放整个内存块（包含对象和控制块）</td></tr></tbody></table><p>Ref: <a href="https://devblogs.microsoft.com/oldnewthing/20230815-00/?p=108602">STL 内部：shared_ptr 构造函数与 make_shared - 老新事物 — Inside STL: The shared_ptr constructor vs make_shared - The Old New Thing</a></p><p><a href="https://stackoverflow.com/questions/20895648/difference-in-make-shared-and-normal-shared-ptr-in-c">c++11 - C++中make_shared和普通shared_ptr的区别 - VoidCC — c++11 - Difference in make_shared and normal shared_ptr in C++ - Stack Overflow</a></p><p>使用shared_from_this (√)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;MyClass&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::shared_ptr&lt;MyClass&gt; <span class="hljs-title">getSharedPtr</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_from_this</span>(); <span class="hljs-comment">// 使用 enable_shared_from_this 的正确方式</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass instance&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 正确方式：使用 std::make_shared 创建 shared_ptr</span><br>    std::shared_ptr&lt;MyClass&gt; obj1 = std::<span class="hljs-built_in">make_shared</span>&lt;MyClass&gt;();<br>    <span class="hljs-comment">// 使用成员函数创建另一个共享的 shared_ptr</span><br>    std::shared_ptr&lt;MyClass&gt; obj2 = obj1-&gt;<span class="hljs-built_in">getSharedPtr</span>();<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202411021514353.png" alt="image.png"></p><p><strong>shared_ptr weak_ptr伪代码实现</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">control_block</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Dispose</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    std::atomic&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>&gt; shareds;<br>    std::atomic&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>&gt; weaks;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">shared_ptr</span><br>&#123;<br>    T* object;<br>    control_block* control;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">weak_ptr</span><br>&#123;<br>    T* object;<br>    control_block* control;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>细节：强引用计数和弱引用计数（弱引用计数中需要保存shared_ptr的数量，实际中shared_ptr一旦存在则weaks + 1，无需weaks &#x3D; shareds + weak_ref）</li></ul><p>Ref: <a href="https://devblogs.microsoft.com/oldnewthing/20230814-00/?p=108597">STL 内部：智能指针 - 老新事物 — Inside STL: Smart pointers - The Old New Thing</a></p><p><a href="https://stackoverflow.com/questions/49585818/why-does-shared-ptr-needs-to-hold-reference-counting-for-weak-ptr">c++ - 为什么shared_ptr需要保存weak_ptr的引用计数？ - 堆栈溢出 — c++ - Why does shared_ptr needs to hold reference counting for weak_ptr? - Stack Overflow</a></p><h2 id="Bonus-Viewing"><a href="#Bonus-Viewing" class="headerlink" title="Bonus Viewing:"></a>Bonus Viewing:</h2><p><a href="https://www.reddit.com/r/cpp/comments/5do55l/heres_everything_i_know_about_shared_ptr/">这是我所知道的有关 shared_ptr 的所有内容：r&#x2F;cpp — Here’s everything I know about shared_ptr : r&#x2F;cpp</a></p><p><a href="https://www.reddit.com/r/cpp/comments/pbiyre/comment/hac69lb/">仅使用引用计数来断言引用的寿命不会比对象长？ ：r&#x2F;cpp — Using reference counting only to assert that references do not outlive an object? : r&#x2F;cpp</a></p><p><a href="https://stackoverflow.com/questions/712279/what-is-the-usefulness-of-enable-shared-from-this">c++ - What is the usefulness of <code>enable_shared_from_this</code>? - Stack Overflow</a></p><p><a href="https://stackoverflow.com/questions/43297517/stdshared-ptr-internals-weak-count-more-than-expected">c++ - std::shared_ptr 内部结构，弱计数超出预期 - 代码日志 — c++ - std::shared_ptr internals, weak count more than expected - Stack Overflow</a></p><p><a href="https://stackoverflow.com/questions/5913396/why-do-stdshared-ptrvoid-work?rq=2">c++ - Why do std::shared_ptr<void> work - Stack Overflow</a>（神奇trick 类型擦除）</p><p><a href="https://www.reddit.com/r/cpp/comments/3eia29/comment/ctfeh1p/">std::shared_ptr 的秘密构造函数：r&#x2F;cpp — std::shared_ptr’s secret constructor : r&#x2F;cpp</a>（此发言没有指明任何锁操作，试图说明weak count如果不包含shared_ptr的计数（即只要存在sharedptr，weaks+1）就会出错，但是结合Chen的blog，顶多增加了原子检查的操作性能损耗。</p><p><a href="https://learn.microsoft.com/en-us/archive/msdn-magazine/2004/december/c-q-a-deleting-managed-objects-wrapping-a-library-and-more">C++ 问答：删除托管对象、包装库等 |微软学习 — C++ Q&amp;A: Deleting Managed Objects, Wrapping a Library, and More | Microsoft Learn</a> （太好了是微软开发杂谈）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络幼儿科普读物01————internet/https</title>
    <link href="/2024/09/08/internet-https/"/>
    <url>/2024/09/08/internet-https/</url>
    
    <content type="html"><![CDATA[<h1 id="网络幼儿科普读物01"><a href="#网络幼儿科普读物01" class="headerlink" title="网络幼儿科普读物01"></a>网络幼儿科普读物01</h1><blockquote><p>审稿人: MrBeanC 阿里多多^^</p></blockquote><h2 id="curl-vs-ping"><a href="#curl-vs-ping" class="headerlink" title="curl vs ping"></a>curl vs ping</h2><ul><li><strong>curl</strong>：用于发送 HTTP&#x2F;HTTPS 等应用层协议的请求，并获取服务器响应，主要用于网络应用层的数据交互。</li><li><strong>ping</strong>：用于网络层的连接测试，通过 ICMP 协议确认目标设备是否可达，常用于诊断网络连通性问题。</li></ul><p><a href="https://superuser.com/questions/920491/why-does-curl-command-work-normally-while-ping-not">神奇问题：curl通ping不通（计算机网络真是太奇妙le）</a></p><h2 id="为什么需要域名访问？不直接用IP呢"><a href="#为什么需要域名访问？不直接用IP呢" class="headerlink" title="为什么需要域名访问？不直接用IP呢"></a>为什么需要域名访问？不直接用IP呢</h2><ul><li>输入域名浏览器会自动补充为https协议访问，域名会被解析为ip地址</li><li>域名是为了human-readable :) 服务器真实地址可能变化，例如服务器到期，or内网采用DDNS，但是用户只需要记住固定的域名</li></ul><blockquote><p>安全证书也可以给公共IP，保证IP的访问安全性~</p></blockquote><h3 id="私有-IP-地址范围"><a href="#私有-IP-地址范围" class="headerlink" title="私有 IP 地址范围"></a>私有 IP 地址范围</h3><p>根据 RFC 1918，以下三个 IP 地址范围被保留为私有地址：</p><p>私有地址 &#x3D;&#x3D; 不能在互联网中被路由</p><ol><li><strong>10.0.0.0 - 10.255.255.255</strong> （<code>10.x.x.x</code>）:<ul><li>支持的地址数量：16,777,216 个</li><li>通常用于大型企业网络</li></ul></li><li><strong>172.16.0.0 - 172.31.255.255</strong> （<code>172.16.x.x</code> 至 <code>172.31.x.x</code>）:<ul><li>支持的地址数量：1,048,576 个</li><li>通常用于中型企业网络</li></ul></li><li><strong>192.168.0.0 - 192.168.255.255</strong> （<code>192.168.x.x</code>）:<ul><li>支持的地址数量：65,536 个</li><li>通常用于家庭网络和小型企业网络</li></ul></li></ol><h3 id="HTTP请求是从哪个端口发出的"><a href="#HTTP请求是从哪个端口发出的" class="headerlink" title="HTTP请求是从哪个端口发出的"></a>HTTP请求是从哪个端口发出的</h3><ul><li><strong>客户端</strong>发起 HTTP 请求时，会从一个随机高位端口（49152-65535）发出。</li><li><strong>服务器</strong>接收 HTTP 请求的默认端口是 80（除非使用了其他自定义端口）。HTTPS是443端口。</li></ul><p><a href="https://www.golinuxcloud.com/set-up-proxy-http-proxy-environment-variable/">在 Linux 中使用 http_proxy 和 https_proxy 环境变量设置代理？</a></p><p>环境变量http_proxy https_proxy是会把对应的请求都发到值的ip端口上，由监听该端口的服务再进行转发</p><p><a href="https://about.gitlab.com/blog/2021/01/27/we-need-to-talk-no-proxy/">NO_PROXY</a></p><p><a href="https://superuser.com/questions/944958/are-http-proxy-https-proxy-and-no-proxy-environment-variables-standard">HTTP_PROXY、HTTPS_PROXY 和 NO_PROXY 环境变量是否标准</a> </p><h3 id="ip-端口-⇒-socket套接字"><a href="#ip-端口-⇒-socket套接字" class="headerlink" title="ip+端口 ⇒ socket套接字"></a>ip+端口 ⇒ socket套接字</h3><p>有了不同的端口分配给不同的进程，电脑可以进行多个进程运行和切换。端口会不会被占用玩完呢？几乎不可能噢，因为pc会维护端口，进程结束释放端口，并且一个端口可以处理一个程序的多个请求。</p>]]></content>
    
    
    
    <tags>
      
      <tag>internet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>丑丑头像——个人博客评论系统valine部署小记</title>
    <link href="/2024/07/21/valine-comments/"/>
    <url>/2024/07/21/valine-comments/</url>
    
    <content type="html"><![CDATA[<h2 id="需求——个人博客网站评论区"><a href="#需求——个人博客网站评论区" class="headerlink" title="需求——个人博客网站评论区"></a>需求——个人博客网站评论区</h2><p>想要让自己的博客网站支持留言，装扮hexo空间:)</p><h2 id="对比技术——Gitalk-or-Valine-LeanCloud"><a href="#对比技术——Gitalk-or-Valine-LeanCloud" class="headerlink" title="对比技术——Gitalk or Valine+LeanCloud"></a>对比技术——<strong>Gitalk</strong> or Valine+LeanCloud</h2><blockquote><p>Gitalk 是一个基于 Github issues 的评论系统。</p></blockquote><p><strong>Gitalk steps:</strong></p><ul><li>注册一个新的 <strong>GitHub Application</strong> 来授权</li><li>修改config配置启用Gitalk</li></ul><p>通过Gitalk的readme，自动跳转到了OAuth application的注册界面，OAuth application不等同于Github application。虽然两者都是为了能够暴露GitHub的仓库操作API，OAuth application并不能限制使用GitHub的权限限度。OAuth application可以类比qq授权给另一个网站登录使用qq的个人信息，OAuth application的回调（callback）url就是个人博客网站url，即接收GitHub发送的token的一方。由于hexo的明文传输，这个token理论上是会被暴露在前端的某个js文件中</p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202407212341648.png" alt="screenshot"></p><p><strong>暴露是否是安全呢？答案：so far so good</strong></p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202407212341908.png" alt="Untitled"></p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202407212341874.png" alt="Untitled"></p><ul><li>关键在于callback url不可改，指向的我们自己的博客是受信任的，安全的。但是当我们点别人的博客提示需要授权的时候，就要小心了</li></ul><p><a href="https://github.com/gitalk/gitalk/issues/444">https://github.com/gitalk/gitalk/issues/444</a></p><p><strong>token权限争议</strong></p><ul><li>引用的博主认为：OAuth application使用的token应该是仅有只读权限 但是这位博主自己的评论区进行GitHub授权时，依然提示需要授权read and write。引用：<a href="https://carl-zk.github.io/blog/2020/03/03/gitalk-%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/">Gitalk 运作原理 | 一叶轻舟渡万江 (carl-zk.github.io)</a></li></ul><p>OAuth App 5年前创建，2019年，此时PR还没提，还是read write</p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202407212341044.png" alt="Untitled"></p><p>2020.2 PR合并，token的权限从读写权改为read only </p><p><a href="https://github.com/gitalk/gitalk/pull/344">https://github.com/gitalk/gitalk/pull/344</a></p><p>2020.3博主调查之后 写下read only的结论</p><p><strong>Valine+LeanCloud steps:</strong> </p><ul><li>注册LeanCloud<a href="https://console.leancloud.cn/apps">LeanCloud</a></li><li>参考stun主题的valine部署方式<a href="https://theme-stun.github.io/docs/zh-CN/advanced/third-part.html#valine">第三方支持 | hexo-theme-stun</a></li></ul><p>对比Gitalk和Valine，Gitalk有一定的风险w 而Valine虽然不一定稳定，但是删库跑路的风险是0.0000001。所以选择Valine＜（＾－＾）＞</p><h2 id="头像是丑丑人儿怎么办呢"><a href="#头像是丑丑人儿怎么办呢" class="headerlink" title="头像是丑丑人儿怎么办呢"></a>头像是丑丑人儿怎么办呢</h2><p>当完成了评论区的基本部署，需要选择默认头像样式。这里可以选择神秘人样式，或者wavatar小怪物。但是没有人想到当VPN+无邮箱测试留言评论，头像是丑丑人儿！（在配置中命名配置的是wavatar！）</p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202407212340677.png" alt="Untitled"></p><p>小坑：需要注意notify：verify：类似这种的配置文件有列出的项目，不能直接注释掉（这是必须项）应该写false来禁用</p><p>经过和cls的一个下午测试，结论如下：</p><ol><li>丑丑人是not found&#x2F;网络情况不佳等异常的fallback（302）</li><li>不开梯子反而可以看到正常人（mp）也可以有wavatar</li><li>wavatar需要填写qq邮箱 每个邮箱随机对应一个wavatar</li><li>不填写邮箱只能显示mp（or丑丑人）</li><li><code>enableQQ</code>在配置中是无效的</li><li>在开VPN情况下，填写邮箱，可以正确加载头像，这并不是网络原因，只是米有了邮箱用于标识造成的not found (bug maybe)</li></ol><p>一言蔽之：只有在<code>VPN + 无邮箱</code>的情况下，才会显示丑人 (302)</p><p>一旦生成头像，会永久和邮箱绑定</p><p>疑惑：为什么有VPN反而not found (302)</p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202407212341687.png" alt="Untitled"></p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202407212341955.png" alt="Untitled"></p><p>aa 没有mail都是丑丑人儿！</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref:"></a>Ref:</h2><p><a href="https://valine.js.org/avatar.html">头像配置 | Valine 一款快速、简洁且高效的无后端评论系统。</a>(我们会发现这个里面评论区头像图片获取的链接和我们使用的头像获取url不太一样呢）</p><p><a href="https://theme-stun.github.io/docs/zh-CN/advanced/third-part.html#valine">第三方支持 | hexo-theme-stun</a></p><p><a href="https://github.com/gitalk/gitalk/issues?page=1&q=secret">https://github.com/gitalk/gitalk/issues?page=1&q=secret</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>valine blog-comments</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javaweb后端-springboot基础知识小回顾</title>
    <link href="/2024/03/30/post/"/>
    <url>/2024/03/30/post/</url>
    
    <content type="html"><![CDATA[<h2 id="Springboot-vs-Sping"><a href="#Springboot-vs-Sping" class="headerlink" title="Springboot vs Sping"></a>Springboot vs Sping</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端小记-vue知识库项目</title>
    <link href="/2023/10/19/post/"/>
    <url>/2023/10/19/post/</url>
    
    <content type="html"><![CDATA[<h2 id="template用法"><a href="#template用法" class="headerlink" title="template用法"></a>template用法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;body&gt;<br>    &lt;div id=&quot;app&quot;&gt;<br>        &lt;template id=&quot;tem&quot;&gt;<br>            &lt;h1&gt;我是模板&lt;/h1&gt;<br>        &lt;/template&gt;<br>    &lt;/div&gt;<br>&lt;/body&gt;<br>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;<br>&lt;script&gt;<br>    var app = new Vue(&#123;<br>        el:&quot;#app&quot;,<br>        template:&quot;#tem&quot;<br>    &#125;)<br>&lt;/script&gt; <br>-----------------------------------or------------------------------------------------<br>&lt;template id=&quot;tem&quot;&gt;<br>&lt;div&gt;<br>        <br>    &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h2 id="vue中组件"><a href="#vue中组件" class="headerlink" title="vue中组件"></a>vue中组件</h2><p><a href="https://blog.csdn.net/stalin_/article/details/107563450#:~:text=%E7%BB%84%E4%BB%B6%E5%8C%96%E6%98%AFVUE%E7%9A%84%E4%B8%80%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%8C%E5%AE%83%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%80%E7%A7%8D%E6%8A%BD%E8%B1%A1%EF%BC%8C%E8%AE%A9%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%8B%AC%E7%AB%8B%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%B0%8F%E7%BB%84%E4%BB%B6%E6%9D%A5%E6%9E%84%E5%BB%BA%E5%A4%A7%E5%9E%8B%E5%BA%94%E7%94%A8%EF%BC%8C%E4%BB%BB%E6%84%8F%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%94%E7%94%A8%E7%95%8C%E9%9D%A2%E9%83%BD%E5%8F%AF%E4%BB%A5%E6%8A%BD%E8%B1%A1%E4%B8%BA%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6%E6%A0%91%E3%80%82,%E7%AE%80%E5%8D%95%E6%9D%A5%E8%AF%B4%EF%BC%8C%E6%9C%89%E4%BA%86%E7%BB%84%E4%BB%B6%E5%8C%96%E8%AE%BE%E8%AE%A1%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E9%83%A8%E5%88%86%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%A4%8D%E7%94%A8%EF%BC%8C%E6%AF%94%E5%A6%82%E6%88%91%E4%BB%AC%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AAheader.vue%EF%BC%8C%E7%84%B6%E5%90%8E%E5%A4%9A%E4%B8%AA%E9%A1%B5%E9%9D%A2%E4%B8%AD%E9%83%BD%E5%8F%AF%E4%BB%A5%E5%BC%95%E7%94%A8%E8%BF%99%E4%B8%AAheader.vue%EF%BC%8C%E8%BF%99%E6%A0%B7%E4%BD%BF%E4%BB%A3%E7%A0%81%E9%87%8F%E6%9B%B4%E5%B0%91%EF%BC%8C%E6%9B%B4%E7%AE%80%E6%B4%81%E3%80%82">vue组件复用</a></p><h3 id="组件的通信"><a href="#组件的通信" class="headerlink" title="组件的通信"></a>组件的通信</h3><ul><li><p>子组件-&gt;父组件</p><ul><li><a href="https://blog.csdn.net/czjl6886/article/details/121588740">父子组件通信</a></li></ul></li><li></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SGM</title>
    <link href="/2023/05/31/SGM/"/>
    <url>/2023/05/31/SGM/</url>
    
    <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><blockquote><p>经典的双目深度预测算法被归纳为四个步骤，即：初始匹配代价计算、代价聚合、视差计算、视差精化步骤</p></blockquote><h3 id="立体校正"><a href="#立体校正" class="headerlink" title="立体校正"></a>立体校正</h3><ul><li><strong>核线约束</strong></li></ul><h3 id="左图右图并不是对等"><a href="#左图右图并不是对等" class="headerlink" title="左图右图并不是对等"></a>左图右图并不是对等</h3><ul><li>base image（左图）match image（右图）</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="代价计算"><a href="#代价计算" class="headerlink" title="代价计算"></a>代价计算</h3><p><strong>Census transform</strong></p><ul><li>输入：两幅图像的灰度值二维数组</li><li>边缘像素无法转化为比特串：两个方法（padding &#x2F; 0填充）</li></ul><h3 id="Hamming-distance"><a href="#Hamming-distance" class="headerlink" title="Hamming distance"></a>Hamming distance</h3><p>- </p><h3 id="代价聚合"><a href="#代价聚合" class="headerlink" title="代价聚合"></a>代价聚合</h3><p><strong>必要性</strong></p><ul><li>初步的代价计算是根据局部窗口进行计算 容易受到噪声的影响</li><li>只会考虑局部信息，通过两个像素邻域内一定大小的窗口内的像素信息来计算代价值</li><li>代价聚合则是建立邻接像素之间的联系，以一定的准则，如相邻像素应该具有连续的视差值，来对代价矩阵进行优化，这种优化往往是全局的，每个像素在某个视差下的新代价值都会根据其相邻像素在同一视差值或者附近视差值下的代价值来重新计算，得到新的DSI，用矩阵S来表示。</li><li>类似于一种视差传播步骤，信噪比高的区域匹配效果好，初始代价能够很好的反映相关性，可以更准确的得到最优视差值，通过代价聚合传播至信噪比低、匹配效果不好的区域，最终使所有影像的代价值都能够准确反映真实相关性。</li><li>单方向一维聚合类似动态规划完成了二维上的最优问题</li></ul><h3 id="视差选择"><a href="#视差选择" class="headerlink" title="视差选择"></a>视差选择</h3><ul><li>之前的<code>cost_aggr</code>是<code>WHD</code>三维的数组，此时我们需要确立出视差范围（第三维）中像素<code>(i,j)</code>对应的最小代价的点<code>(i,j+d)</code></li><li>Trick：index的视差<code>d</code>和value的代价<code>cost_aggr[h*w+w*d+d]</code>到底什么关系？<ul><li>并不是说index视差是<code>j+d</code> 对应的聚合代价<code>cost_aggr[h*w+w*d+d]</code>必须是这么多或者靠近这个值<ul><li>这个聚合代价值是我们通过census transform等一系列算法，结合了周围像素灰度值和全局信息得到</li><li>而index视差<code>d</code>是我们位置上去锁定右图该像素的坐标 这个视差并非实际真实两点之间的视差代价</li><li>单独在某个图片谈视差<code>d</code>等价我们的<strong>代价</strong>视差是非法的；index的<code>d</code> 是在核线约束下的产物，仅仅在两图中同一条epipolar line上寻像素位置是可以讨论<code>d</code> ，这可不是真实的视差呀</li></ul></li></ul></li></ul><h3 id="视差优化"><a href="#视差优化" class="headerlink" title="视差优化"></a>视差优化</h3><h4 id="左右一致性检查-LRC"><a href="#左右一致性检查-LRC" class="headerlink" title="左右一致性检查 LRC"></a>左右一致性检查 LRC</h4><ul><li>Left-Right Check：检查左右图的同名像素点是否具有相同的视差或者相差并不是很大的误差</li></ul><p>右图的代价数组如何生成呢？</p><ul><li>法一：直接通过右图原图灰度值模仿左图走一遍流程。我认为这就是所说的“交换”左右图。但是由于左右图直接互换，会导致for循环开始的位置改变（两个图的重叠位置变了）</li><li>法二：通过左图的代价去寻找右图的代价。利用了左图<code>(i,j)</code>对应右图的<code>(i,j-d)</code>的极线约束。注意：次步骤利用的左图的三维数组<code>cost_aggr</code> 而并非筛选过最小值后的<code>left_disparity</code>数组，需要在右图也首先生成三维的聚合代价，再在视差范围的维度进行最小值筛选，压缩成二维的像素-代价数组</li></ul><p>左右图的对应像素点匹配时，我们在从左图寻右图对应点，终于用到了左图的<code>left_disparity</code>的代价值作为视差<code>d</code>去找右图的对应坐标<code>j-d</code></p><ul><li>如果左右图的代价作差小于阈值 -&gt; 合法的视差</li><li>否则则会把非法视差继续分类为<strong>遮挡</strong>和<strong>误匹配</strong></li></ul><h4 id="遮挡和误匹配"><a href="#遮挡和误匹配" class="headerlink" title="遮挡和误匹配"></a>遮挡和误匹配</h4><p><strong>遮挡</strong>：定义上是左图能看到，但是右图不能看到的像素。所以会匹配到右图的<strong>前景</strong>像素。epipolar line和匹配函数没有相交点</p><ul><li>判断遮挡需要从右图像反找左图像</li><li>书接上文，得到左右图的<strong>二维</strong>像素-代价数组，此时已经通过左图的数组value值作为视差<code>d</code>找到了对应的右图同名像素点<code>j-d</code> </li><li>此时我们把右图的数组<code>j-d</code>对应的value作为<code>d&#39;</code> 反过去找左图的对应点应该为<code>j+d&#39;</code> </li><li>根据前提：右图是<strong>前景</strong>像素，则匹配回左图也应该是在前景，满足了我们是左图能看见。在左图中，该像素应该是可见的，前面无物体遮住；在右图中，该像素是不可见的，被前景物体遮挡，意思是和前景物体是重合的位置。因此从右图返回左图寻找这个像素点，会落到前景上而非背景上，即右推左的深度 &lt; 左本身深度 即右推左的视差 &gt; 左本身的视差</li></ul><p><strong>误匹配</strong>：epipolar line和匹配函数有交点，但是左图和右图并非同一条epipolar line</p><h4 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h4><p>遮挡和误匹配均采用八个方向限定长度发散寻找有效误差的方式，在这个有效视察备选数组中：</p><ul><li>遮挡选择第二小的视差作为填充：前景和背景需要区分，这里选择把误匹配作为背景填充，也就是选择深度大-&gt;视差小的点（呼应了我们的假设：左图可见为背景像素）[背景不等于不可见ya]</li><li>误匹配选择中值的视差作为填充：误匹配点需要和周围像素较为平滑</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://aitechtogether.com/article/7933.html">refer</a></p><p><a href="https://candyguo.github.io/blog-post-2/">refer</a></p><p><a href="https://www.guyuehome.com/35841">refer</a></p><p><a href="https://johnwlambert.github.io/stereo/">极线约束等前提的数学推导</a></p><p><a href="https://www.zhihu.com/question/317277165">初步了解立体匹配</a></p><p><a href="https://bbs.huaweicloud.com/blogs/345781">代价聚合理解</a></p><p><a href="https://pvphan.com/gatech-cs6476-stereo">论文理解</a></p><p><a href="https://vincentqin.tech/posts/stereo-vision-overview/">立体视觉综述</a></p><p><a href="https://blog.csdn.net/qq_35200351/article/details/122388213">论文汇总</a></p><p><a href="https://ethanli.blog.csdn.net/article/details/105065660">C++SGM参考</a></p><p><a href="https://aijishu.com/a/1060000000139727">相机坐标系等前置数学知识</a></p>]]></content>
    
    
    <categories>
      
      <category>CV</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>VS重新安装</title>
    <link href="/2023/05/31/post-1/"/>
    <url>/2023/05/31/post-1/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="彻底卸载的软件："><a href="#彻底卸载的软件：" class="headerlink" title="彻底卸载的软件："></a>彻底卸载的软件：</h2><ul><li><a href="https://learn.microsoft.com/zh-cn/visualstudio/install/uninstall-visual-studio?view=vs-2022">reference</a></li></ul></li><li>如果遇到bug：<strong>PackageId:Win11SDK_10.0.22000</strong><ul><li>修改注册表即可（多半是因为把位置定义为了不存在的磁盘）</li><li><a href="https://developercommunity.visualstudio.com/t/packageidwin11sdk-10022000packageactioninstallretu-44/1690522">reference</a></li></ul></li><li>testtest</li></ul>]]></content>
    
    
    <categories>
      
      <category>environment</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>c++两个类公用一个变量</title>
    <link href="/2023/05/28/post/"/>
    <url>/2023/05/28/post/</url>
    
    <content type="html"><![CDATA[<h2 id="intro"><a href="#intro" class="headerlink" title="intro"></a>intro</h2><blockquote><p>如果有两个类(窗口),需要共同使用一个变量path来记录上一次打开的目录</p><p>要求在空间中只存一份变量</p></blockquote><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><h3 id="static-变量"><a href="#static-变量" class="headerlink" title="static 变量"></a>static 变量</h3><ul><li><p>定义一个utils类 存放两个类的公用变量为类的成员 并且定义为<code>static</code>类型</p></li><li><p>When we declare a member of a class as static it means no matter how many objects of the class are created, there is only one copy of the static member.</p></li><li><pre><code class="c++">class Box &#123;   public:      static int objectCount;&#125;;// Initialize static member of class Boxint Box::objectCount = 0;</code></pre></li><li><p>声明在类内 初始化在类外</p></li><li><p><img src="/assets/image-20230528230648709.png" alt="image-20230528230648709"></p></li></ul><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><blockquote><p>实际上这个静态成员只有在main函数启动的时候才能被初始化(也就是<code>qApplication-&gt;dirpath</code>需要先启动app才可以访问这个当前项目目录)</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>post</title>
    <link href="/2023/03/01/post/"/>
    <url>/2023/03/01/post/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/02/26/sys-3/"/>
    <url>/2023/02/26/sys-3/</url>
    
    <content type="html"><![CDATA[<ul><li>host -&gt; hub -&gt; router</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sys-2</title>
    <link href="/2023/02/24/sys-2/"/>
    <url>/2023/02/24/sys-2/</url>
    
    <content type="html"><![CDATA[<h1 id="chap5"><a href="#chap5" class="headerlink" title="chap5"></a>chap5</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">twiddlel</span><span class="hljs-params">(<span class="hljs-type">long</span> *xp, <span class="hljs-type">long</span> *yp)</span> <br>&#123; <br>*xp += *yp; <br>*xp += *yp; <br>&#125; <br><br><span class="hljs-type">void</span> <span class="hljs-title function_">twiddle2</span><span class="hljs-params">(<span class="hljs-type">long</span> *xp, <span class="hljs-type">long</span> *yp)</span> <br>&#123; <br>*xp += <span class="hljs-number">2</span>* *yp;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>内存读写的效率分析：第二个函数读写次数更少</li><li>如果xp &#x3D;&#x3D; yp 则第一个会变成4 xp 第二个是3 xp、</li></ul><h2 id="内存混叠-memory-aliasing"><a href="#内存混叠-memory-aliasing" class="headerlink" title="内存混叠 memory aliasing"></a>内存混叠 memory aliasing</h2><ul><li>two pointers may designate the same memory location is known as <em>memory aliasing</em></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">x = <span class="hljs-number">1000</span>; y = <span class="hljs-number">3000</span>; <br>*q = y; <span class="hljs-comment">/* 3000 */</span> <br>*p = x; <span class="hljs-comment">/* 1000 */</span> <br>t1 = *q; <span class="hljs-comment">/* 1000 or 3000 */</span><br></code></pre></td></tr></table></figure><ul><li>需要假设代码中的pointer可能相等的情况</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sys-1</title>
    <link href="/2023/02/23/sys-1/"/>
    <url>/2023/02/23/sys-1/</url>
    
    <content type="html"><![CDATA[<h1 id="chap3"><a href="#chap3" class="headerlink" title="chap3"></a>chap3</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li><p>申请数组时注意数组的元素type 每一个元素所占内存大小由type决定</p></li><li><img src="assets/image-20230223215804804.png" alt="image-20230223215804804" style="zoom:50%;" /></li><li><p><img src="/assets/image-20230223220019851.png" alt="image-20230223220019851"></p></li><li><p><img src="/assets/image-20230223220045434.png" alt="image-20230223220045434"></p></li><li><p>a pointer of any kind is 8 bytes long</p></li></ul><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul><li>一元运算符<code>&amp;</code>和<code>*</code>允许生成和解引用指针。</li><li>That is, for an expression <em><code>Expr</code></em> denoting some object, <code>&amp;Expr</code> is a pointer giving the address of the object. For an expression <em><code>AExpr</code></em> denoting an address, <em><code>*AExpr</code></em> gives the value at that address. </li><li>The array reference <code>A[i]</code> is identical to the expression <code>*(A+i)</code> .因为A表示的数组最开头的地址 A+i就是第i个的地址 因此对地址进行解引用就是拿到这个地址上的object</li><li><img src="assets/image-20230223222643822.png" alt="image-20230223222643822" style="zoom:80%;" /></li></ul><h3 id="nested-array"><a href="#nested-array" class="headerlink" title="nested array"></a>nested array</h3><ul><li><p>Suppose <em>array <code>A</code></em> (5*3 int array) , <code>i</code> , and <code>j</code> are in registers <code>%rdi</code>, <code>%rsi</code> , and <code>%rdx</code> , respectively. Then array element <code>A[i][j]</code> can be copied to register <code>%eax</code> by the following code: </p></li><li><p>一行3个int 一共有5行</p><ul><li><pre><code class="assembly">A in %rdi, i in %rsi, and j in %rdx leaq (%rsi,%rsi,3), %rax Compute 3i leaq (%rdi,%rax,4), %rax Compute x + 12i movl (%rax,%rdx,4), %eax Read from M[x + 12i + 4]<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><br>- 例子<br><br>  - ```<br>    long <span class="hljs-selector-tag">P</span><span class="hljs-selector-attr">[M]</span><span class="hljs-selector-attr">[N]</span>; <br>    long <span class="hljs-selector-tag">Q</span><span class="hljs-selector-attr">[N]</span><span class="hljs-selector-attr">[M]</span>; <br>    long sum_element(long <span class="hljs-selector-tag">i</span>, long j) <br>    &#123; return <span class="hljs-selector-tag">P</span><span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span> + <span class="hljs-selector-tag">Q</span><span class="hljs-selector-attr">[j]</span><span class="hljs-selector-attr">[i]</span>; &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><pre><code class="assembly">long sum_element(long i, long j) i in %rdi, j in %rsi sum_element: leaq 0(,%rdi,8), %rdx # 8*isubq %rdi, %rdx # 7*iaddq %rsi, %rdx # j+7*ileaq (%rsi,%rsi,4), %rax # 5*jaddq %rax, %rdi # i+5*jmovq Q(,%rdi,8), %rax # Retrieve M[x + 8 (5j + i)] i-&gt;M=5addq P(,%rdx,8), %rax # Add M[x + 8 (7i + j)] j-&gt;N=7ret</code></pre></li></ul></li><li><p>leaw #2个字节<br>leal #4个字节<br>leaq #8个字节</p></li><li><p>leaq a(b, c, d), %rax 先计算地址a + b + c * d，然后把最终地址载到寄存器rax中</p></li></ul><h3 id="对矩阵乘法的优化"><a href="#对矩阵乘法的优化" class="headerlink" title="对矩阵乘法的优化"></a>对矩阵乘法的优化</h3><p>- </p><h2 id="data-alignment"><a href="#data-alignment" class="headerlink" title="data alignment"></a>data alignment</h2><ul><li>对原始数据类型的可分配地址进行了限制Many computer systems place restrictions on the allowable addresses for the primitive data types, requiring that the address for some objects must be a multiple of some value <em>K</em> (typically 2, 4, or 8).</li><li>目的是：读取内存时不会一个数据需要读两次或以上</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>c-4</title>
    <link href="/2023/02/22/c-4/"/>
    <url>/2023/02/22/c-4/</url>
    
    <content type="html"><![CDATA[<h1 id="item-18"><a href="#item-18" class="headerlink" title="item 18"></a>item 18</h1><h2 id="场景-amp-问题"><a href="#场景-amp-问题" class="headerlink" title="场景&amp;问题"></a>场景&amp;问题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Date</span>(<span class="hljs-type">int</span> month, <span class="hljs-type">int</span> day, <span class="hljs-type">int</span> year);<br>...<br>&#125;;<br><br><span class="hljs-function">Date <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">30</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1995</span>)</span></span>; <span class="hljs-comment">// Oops! Should be “3, 30” , not “30, 3”</span><br><span class="hljs-function">Date <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">40</span>, <span class="hljs-number">1995</span>)</span></span>; <span class="hljs-comment">// Oops! Should be “3, 30” , not “3, 40”</span><br></code></pre></td></tr></table></figure><ul><li>为了防止输入不合法 可以引入新的类型进行封装</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Day</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Day</span><span class="hljs-params">(<span class="hljs-type">int</span> d)</span>:val(d)&#123;</span>&#125;<br>    <span class="hljs-type">int</span> val;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Month</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Month</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span>:val(m)&#123;</span>&#125;<br>    <span class="hljs-type">int</span> val;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Year</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Year</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span>:val(y)&#123;</span>&#125;<br>    <span class="hljs-type">int</span> val;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Date</span>(<span class="hljs-type">const</span> Month&amp;m,<span class="hljs-type">const</span> Day&amp;d,<span class="hljs-type">const</span> Year&amp;y);<br>&#125;<br><span class="hljs-function">Date <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">30</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1995</span>)</span></span>; <span class="hljs-comment">// error! wrong types</span><br><span class="hljs-function">Date <span class="hljs-title">d</span><span class="hljs-params">(Day(<span class="hljs-number">30</span>), Month(<span class="hljs-number">3</span>), Year(<span class="hljs-number">1995</span>))</span></span>; <span class="hljs-comment">// error! wrong types</span><br><span class="hljs-function">Date <span class="hljs-title">d</span><span class="hljs-params">(Month(<span class="hljs-number">3</span>), Day(<span class="hljs-number">30</span>), Year(<span class="hljs-number">1995</span>))</span></span>; <span class="hljs-comment">// okay, types are correct</span><br></code></pre></td></tr></table></figure><ul><li>如果需要对输入的数据进行更多限制（月份只有1-12）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Month</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> Month <span class="hljs-title">Jan</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Month</span>(<span class="hljs-number">1</span>); &#125; <span class="hljs-comment">// functions returning all valid</span><br><span class="hljs-function"><span class="hljs-type">static</span> Month <span class="hljs-title">Feb</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Month</span>(<span class="hljs-number">2</span>); &#125; <span class="hljs-comment">// Month values; see below for ... // why these are functions, not</span><br><span class="hljs-function"><span class="hljs-type">static</span> Month <span class="hljs-title">Dec</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Month</span>(<span class="hljs-number">12</span>); &#125; <span class="hljs-comment">// objects</span><br>... <span class="hljs-comment">// other member functions </span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Month</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span></span>; <span class="hljs-comment">// prevent creation of new</span><br><span class="hljs-comment">// Month values</span><br>... <span class="hljs-comment">// month-specific data</span><br>&#125;;<br><span class="hljs-function">Date <span class="hljs-title">d</span><span class="hljs-params">(Month::Mar(), Day(<span class="hljs-number">30</span>), Year(<span class="hljs-number">1995</span>))</span></span>;  <br></code></pre></td></tr></table></figure><h3 id="cross-DLL-problem"><a href="#cross-DLL-problem" class="headerlink" title="cross DLL problem"></a>cross DLL problem</h3><ul><li><a href="https://stackoverflow.com/questions/1958643/is-it-ok-to-use-boostshared-ptr-in-dll-interface#:~:text=According%20to%20Scott%20Meyers%20in%20Effective%20C%2B%2B%20%283rd,the%20destructor%20from%20the%20dll%20that%20created%20it.">ref:dll和exe都停止时保证删除资源</a></li><li></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>c++-02</title>
    <link href="/2023/02/09/c-02/"/>
    <url>/2023/02/09/c-02/</url>
    
    <content type="html"><![CDATA[<h1 id="item-1"><a href="#item-1" class="headerlink" title="item 1"></a>item 1</h1><h2 id="场景-amp-问题"><a href="#场景-amp-问题" class="headerlink" title="场景&amp;问题"></a>场景&amp;问题</h2><h1 id="item-1-1"><a href="#item-1-1" class="headerlink" title="item 1"></a>item 1</h1><h2 id="场景-amp-问题-1"><a href="#场景-amp-问题-1" class="headerlink" title="场景&amp;问题"></a>场景&amp;问题</h2><h1 id="item-1-2"><a href="#item-1-2" class="headerlink" title="item 1"></a>item 1</h1><h2 id="场景-amp-问题-2"><a href="#场景-amp-问题-2" class="headerlink" title="场景&amp;问题"></a>场景&amp;问题</h2><h1 id="item-4"><a href="#item-4" class="headerlink" title="item 4"></a>item 4</h1><h2 id="场景-amp-问题-3"><a href="#场景-amp-问题-3" class="headerlink" title="场景&amp;问题"></a>场景&amp;问题</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++-01</title>
    <link href="/2023/02/09/C-01/"/>
    <url>/2023/02/09/C-01/</url>
    
    <content type="html"><![CDATA[<h1 id="item-8"><a href="#item-8" class="headerlink" title="item  8"></a>item  8</h1><h2 id="场景-amp-问题"><a href="#场景-amp-问题" class="headerlink" title="场景&amp;问题"></a>场景&amp;问题</h2><ul><li>c++并不喜欢在destructor中emit exception<ul><li>因为如果在容器或数组中，多个widget销毁都在emit exception 同一时刻有两个异常对C++很难处理，所以会terminate或者undefined behavior</li><li>就算是普通的destructor发出异常也容易导致提前terminate或者undefined behavior</li></ul></li></ul><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><h3 id="code-example"><a href="#code-example" class="headerlink" title="code example"></a>code example</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConnection</span> &#123;<br><span class="hljs-keyword">public</span>:<br>...<br><span class="hljs-function"><span class="hljs-type">static</span> DBConnection <span class="hljs-title">create</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// function to return</span><br><span class="hljs-comment">// DBConnection objects; params</span><br><span class="hljs-comment">// omitted for simplicity</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// close connection; throw an</span><br>&#125;;     <span class="hljs-comment">// exception if closing fails</span><br>---------------------------------------------------------------<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConn</span> &#123; <span class="hljs-comment">// class to manage DBConnection</span><br><span class="hljs-keyword">public</span>:    <span class="hljs-comment">// objects ...</span><br>~<span class="hljs-built_in">DBConn</span>()    <span class="hljs-comment">// make sure database connections</span><br>&#123;   <span class="hljs-comment">// are always closed</span><br>db.<span class="hljs-built_in">close</span>();<br>&#125;<br><span class="hljs-keyword">private</span>:<br>DBConnection db;<br>&#125;;<br>---------------------------------------------------------------<br>&#123; <span class="hljs-comment">// open a block</span><br><span class="hljs-function">DBConn <span class="hljs-title">dbc</span><span class="hljs-params">(DBConnection::create())</span></span>; <span class="hljs-comment">// create DBConnection object</span><br><span class="hljs-comment">// and turn it over to a DBConn</span><br><span class="hljs-comment">// object to manage</span><br>... <span class="hljs-comment">// use the DBConnection object</span><br><span class="hljs-comment">// via the DBConn interface</span><br>&#125; <span class="hljs-comment">// at end of block, the DBConn</span><br><span class="hljs-comment">// object is destroyed, thus</span><br><span class="hljs-comment">// automatically calling close on </span><br><span class="hljs-comment">// the DBConnection object</span><br></code></pre></td></tr></table></figure><ul><li>create a resource-managing class 来帮助该类进行关闭和退出</li><li>如果destructor执行没有异常这样是可以的 如果有异常抛出 DBConn’s destructor will propagate that exception, i.e. allow it to leave the destructor.</li></ul><h3 id="方案1-terminate-the-program"><a href="#方案1-terminate-the-program" class="headerlink" title="方案1 terminate the program"></a>方案1 terminate the program</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">DBConn::~<span class="hljs-built_in">DBConn</span>()<br>&#123;<br><span class="hljs-keyword">try</span> &#123; db.<span class="hljs-built_in">close</span>(); &#125;<br><span class="hljs-built_in">catch</span> (...) &#123;<br>make log entry that the call to close failed;<br>std::<span class="hljs-built_in">abort</span>();<br>&#125; &#125;<br></code></pre></td></tr></table></figure><ul><li>if allowing the exception to propagate from the destructor would lead to undefined behavior, this prevents that from happening. That is, calling abort may forestall undefined behavior.</li><li></li></ul><h3 id="方案2-Swallow-the-exception"><a href="#方案2-Swallow-the-exception" class="headerlink" title="方案2 Swallow the exception"></a>方案2 Swallow the exception</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">DBConn::~<span class="hljs-built_in">DBConn</span>()<br>&#123;<br><span class="hljs-keyword">try</span> &#123; db.<span class="hljs-built_in">close</span>(); &#125;<br><span class="hljs-built_in">catch</span> (...) &#123;<br>make log entry that the call to close failed;<br>&#125; &#125;<br></code></pre></td></tr></table></figure><ul><li>通常来说swallow exception并不好因为 it suppresses important information压缩了重要信息</li><li>但是有时候比起过早终止程序和ub 需要这种方法来让程序无论如何也要执行完毕</li></ul><blockquote><p>评价方案1 2 ：都无法让程序对最初的导致抛出异常的条件进行反应</p></blockquote><h3 id="方案3-包装一个函数来检测异常-并用destructor调用该函数"><a href="#方案3-包装一个函数来检测异常-并用destructor调用该函数" class="headerlink" title="方案3 包装一个函数来检测异常 并用destructor调用该函数"></a>方案3 包装一个函数来检测异常 并用destructor调用该函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConn</span> &#123;<br><span class="hljs-keyword">public</span>:<br>...<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-comment">// new function for</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">// client use</span><br>db.<span class="hljs-built_in">close</span>();<br>closed = <span class="hljs-literal">true</span>;<br>&#125;<br>~<span class="hljs-built_in">DBConn</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (!closed) &#123;<br><span class="hljs-keyword">try</span> &#123; <span class="hljs-comment">// close the connection</span><br>db.<span class="hljs-built_in">close</span>(); <span class="hljs-comment">// if the client didn’t</span><br>&#125;<br><span class="hljs-built_in">catch</span> (...) &#123; <span class="hljs-comment">// if closing fails,</span><br>make log entry that call to close failed; <span class="hljs-comment">// note that and ... // terminate or swallow</span><br>&#125; &#125; &#125;<br><span class="hljs-keyword">private</span>:<br>DBConnection db;<br><span class="hljs-type">bool</span> closed;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>如果一个操作涉及抛出异常和处理异常 则该异常必须来自非析构函数</li><li></li></ul><h1 id="item-9"><a href="#item-9" class="headerlink" title="item 9"></a>item 9</h1><h2 id="场景-amp-问题-1"><a href="#场景-amp-问题-1" class="headerlink" title="场景&amp;问题"></a>场景&amp;问题</h2><h3 id="code-example-1"><a href="#code-example-1" class="headerlink" title="code example"></a>code example</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transaction</span> &#123; <span class="hljs-comment">// base class for all</span><br><span class="hljs-keyword">public</span>: <span class="hljs-comment">// transactions</span><br><span class="hljs-built_in">Transaction</span>();<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// make type-dependent</span><br><span class="hljs-comment">// log entry ...</span><br>&#125;;<br>Transaction::<span class="hljs-built_in">Transaction</span>() <span class="hljs-comment">// implementation of</span><br>&#123; <span class="hljs-comment">// base class ctor</span><br>...<br><span class="hljs-built_in">logTransaction</span>(); <span class="hljs-comment">// as final action, log this</span><br>&#125; <span class="hljs-comment">// transaction</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BuyTransaction</span>: <span class="hljs-keyword">public</span> Transaction &#123; <span class="hljs-comment">// derived class</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// how to log trans-</span><br><span class="hljs-comment">// actions of this type ...</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SellTransaction</span>: <span class="hljs-keyword">public</span> Transaction &#123; <span class="hljs-comment">// derived class</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// how to log trans-</span><br><span class="hljs-comment">// actions of this type ...</span><br>&#125;;<br>BuyTransaction b;<br></code></pre></td></tr></table></figure><ul><li><p>这里基类的Transaction的constructor会调用一个virtual函数 但是这个函数virtual函数并非子类的版本而是积累的版本 因为此时子类尚未构建 子类的所有成员都是未初始化的 会导致ub</p></li><li><p>During base class construction, virtual functions never go down into derived classes. Instead, the object behaves as if it were of the base type.</p></li><li><p>During base class construction of a derived class object, the type of the object <em>is</em> that of the base class.</p></li><li><p>当在执行基类的初始化部分时 这个object就会被视为是基类类型 所有virtual函数会被解析成基类，所有运行和类型信息都是基类</p></li><li><p>因为派生类的成员都还没有初始化 所以此时需要假设他们都不存在 即此时这个object当作基类类型</p></li><li><p>An object doesn’t become a derived class object until execution of a derived class constructor begins. 一旦派生类析构函数运行，对象的派生类数据成员就会假定未定义的值，因此C++将它们视为它们不再存在。在进入基类析构函数时，对象就成为一个基类对象</p></li></ul><h2 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h2><ul><li>Turn logTransaction into a non-virtual function in Transaction, then require that derived class constructors pass the necessary log information to the Transaction constructor. That function can then safely call the non virtual logTransaction.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transaction</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Transaction</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; logInfo)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; logInfo)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// now a non-virtual func ...</span><br>&#125;;<br>Transaction::<span class="hljs-built_in">Transaction</span>(<span class="hljs-type">const</span> std::string&amp; logInfo) &#123;<br>...<br><span class="hljs-built_in">logTransaction</span>(logInfo); <span class="hljs-comment">// now a non-</span><br>&#125; <span class="hljs-comment">// virtual call</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BuyTransaction</span>: <span class="hljs-keyword">public</span> Transaction &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">BuyTransaction</span>( parameters )<br>: <span class="hljs-built_in">Transaction</span>(<span class="hljs-built_in">createLogString</span>( parameters )) <span class="hljs-comment">// pass log info</span><br>&#123; ... &#125; <span class="hljs-comment">// to base class ... // constructor</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> std::string <span class="hljs-title">createLogString</span><span class="hljs-params">( parameters )</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/questions/7405740/how-can-i-initialize-base-class-member-variables-in-derived-class-constructor">在派生类中对基类的成员进行初始化</a></p><h1 id="item-10"><a href="#item-10" class="headerlink" title="item 10"></a>item 10</h1><h2 id="场景-amp-问题-2"><a href="#场景-amp-问题-2" class="headerlink" title="场景&amp;问题"></a>场景&amp;问题</h2><ul><li>c++允许连续等号赋值 而且 that assignment is right-associative, so the above assignment chain is parsed like</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x, y, z;<br>x = y = z = <span class="hljs-number">15</span>; <span class="hljs-comment">// chain of assignments</span><br>x = (y = (z = <span class="hljs-number">15</span>));<br></code></pre></td></tr></table></figure><ul><li>原理：assignment returns a reference to its left-hand argument</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++">Widget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs) <span class="hljs-comment">// return type is a reference to</span><br>&#123; <span class="hljs-comment">// the current class</span><br>...<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// return the left-hand object</span><br>&#125;<br>...<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>...<br>Widget&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> Widget&amp; rhs) <span class="hljs-comment">// the convention applies to</span><br>&#123; <span class="hljs-comment">// +=, -=, *=, etc.</span><br>...<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>Widget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">int</span> rhs) <span class="hljs-comment">// it applies even if the</span><br>&#123; <span class="hljs-comment">// operator’s parameter type</span><br>... <span class="hljs-comment">// is unconventional</span><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>...<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="solution-2"><a href="#solution-2" class="headerlink" title="solution"></a>solution</h2><ul><li>记住约定：Have assignment operators return a reference to <code>*this</code></li></ul><h1 id="item-11"><a href="#item-11" class="headerlink" title="item 11"></a>item 11</h1><h2 id="场景-amp-问题-3"><a href="#场景-amp-问题-3" class="headerlink" title="场景&amp;问题"></a>场景&amp;问题</h2><h3 id="code-example-2"><a href="#code-example-2" class="headerlink" title="code example"></a>code example</h3><ul><li>assignment to self</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123; ... &#125;;<br>Widget w;<br>...<br>w = w; <span class="hljs-comment">// assignment to self</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>tetris开发笔记</title>
    <link href="/2023/01/30/post/"/>
    <url>/2023/01/30/post/</url>
    
    <content type="html"><![CDATA[<h2 id="多个头文件-定义类的h文件中的全局变量的问题"><a href="#多个头文件-定义类的h文件中的全局变量的问题" class="headerlink" title="多个头文件 定义类的h文件中的全局变量的问题"></a>多个头文件 定义类的h文件中的全局变量的问题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br></code></pre></td></tr></table></figure><p>为什么.h文件中不能定义全局变量</p>]]></content>
    
    
    
    <tags>
      
      <tag>qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue-3</title>
    <link href="/2023/01/09/vue-3/"/>
    <url>/2023/01/09/vue-3/</url>
    
    <content type="html"><![CDATA[<h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><p><img src="/assets/image-20230110160411408.png" alt="image-20230110160411408"></p><h3 id="定时器的函数不是vue管理的"><a href="#定时器的函数不是vue管理的" class="headerlink" title="定时器的函数不是vue管理的"></a>定时器的函数不是vue管理的</h3><ul><li>不是vue管理的</li><li>箭头函数的this和普通函数的this</li><li>箭头函数会寻找外面函数的this作为自己的this</li><li><img src="/assets/image-20230128113016137.png" alt="image-20230128113016137"></li></ul><h3 id="不能亲自去修改dom"><a href="#不能亲自去修改dom" class="headerlink" title="不能亲自去修改dom"></a>不能亲自去修改dom</h3><ul><li><p>引入vue的本意就是通过vue去修改dom</p></li><li><p><img src="/assets/image-20230128114224306.png" alt="image-20230128114224306"></p><p>这种方式是不可取的</p></li><li><p><img src="/assets/image-20230128132724077.png" alt="image-20230128132724077"></p></li><li><p><img src="/assets/image-20230128132836111.png" alt="image-20230128132836111"></p><p>template不会破坏结构 对比新建一个div把属性包裹起来 template不会新键div</p><p>template只能配合v-if使用</p></li></ul><p><img src="/assets/image-20230128132935691.png" alt="image-20230128132935691"></p><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><p><img src="/assets/image-20230201094926427.png" alt="image-20230201094926427"></p><p><img src="/assets/image-20230201095042094.png" alt="image-20230201095042094"></p><img src="assets/image-20230201103022263.png" alt="image-20230201103022263" style="zoom:50%;" /><img src="assets/image-20230201103105598.png" alt="image-20230201103105598" style="zoom:50%;" /><p><img src="/assets/image-20230201103245975.png" alt="image-20230201103245975"></p>]]></content>
    
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue-2</title>
    <link href="/2023/01/03/vue-2/"/>
    <url>/2023/01/03/vue-2/</url>
    
    <content type="html"><![CDATA[<h3 id="数据双向绑定"><a href="#数据双向绑定" class="headerlink" title="数据双向绑定"></a>数据双向绑定</h3><h4 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h4><ul><li><p>只能运用在表单类（输入类）元素上（input,select）</p><p>体现用户交互对数据产生影响 数据又重新渲染到页面</p></li><li><p>标签类（h1234）上不能使用</p><p>标签类元素并不接受用户输入 所以不会影响到数据</p></li></ul><h3 id="用户自定义代码片段"><a href="#用户自定义代码片段" class="headerlink" title="用户自定义代码片段"></a>用户自定义代码片段</h3><h3 id="vue所管理的函数"><a href="#vue所管理的函数" class="headerlink" title="vue所管理的函数"></a>vue所管理的函数</h3><p>vue管理的函数（比如函数式的data）不能写成箭头式函数 否则他的this就不是vue而是window了</p><h2 id="MVVM模型"><a href="#MVVM模型" class="headerlink" title="MVVM模型"></a>MVVM模型</h2><p>M:model(对应data中的数据)</p><p>V:view(模板)</p><p>VM:view model(vue实例对象)</p><h2 id="dom结构"><a href="#dom结构" class="headerlink" title="dom结构"></a>dom结构</h2><p>DOM是Document Object Model(文档对象模型)的缩写，HTML DOM则是专门适用与HTML&#x2F;XHTML的文档对象模型。熟悉软件开发的人员可以将HTML DOM理解为网页的API。它将网页中的各个元素都看作一个个对象，从而使网页中的元素也可以被计算机语言获取或者编辑。 例如Javascript就可以利用HTML DOM动态的修改网页。</p><p>关于对象引用方式,一,DOM对象引用,二,自定义的对象引用</p><h2 id="原型链（vm里面的所有属性）"><a href="#原型链（vm里面的所有属性）" class="headerlink" title="原型链（vm里面的所有属性）"></a>原型链（vm里面的所有属性）</h2><h2 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h2><p><img src="/assets/image-20230105154311421.png" alt="image-20230105154311421"></p><ul><li>只有写在data中的元素（不论是数据还是函数）才都会进行数据代理 但是如果是函数用数据代理是没有意义的</li><li>数据代理会给该元素配置getter和setter 数据由于会随时改变所以需要读取和修改 但是函数只是被调用 因此不需要getter和setter</li><li>函数应该写在methods中</li></ul><h3 id="mouse-event-x2F-pointer-event"><a href="#mouse-event-x2F-pointer-event" class="headerlink" title="mouse event&#x2F;pointer event"></a>mouse event&#x2F;pointer event</h3><p>目前绝大多数的 Web 内容都假设用户的指针定点设备为鼠标。然而，近年来的新兴设备支持更多不同方式的指针定点输入，如各类触控笔和触摸屏幕等。这就有必要扩展现存的定点设备事件模型，以有效追踪各类*<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Pointer_events#term_pointer_event">指针事件</a>*。</p><p>指针事件 - Pointer events 是一类可以为定点设备所触发的 DOM 事件。它们被用来创建一个可以有效掌握各类输入设备（鼠标、触控笔和单点或多点的手指触摸）的统一的 DOM 事件模型。所谓 <em><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Pointer_events#term_pointer">指针</a></em> 是指一个可以明确指向屏幕上某一组坐标的硬件设备。建立这样一个单独的事件模型可以有效的简化 Web 站点与应用所需的工作，同时也便于提供更加一致与良好的用户体验，无需关心不同用户和场景在输入硬件上的差异。另外，对于某些需要处理特定设备的场景，指针事件也定义了一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType"><code>pointerType</code> (en-US)</a> 属性用以查看触发事件的设备类型。</p><p>这些事件需要能够处理 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent"><code>mouse events</code></a> 之类较为通用的指针输入（<code>mousedown/pointerdown</code>, <code>mousemove/pointermove</code>, 等）。因此，指针事件的类型，很大程度上类似于当前的鼠标事件类型。</p><h2 id="js事件冒泡"><a href="#js事件冒泡" class="headerlink" title="js事件冒泡"></a>js事件冒泡</h2><ul><li><p>js中的事件流分为捕获阶段和冒泡阶段</p></li><li><p>捕获事件 -&gt; 事件冒泡</p></li><li><p>由外到内 由内到外</p></li></ul><p>vue事件修饰符</p>]]></content>
    
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue-1</title>
    <link href="/2023/01/03/vue-1/"/>
    <url>/2023/01/03/vue-1/</url>
    
    <content type="html"><![CDATA[<h2 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h2><ul><li>live server</li><li>vue snippet</li></ul><h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><h4 id="插值语法"><a href="#插值语法" class="headerlink" title="插值语法"></a>插值语法</h4><p>id选择器</p><p>类选择器</p><ul><li>解析标签体内容（注意<code>&#123;&#123;&#125;&#125;</code>是js表达式 区分 js语句）</li><li>hhh <code>两个&#123;&#125;</code>会引起hexo报错</li></ul><h4 id="指令语法"><a href="#指令语法" class="headerlink" title="指令语法"></a>指令语法</h4><ul><li>用于解析标签（包括标签属性，标签体内容，绑定事件…）</li><li>指令通常都是v-开头的</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/11/19/11/"/>
    <url>/2022/11/19/11/</url>
    
    <content type="html"><![CDATA[<h1 id="顺序查找法"><a href="#顺序查找法" class="headerlink" title="顺序查找法"></a>顺序查找法</h1><ul><li><p>如果查找的关键字不在线性表中 需要进行n+1次关键字的比较</p></li><li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211192211924.png" alt="image-20221013134306357"></p></li></ul><h3 id="sequential-search"><a href="#sequential-search" class="headerlink" title="sequential search"></a>sequential search</h3><ul><li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211192212152.png" alt="image-20221013135040886"></li></ul><h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><h3 id="basics"><a href="#basics" class="headerlink" title="basics"></a>basics</h3><ul><li>需要对数据元素进行编号访问 必须存储在数组中</li><li></li></ul><h3 id="折半查找树"><a href="#折半查找树" class="headerlink" title="折半查找树"></a>折半查找树</h3><ul><li><a href="https://blog.csdn.net/zhupengqq/article/details/51837908">计算平均查找长度（成功&#x2F;不成功</a><ul><li>成功：从根结点数到待查找结点一共经过的结点数</li><li>不成功：补缺失的结点</li></ul></li><li><a href="https://www.cnblogs.com/zipeilu/p/14626027.html">折半查找平均查找长度推导 - zipeilu - 博客园 (cnblogs.com)</a></li><li></li></ul><p>binary search</p><ul><li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211192212440.png" alt="image-20221013141320990"></li></ul><h3 id="block-search-（linear-search的改进）"><a href="#block-search-（linear-search的改进）" class="headerlink" title="block search （linear search的改进）"></a><strong>block search （linear search的改进）</strong></h3><ul><li><p>不要求等分块儿（块儿里元素个数不要求都相等）</p></li><li><p>不限制顺序</p></li><li><p>前一块的最大键码 小于 第二块的最小键码</p></li></ul><p><a href="https://www.tutorialspoint.com/implementing-block-search-in-javascript">实现code</a></p><h3 id="B-tree-–balanced-tree-amp-多分树"><a href="#B-tree-–balanced-tree-amp-多分树" class="headerlink" title="B-tree –balanced tree&amp;多分树"></a>B-tree –balanced tree&amp;多分树</h3><h4 id="basics-1"><a href="#basics-1" class="headerlink" title="basics"></a>basics</h4><ul><li>控制树的高度比较小 所以磁盘的读取比较少</li><li></li><li>所有叶子结点必须在同一层（方便查找失败的处理）</li><li>k个子节点的非叶子节点包含k-1个关键码</li><li></li></ul><h3 id="2-3-tree"><a href="#2-3-tree" class="headerlink" title="2-3 tree"></a>2-3 tree</h3><ul><li><p>b-tree的延申</p></li><li></li><li><p><a href="https://blog.csdn.net/weixin_43305485/article/details/120619942">二分查找 的 树的结构</a></p></li></ul><p><img src="/assets/image-20221018104651165.png" alt="image-20221018104651165"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/11/19/10/"/>
    <url>/2022/11/19/10/</url>
    
    <content type="html"><![CDATA[<h2 id="二部图"><a href="#二部图" class="headerlink" title="二部图"></a>二部图</h2><ul><li>边的限制（两个顶点分别在两个子集）</li></ul><h3 id="判断二部图"><a href="#判断二部图" class="headerlink" title="判断二部图"></a>判断二部图</h3><h4 id="染色法"><a href="#染色法" class="headerlink" title="染色法"></a>染色法</h4><ul><li>对于二分图的判断方法最常见的是染色法，顾名思义就是我们对每一个点进行染色操作，我们只用黑白两种颜色，问能不能使所有的点都染上了色，而且相邻两个点的颜色不同，如果可以那么这个图就是一个二分图，对于判断是否是一个二分图的方法可以用dfs和bfs两种方式去实现。</li><li>定理：<strong>一张图是二分图，当且仅当图中不存在奇环（长度为奇数的环）。一定不含有奇数环，可能包含长度为偶数的环， 不一定是连通图</strong>定理：</li><li><strong>当且仅当</strong>无向图G的<strong>每一个环</strong><br>的结点数<strong>均是偶数</strong>时，图G才是一个二分图。<strong>如果无环，相当于每的结点数为 0，故也视为二分图。</strong></li><li>使用深度优先搜索对图进行染色，共两种颜色。有边相连的两个点染成不同的颜色。若染色过程中出现冲突，则该图不是二分图。否则是二分图。</li><li>通过顶点的neighbor染色：BFS</li></ul><h3 id="对于无权二部图的最大匹配"><a href="#对于无权二部图的最大匹配" class="headerlink" title="对于无权二部图的最大匹配"></a>对于无权二部图的最大匹配</h3><ul><li>matching是edges的子集 matching不能含有有共同顶点的边</li><li>Bipartite matching is the problem of finding a <strong>subgraph</strong> in a bipartite graph where no two edges share an endpoint.</li></ul><h3 id="有权二部图的最大匹配"><a href="#有权二部图的最大匹配" class="headerlink" title="有权二部图的最大匹配"></a>有权二部图的最大匹配</h3><ul><li>如果权重有正有负-&gt;等价于找到最小化匹配（即不喜欢为正 喜欢为负）</li></ul><h4 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h4><ul><li><a href="https://www.cnblogs.com/smuxiaolei/p/8343472.html">简单理解思想—-递归的腾位置</a></li></ul><p>先把最大匹配转化为最小匹配然后使用匈牙利算法</p><ul><li>限制条件：必须二部图的两个子集是元素个数相等的</li><li>O(n^3)</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/11/19/09/"/>
    <url>/2022/11/19/09/</url>
    
    <content type="html"><![CDATA[<h3 id="basics"><a href="#basics" class="headerlink" title="basics"></a>basics</h3><h4 id="流网络"><a href="#流网络" class="headerlink" title="流网络"></a>流网络</h4><ul><li><p>flow network: the graph is connected and since each vertex other than s(source) has at least one entering edge</p><ul><li>so |E| &gt;&#x3D; |V| - 1</li></ul></li><li><p>两个constraints</p><ul><li>capacity constraint:</li><li>flow conservation: flow in equals flow out</li></ul></li><li><p>flow：实际流量</p></li><li><p>capacity：最大容量</p></li><li><p>residual：余量&#x3D;最大容量-实际流量</p></li><li><p>blocking flow: A blocking flow is a union of flows along admissible paths that <strong>saturate at least one arc</strong> on every admissible path. (也就是naive algorithm得到的解)</p></li></ul><h4 id="最小割-min-cut"><a href="#最小割-min-cut" class="headerlink" title="最小割 min cut"></a>最小割 min cut</h4><ul><li><p>a cut whose capacity is minimum over all cuts of the network</p><ul><li>区分一下capacity and flow</li><li>flow是有方向的 （向量）必须带符号进行加减</li><li>capacity是无方向（标量） 只考虑一个方向最大的即可</li></ul></li><li><p>最小割的capacity 会 限制最大流的值 因为最大流</p></li></ul><p><a href="https://blog.csdn.net/flying_coding/article/details/106973854">reference</a></p><ul><li>思考这样一个问题：在给定的图中，如何判断一个源点s到终点t是否有路径存在呢？<ul><li><strong>若从S到T的路径为零，则不存在s到t的路径，其中s∈S，t∈T。</strong></li><li><strong>一个图中从s到t的路径最多不超过其S,T最小割的数量,其中s∈S，t∈T。</strong></li></ul></li></ul><p><a href="https://zhuanlan.zhihu.com/p/65793018">reference</a></p><ul><li>[对最大流最小割定理的证明]([Max-flow Min-cut Algorithm | Brilliant Math &amp; Science Wiki](<a href="https://brilliant.org/wiki/max-flow-min-cut-algorithm/#:~:text=The">https://brilliant.org/wiki/max-flow-min-cut-algorithm/#:~:text=The</a> max-flow min-cut theorem is a network flow,would totally disconnect the source from the sink.))</li><li></li></ul><h3 id="Naive-algorithm"><a href="#Naive-algorithm" class="headerlink" title="Naive algorithm"></a>Naive algorithm</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul><li>初始化的residual 图 &#x3D;&#x3D; original 图</li><li>选择Augmenting path（a path from 𝑠 to 𝑡 that does not contain cycles.）</li></ul><h3 id="Ford-Fulkerson"><a href="#Ford-Fulkerson" class="headerlink" title="Ford-Fulkerson"></a>Ford-Fulkerson</h3><h4 id="basics-1"><a href="#basics-1" class="headerlink" title="basics"></a>basics</h4><ul><li><p>核心：residual networks, augmenting paths, cuts</p></li><li><p>although each iteration of the method increases the value of the flow, we shall see that the flow on any particular edge of G may increase or decrease.</p><p>decreasing the flow on some edges may INCREASE the total flow from source to sink.</p></li><li><p>residual graph中引入了相反方向的edge是为了表达decrease这条边的流量（sending the flow back along an edge is equivalent to decreasing the flow on the edge)</p><p>residual graph中的edge数量小于等于原本edges数量的两倍</p></li><li><p>结束条件：residual network contains no augmenting path</p></li></ul><h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4><ul><li><p><a href="https://www.desgard.com/algo/docs/part4/ch03/2-ford-fulkerson/">basics</a></p><ul><li><strong>通过将流量推回这种操作，从而得到新的流</strong> 。为什么要这么做呢？其实原因就是 <strong>因为对一条增广路不一定输入这条增广路的上限流量就能保证全局的最大流量</strong> 。再提高一个维度来看我们之前的思路，<strong>其实一直是“贪心”思想在引导我们加流和拆边操作，但是贪心并不能获得全局最大流量，这也是之前动态规划能够解决贪心对于全局最优解无法实现的问题</strong> 。</li><li>贪心只能得到局部的最优解 因此naive算法得到的不会是最终的最大流解</li></ul></li><li><p><a href="https://emory.gitbook.io/dsa-java/network-flow/ford-fulkerson-algorithm">演示worst case为什么是f*m</a></p></li><li><p>Ford-Fulkerson算法的时间复杂度取决于增广路径如何决定</p><p>如果所有的容量都是整数，有一个Ford-Fulkerson算法的直接实现的时间复杂度O(|E||f*|),其中f*由算法决定</p></li></ul><h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><ul><li><p>允许undo path</p></li><li><p>最后删除所有的undo path</p></li><li><p>时间复杂度</p><p><a href="https://stackoverflow.com/questions/33565995/time-complexity-of-the-ford-fulkerson-method-in-a-flow-network-with-unit-capacit">algorithm - Time complexity of the Ford-Fulkerson method in a flow network with unit capacity edges - Stack Overflow</a></p></li></ul><h3 id="Edmonds-Karp-algorithm"><a href="#Edmonds-Karp-algorithm" class="headerlink" title="Edmonds-Karp algorithm"></a>Edmonds-Karp algorithm</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><ul><li><p><strong>Edmonds–Karp algorithm</strong> is an optimized implementation of the Ford–Fulkerson method for computing the maximum flow in a flow network in <strong>O(V E^2)</strong> time instead of <strong>O(E |max_flow|)</strong> in case of Ford-Fulkerson algorithm.</p></li><li><p>The algorithm is identical to the Ford–Fulkerson algorithm, except that the search order when finding the augmenting path is defined. The path found must be a shortest path that has available capacity.</p></li><li><p><img src="/assets/image-20221006221449948.png" alt="image-20221006221449948"></p></li><li><p>This can be found by a <a href="https://en.wikipedia.org/wiki/Breadth-first_search">breadth-first search</a>, where we apply a weight of 1 to each edge. The running time of {\displaystyle O(|V||E|^{2})}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ae5bc5dfaecce53a04efd47719ac640aa983e706" alt="{\displaystyle O(|V||E|^{2})}"> is found by showing that each augmenting path can be found in {\displaystyle O(|E|)}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/976fe7f1e011d0dcdb3d6163754c877aaad5187f" alt="O(|E|)"> time, that every time at least one of the {\displaystyle E}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4232c9de2ee3eec0a9c0a19b15ab92daa6223f9b" alt="E"> edges becomes saturated (an edge which has the maximum possible flow), that the distance from the saturated edge to the source along the augmenting path must be longer than last time it was saturated, and that the length is at most {\displaystyle |V|}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9ddcffc28643ac01a14dd0fb32c3157859e365a7" alt="|V|">.</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/11/19/07/"/>
    <url>/2022/11/19/07/</url>
    
    <content type="html"><![CDATA[<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><h2 id="basics"><a href="#basics" class="headerlink" title="basics"></a>basics</h2><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">小明有<span class="hljs-number"> 2 </span>个小时的作业，回家一共有<span class="hljs-number"> 4 </span>个小时做作业的时间。他可以选择一开始就做，或者因为「ddl 综合征」最后<span class="hljs-number"> 2 </span>小时才开始做。此时「做作业最早的时间」和「做作业的最晚时间」是不等的。<br>老师知道小明的情况后将小明的作业增加到了<span class="hljs-number"> 4 </span>个小时的量，小明做作业的时间还是<span class="hljs-number"> 4 </span>个小时。小明只能回家就开始做作业才能做完。此时「做作业最早的时间」和「做作业的最晚时间」是相等的。<br>「做作业最早的时间」和「做作业的最晚时间」是相等的说明：如果做作业的时间延误，将会导致整个工期延误，做作业的时间缩短，整个工期的最短时间就会缩短。<br>我们将「做作业」抽象为「活动」Activity，「作业完成」抽象为「事件」Event<br>关键路径定义：活动的最早发生时间和最晚发生时间相等的路径就是关键路径<br></code></pre></td></tr></table></figure><ul><li>DAG（Directed Acyclic Graph简称DAG），就是有向无环图，DAG这种图中的所有边都是有向边，而且从任意一个顶点开始，都找不到回到起始点的环路。当且仅当一个有向图为有向无环图（directed acyclic graph，或称DAG）时，才能得到对应于该图的拓扑排序。每一个有向无环图都至少存在一种拓扑排序</li><li>一个可以进行拓扑排序的DAG图的基本特征，必然存在至少一个入度为0的节点，如此才可以排序。有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。</li><li>顶点表示事件 边表示活动 边的权值表示活动所需要的时间</li><li>边的方向表示活动可以在起点事件之后开始 在终点事件之前完成</li><li>AOE网</li><li>完成工程的最短时间是从源点到汇点的最长路径的长度 称为关键路径</li></ul><p><a href="https://tiemchart.com/blogs/training/forward-pass-and-backward-pass/#:~:text=Forward%20pass%20is%20a%20technique%20to%20move%20forward,if%20there%20is%20any%20slack%20in%20the%20activity.">reference</a></p><ul><li><p>forward pass：计算最早结束时间</p><p>In order to calculate Early Finish, we use forward pass. Means moving from Early Start towards right to come up with Early Finish of the project.</p></li><li><p>backward pass：计算最晚开始时间</p><p>Late Start (LS) is the latest date that the activity can finish without causing a delay to the project completion date.</p></li></ul><p><a href="https://zhuanlan.zhihu.com/p/337438327">reference</a></p><ul><li><strong>最早发生时间：从前往后，前驱结点到当前结点所需时间，取最大值。</strong></li><li><strong>最迟发生时间：从后往前，后继结点的最迟发生时间-边权值，取最小值。</strong></li></ul><p>1  3 2 4 5 6</p><p>13246</p><p>13256</p><h2 id="steps"><a href="#steps" class="headerlink" title="steps"></a>steps</h2><ul><li>Identify vertices that have no incoming edges （The “in-degree” of these vertices is zero）<ul><li>If no such vertices, graph has only cycle(s) (cyclic graph) Topological sort not possible – Halt.</li></ul></li><li>Delete this vertex of in-degree 0 and all its outgoing edges from the graph. Place it in the output.</li><li>Repeat Step 1 and Step 2 until graph is empty</li></ul><h3 id="判断是否为有向图"><a href="#判断是否为有向图" class="headerlink" title="判断是否为有向图"></a>判断是否为有向图</h3><ul><li>在图论中，如果一个<a href="https://baike.baidu.com/item/%E6%9C%89%E5%90%91%E5%9B%BE?fromModule=lemma_inlink">有向图</a>无法从某个顶点出发经过若干条边回到该点，则这个图是一个<strong>有向无环图</strong>（DAG图）。</li><li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211192229111.png" alt="image-20221119150809245"></li></ul><p>这是有向无环图</p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; adj;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">indegree</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br><span class="hljs-type">int</span> u,v;<br>cin&gt;&gt;u&gt;&gt;v;<br>adj[u].<span class="hljs-built_in">push_back</span>(v);<br>indeg[v]++<br>&#125;<br>queue&lt;<span class="hljs-type">int</span>&gt; pq;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">if</span>(indeg[i]==<span class="hljs-number">0</span>)&#123;<br>pq.<span class="hljs-built_in">push</span>(i);<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())&#123;<br>cnt++;<br><span class="hljs-type">int</span> x = pq.<span class="hljs-built_in">front</span>();<br>pq.<span class="hljs-built_in">pop</span>();<br>cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it:adj[x])&#123;<br>indeg[it]--;<br><span class="hljs-keyword">if</span>(indeg[it]==<span class="hljs-number">0</span>)<br>pq.<span class="hljs-built_in">push</span>(it);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><a href="https://www.geeksforgeeks.org/cpp-program-for-topological-sorting/">stack实现</a></li></ul><p>复杂度分析</p><ul><li><p>version 1</p><ul><li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211192229814.png" alt="image-20221119160556133"></li></ul></li><li><p>version 2 Initialize and maintain a queue (or stack) of vertices with In-Degree 0</p><ul><li>Store each vertex’s In-Degree in an array Initialize a queue with all in-degree zero vertices While there are vertices remaining in the queue:       ➭ Dequeue and output a vertex       ➭ Reduce In-Degree of all vertices adjacent to it by 1       ➭ Enqueue any of these vertices whose In-Degree became zero</li><li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211192229866.png" alt="image-20221119160658194"></li><li><img src="/assets/image-20221119160731648.png" alt="image-20221119160731648"></li></ul></li></ul><p>​</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/11/19/05/"/>
    <url>/2022/11/19/05/</url>
    
    <content type="html"><![CDATA[<h1 id="Minimum-cost-spanning-trees"><a href="#Minimum-cost-spanning-trees" class="headerlink" title="Minimum-cost spanning trees"></a>Minimum-cost spanning trees</h1><ul><li>connected undirected weighted graph</li><li></li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="最小生成树的性质"><a href="#最小生成树的性质" class="headerlink" title="最小生成树的性质"></a>最小生成树的性质</h3><ul><li>A minimum spanning tree is a subgraph of an undirected weighted graph G, such that<ul><li>It is a tree (i.e. it is acyclic)</li><li>It covers all the vertices and contains |V| - 1 edges</li></ul></li><li>Not necessarily unique A graph may have many spanning trees.</li></ul><blockquote><p>prim and kruskal 算法用于generate最小生成树</p></blockquote><h2 id="prim"><a href="#prim" class="headerlink" title="prim"></a>prim</h2><ul><li><p>Prim: (build tree incrementally)</p><p>Pick lower cost edge connected to known (incomplete) spanning tree that does not create a cycle and expand to include it in the tree</p></li></ul><h3 id="steps"><a href="#steps" class="headerlink" title="steps"></a>steps</h3><ul><li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191609200.png" alt="image-20221117221621810"></p></li><li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191609807.png" alt="image-20221117221005358"></p></li></ul><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><ul><li><pre><code class="c++">// A C++ program for Prim&#39;s Minimum// Spanning Tree (MST) algorithm. The program is// for adjacency matrix representation of the graph#include &lt;bits/stdc++.h&gt;using namespace std; // Number of vertices in the graph#define V 5 // A utility function to find the vertex with// minimum key value, from the set of vertices// not yet included in MSTint minKey(int key[], bool mstSet[])&#123;    // Initialize min value    int min = INT_MAX, min_index;     for (int v = 0; v &lt; V; v++)        if (mstSet[v] == false &amp;&amp; key[v] &lt; min)            min = key[v], min_index = v;     return min_index;&#125; // A utility function to print the// constructed MST stored in parent[]void printMST(int parent[], int graph[V][V])&#123;    cout &lt;&lt; &quot;Edge \tWeight\n&quot;;    for (int i = 1; i &lt; V; i++)        cout &lt;&lt; parent[i] &lt;&lt; &quot; - &quot; &lt;&lt; i &lt;&lt; &quot; \t&quot;             &lt;&lt; graph[i][parent[i]] &lt;&lt; &quot; \n&quot;;&#125; // Function to construct and print MST for// a graph represented using adjacency// matrix representationvoid primMST(int graph[V][V])&#123;    // Array to store constructed MST    int parent[V];     // Key values used to pick minimum weight edge in cut    int key[V];     // To represent set of vertices included in MST    bool mstSet[V];     // Initialize all keys as INFINITE    for (int i = 0; i &lt; V; i++)        key[i] = INT_MAX, mstSet[i] = false;     // Always include first 1st vertex in MST.    // Make key 0 so that this vertex is picked as first    // vertex.    key[0] = 0;    parent[0] = -1; // First node is always root of MST     // The MST will have V vertices    for (int count = 0; count &lt; V - 1; count++) &#123;        // Pick the minimum key vertex from the        // set of vertices not yet included in MST        int u = minKey(key, mstSet);         // Add the picked vertex to the MST Set        mstSet[u] = true;         // Update key value and parent index of        // the adjacent vertices of the picked vertex.        // Consider only those vertices which are not        // yet included in MST        for (int v = 0; v &lt; V; v++)             // graph[u][v] is non zero only for adjacent            // vertices of m mstSet[v] is false for vertices            // not yet included in MST Update the key only            // if graph[u][v] is smaller than key[v]            if (graph[u][v] &amp;&amp; mstSet[v] == false                &amp;&amp; graph[u][v] &lt; key[v])                parent[v] = u, key[v] = graph[u][v];    &#125;     // print the constructed MST    printMST(parent, graph);&#125;<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br><br>- ```<br>  <span class="hljs-built_in">bool</span> Graph&lt;T&gt;::<span class="hljs-constructor">Prim(<span class="hljs-params">int</span> <span class="hljs-params">from</span>,LinkList&lt;Edge&lt;T&gt;&gt; &amp;<span class="hljs-params">mst</span>)</span>&#123;<br>  T* nearest = <span class="hljs-keyword">new</span> T<span class="hljs-literal">[<span class="hljs-identifier">vertexNum</span>]</span>;<br>  <span class="hljs-built_in">int</span>* neighbor = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">vertexNum</span>]</span>;s<br>  <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;vertexNum;i++)&#123;<br>  neighbor<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>=from;<br>  nearest<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>=MAX_VALUE;<br>  &#125;<br>  <span class="hljs-keyword">for</span>(Edge&lt;T&gt; e=<span class="hljs-constructor">FirstEdge(<span class="hljs-params">from</span>)</span>;<span class="hljs-constructor">IsEdge(<span class="hljs-params">e</span>)</span>;e=<span class="hljs-constructor">NextEdgge(<span class="hljs-params">e</span>)</span>)&#123;<br>  nearest<span class="hljs-literal">[<span class="hljs-identifier">e</span>.<span class="hljs-identifier">end</span>]</span> = e.weight; <span class="hljs-comment">//从start开始到start相连的边的权值初始化</span><br>  &#125;<br>  neighbor<span class="hljs-literal">[<span class="hljs-identifier">from</span>]</span> = -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i =<span class="hljs-number">1</span>;i&lt;vertexNum;i++)&#123; <span class="hljs-comment">//最小生成树是n-1条边</span><br>  T min = MAX_VALUE;<br>  <span class="hljs-built_in">int</span> v = -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;vertexNum;j++)&#123;<br>  <span class="hljs-keyword">if</span>(nearest<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>&lt;min<span class="hljs-operator"> &amp;&amp; </span>neighbor<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>&gt;-<span class="hljs-number">1</span>)&#123;<br>  min = nearest<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>;<br>  v=j;<br>  &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(v&gt;=<span class="hljs-number">0</span>)&#123;<br>  Edge&lt;T&gt; tmp = (neighbor<span class="hljs-literal">[<span class="hljs-identifier">v</span>]</span>,v,min);<br>  mst.insert<span class="hljs-constructor">Tail(<span class="hljs-params">tmp</span>)</span>;<br>  neighbor<span class="hljs-literal">[<span class="hljs-identifier">v</span>]</span> = -<span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span>(Edge&lt;T&gt; e=first<span class="hljs-constructor">Edge(<span class="hljs-params">v</span>)</span>;<span class="hljs-constructor">IsEdge(<span class="hljs-params">e</span>)</span>;e=<span class="hljs-constructor">NextEdge(<span class="hljs-params">e</span>)</span>)&#123;<br>  <span class="hljs-built_in">int</span> u = e.<span class="hljs-keyword">end</span>;<br>  <span class="hljs-comment">//更新nearest和neighbor需要注意判断是否已加入mst 以及到目前该点的距离是不是需要更新成最短的</span><br>  <span class="hljs-keyword">if</span>(neighbor<span class="hljs-literal">[<span class="hljs-identifier">u</span>]</span>!=-<span class="hljs-number">1</span>&amp;&amp;nearest<span class="hljs-literal">[<span class="hljs-identifier">u</span>]</span>&gt;e.weight)&#123;<br>  neighbor<span class="hljs-literal">[<span class="hljs-identifier">u</span>]</span> = v;<br>  nearest<span class="hljs-literal">[<span class="hljs-identifier">u</span>]</span> = e.weight;<br>  &#125;<br>  &#125;<br>  &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><p><a href="https://www.prepbytes.com/blog/queues/prims-algorithm-using-priority_queue-in-stl/">priority queue实现</a></p></li><li><p><a href="https://www.geeksforgeeks.org/prims-algorithm-using-priority_queue-stl/">priority queue实现</a></p></li><li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191609619.png" alt="image-20221119105020849"></p></li></ul><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191609618.png" alt="image-20221119104837149"></li><li>使用priority queue可以提升到O(elogv)</li></ul><h2 id="kruskal"><a href="#kruskal" class="headerlink" title="kruskal"></a>kruskal</h2><ul><li><p>Kruskal: (build forest that will finish as a tree)</p><p>Pick lower cost edge not yet in a tree that does not create a cycle and expand to include it somewhere in the forest</p></li><li><p>Work with <strong>edges</strong>, rather than nodes</p></li><li><p>基于greedy思想</p></li></ul><h3 id="steps-1"><a href="#steps-1" class="headerlink" title="steps"></a>steps</h3><ul><li><p>Sort edges by increasing edge weight</p></li><li><p>Select the first |V| – 1 edges that do not generate a cycle</p></li><li><p>Initialize a forest of trees, each tree being a single nodeBuild a priority queue of edges with priority being lowest costRepeat until |V| -1 edges have been accepted {Delete min edge from priority queueIf it forms a cycle then discard it      else accept the edge – It will join 2 existing trees yielding a larger tree and reducing the forest by one tree}</p></li><li><p>The accepted edges form the minimum spanning tree</p><p>Every step will have joined two trees in the forest together, so that at the end, there will only be one tree</p></li></ul><h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><h4 id="UNION-x2F-FIND-algorithm"><a href="#UNION-x2F-FIND-algorithm" class="headerlink" title="UNION&#x2F;FIND algorithm"></a>UNION&#x2F;FIND algorithm</h4><ul><li><p><a href="https://book.huihoo.com/data-structures-and-algorithms-with-object-oriented-design-patterns-in-c++/html/page579.html">ref</a></p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191609955.png" alt="image-20221118221116048"></p></li><li><pre><code class="c++">class UFsets&#123;private:    int n;    int* root;    int* next;    int* length;public:    UFsets(int size)&#123;        n = size;        root = new int[n];        next = new int[n];        length = new int[n];        for(int i = 0;i&lt;n;i++)&#123;            root[i] = i;            next[i] = i;            length[i] = 1;        &#125;    &#125;    int UFsets::Find(int v)&#123;        if(v&lt;n)            return root[v];        else            return -1;    &#125;    void UFsets::Union(int v, int u)&#123;        if(root[u] == root[v])            return;        else if(length[v]&gt;length[u])&#123;            int uRoot = root[u];            length[v] = length[v]+length[u];            root[u] = root[v];            for(int uNext = next[uRoot];next[u]!=uRoot;uNext=next[uNext])&#123;                root[uNext] = root[v];        &#125;            next[u] = root[v];            next[v] = uRoot;        &#125;        else if(length[u]&gt;length[v])&#123;            int vRoot = root[v];            length[u] = length[u] + length[v];            root[v] = root[u];            for(int vNext = next[vRoot];next[vNext]!=vRoot;vNext=next[vNext])&#123;                root[vNext] = root[u];            &#125;            next[v] = root[u];            next[u] = vRoot;        &#125;    &#125;&#125;<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br>- ```c++<br>  <span class="hljs-built_in">bool</span> Graph&lt;T&gt;::<span class="hljs-constructor">Kruskal(LinkList&lt;Edge&lt;T&gt;&gt; &amp;<span class="hljs-params">mst</span>)</span>&#123;<br>  <span class="hljs-built_in">int</span> *vertexArray = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">vertexNum</span>]</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;vertexNum;i++)&#123;<br>  vertexArray<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = i;<br>  &#125;<br>  UFsets set(vertexNum);s<br>  MinHeap&lt;Edge&lt;T&gt;&gt; heap(edge<span class="hljs-constructor">Count()</span>);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i&lt;vertexNum;i++)&#123;<br>  <span class="hljs-keyword">for</span>(Edge&lt;T&gt; edge=first<span class="hljs-constructor">Edge(<span class="hljs-params">i</span>)</span>;<span class="hljs-constructor">IsEdge(<span class="hljs-params">edge</span>)</span>;edge = next<span class="hljs-constructor">Edge(<span class="hljs-params">edge</span>)</span>)&#123;<br>  <span class="hljs-keyword">if</span>(edge.start&lt;edge.<span class="hljs-keyword">end</span>)&#123;<br>  heap.<span class="hljs-constructor">Insert(<span class="hljs-params">edge</span>)</span>;<br>  &#125;<br>  &#125;<br>  &#125;<br>  <span class="hljs-built_in">int</span> mstEdgeNum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span>(!heap.<span class="hljs-constructor">IsEmpty()</span>)&#123;<br>  Edge&lt;T&gt; edge = heap.<span class="hljs-constructor">RemoveFirst()</span>;<br>  <span class="hljs-built_in">int</span> start = edge.start;<br>  <span class="hljs-built_in">int</span> <span class="hljs-keyword">end</span> = edge.<span class="hljs-keyword">end</span>;<br>  <span class="hljs-keyword">if</span>(set.<span class="hljs-constructor">Find(<span class="hljs-params">start</span>)</span>!=set.<span class="hljs-constructor">Find(<span class="hljs-params">end</span>)</span>)&#123;<br>  set.<span class="hljs-constructor">Union(<span class="hljs-params">start</span>,<span class="hljs-params">end</span>)</span>;<br>  mst.insert<span class="hljs-constructor">Tail(<span class="hljs-params">edge</span>)</span>;<br>  mstEdgeNum++;<br>  &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(mst.<span class="hljs-constructor">Count()</span><span class="hljs-operator"> == </span>edge<span class="hljs-constructor">Count()</span>-<span class="hljs-number">1</span>)<br>  return <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">else</span><br>  return <span class="hljs-literal">false</span>;<br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191609129.png" alt="image-20221119100816009"></p></li></ul><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191609307.png" alt="image-20221119104727507"></li></ul><h2 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a>总结对比</h2><p><a href="https://www.geeksforgeeks.org/difference-between-prims-and-kruskals-algorithm-for-mst/#:~:text=Prim's%20algorithm%20has%20a%20time,works%20only%20on%20connected%20graph.">ref</a></p><table><thead><tr><th align="left">Prim’s Algorithm</th><th align="left">Kruskal’s Algorithm</th></tr></thead><tbody><tr><td align="left">It starts to build the Minimum Spanning Tree from any vertex in the graph.</td><td align="left">It starts to build the Minimum Spanning Tree from the vertex carrying minimum weight in the graph.</td></tr><tr><td align="left">It traverses one node more than one time to get the minimum distance.</td><td align="left">It traverses one node only once.</td></tr><tr><td align="left">Prim’s algorithm has a time complexity of O(V2), V being the number of vertices and can be improved up to O(E log V) using Fibonacci heaps.</td><td align="left">Kruskal’s algorithm’s time complexity is O(E log V), V being the number of vertices.</td></tr><tr><td align="left">Prim’s algorithm gives connected component as well as it works only on connected graph.</td><td align="left">Kruskal’s algorithm can generate forest(disconnected components) at any instant as well as it can work on disconnected components</td></tr><tr><td align="left">Prim’s algorithm runs faster in dense graphs.</td><td align="left">Kruskal’s algorithm runs faster in sparse graphs.</td></tr><tr><td align="left">It generates the minimum spanning tree starting from the root vertex.</td><td align="left">It generates the minimum spanning tree starting from the least weighted edge.</td></tr><tr><td align="left">Applications of prim’s algorithm are Travelling Salesman Problem, Network for roads and Rail tracks connecting all the cities etc.</td><td align="left">Applications of Kruskal algorithm are LAN connection, TV Network etc.</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/11/19/02/"/>
    <url>/2022/11/19/02/</url>
    
    <content type="html"><![CDATA[<h1 id="Graph-Traversals"><a href="#Graph-Traversals" class="headerlink" title="Graph Traversals"></a>Graph Traversals</h1><p>A graph-traversal algorithm visits all vertices if and only if the graph is connected.</p><h2 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h2><h3 id="存储结构-邻接矩阵"><a href="#存储结构-邻接矩阵" class="headerlink" title="存储结构-邻接矩阵"></a>存储结构-邻接矩阵</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Edge</span>  <br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> from;<br><span class="hljs-type">int</span> to;<br><span class="hljs-type">int</span> weight;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Edge</span>();<br><span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> from,<span class="hljs-type">int</span> to,<span class="hljs-type">int</span> weight);<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Edge</span>();<br>&#125;;<br>Edge::<span class="hljs-built_in">Edge</span>()<br>&#123;<br>from=to=<span class="hljs-number">-1</span>;<br>weight=<span class="hljs-number">0</span>;<br>&#125;<br>Edge::<span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> from,<span class="hljs-type">int</span> to,<span class="hljs-type">int</span> weight)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;from=from;<br><span class="hljs-keyword">this</span>-&gt;to=to;<br><span class="hljs-keyword">this</span>-&gt;weight=weight;<br>&#125;<br>Edge::~<span class="hljs-built_in">Edge</span>()<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNVISITED 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VISITED 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;Edge.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">graph</span>  <br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> numvertex;<br><span class="hljs-type">int</span> numEdge;<br><span class="hljs-type">int</span> *mark;<br><span class="hljs-type">int</span> *indegree;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">graph</span>(<span class="hljs-type">int</span> numvertex);<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEdge</span><span class="hljs-params">(Edge oneEdge)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">tovertex</span><span class="hljs-params">(Edge oneEdge)</span></span>;<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">graph</span>();<br>&#125;;<br><span class="hljs-comment">//返回边的起始点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">graph::tovertex</span><span class="hljs-params">(Edge oneEdge)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> oneEdge.to;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">graphm</span> : <span class="hljs-keyword">public</span> graph  <br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> **martix;<br><span class="hljs-built_in">graphm</span>(<span class="hljs-type">int</span> numvertex);<br><span class="hljs-function">Edge <span class="hljs-title">firstEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> onevertex)</span></span>;<br><span class="hljs-function">Edge <span class="hljs-title">nextEdge</span><span class="hljs-params">(Edge oneEdge)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> from,<span class="hljs-type">int</span> to,<span class="hljs-type">int</span> weight)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(graphm g,<span class="hljs-type">int</span> v)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(graphm&amp; g,<span class="hljs-type">int</span> v)</span></span>;<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">graphm</span>();<br>&#125;;<br>graphm::<span class="hljs-built_in">graphm</span>(<span class="hljs-type">int</span> numvertex):<span class="hljs-built_in">graph</span>(numvertex)<br>&#123;<br>martix=(<span class="hljs-type">int</span> **) <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>*[numvertex];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;numvertex;i++)<br>martix[i]=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[numvertex];<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;numvertex;i++)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;numvertex;j++)<br>martix[i][j]=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//返回顶点onevertex的第一条边</span><br><span class="hljs-function">Edge <span class="hljs-title">graphm::firstEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> onevertex)</span></span><br><span class="hljs-function"></span>&#123;<br>Edge temp;<br>temp.from=onevertex;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;numvertex;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(martix[onevertex][i]!=<span class="hljs-number">0</span>)<br>&#123;<br>temp.to=i;<br>temp.weight=martix[onevertex][i];<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><span class="hljs-comment">//返回与边oneEdge有相同起始点的下一条边</span><br><span class="hljs-function">Edge <span class="hljs-title">graphm::nextEdge</span><span class="hljs-params">(Edge oneEdge)</span></span><br><span class="hljs-function"></span>&#123;<br>Edge temp;<br>temp.from=oneEdge.from;<br><span class="hljs-keyword">if</span>(oneEdge.to&lt;numvertex)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=oneEdge.to+<span class="hljs-number">1</span>;i&lt;numvertex;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(martix[oneEdge.from][i]!=<span class="hljs-number">0</span>)<br>&#123;<br>temp.to=i;<br>temp.weight=martix[oneEdge.from ][i];<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="存储结构-邻接表"><a href="#存储结构-邻接表" class="headerlink" title="存储结构-邻接表"></a>存储结构-邻接表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListGraph</span>: <span class="hljs-keyword">public</span> Graph&#123;<br><span class="hljs-keyword">private</span>:<br>    LinkList&lt;Edge&gt; * vertexList;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://linuxhint.com/adjacency-list-cpp/#:~:text=The%20adjacency%20list%20is%20a,to%20other%20nodes%20or%20vertices.&text=In%20the%20undirected%20graph%2C%20we%20can%20move%20to%20any%20vertex.">我看得懂的实现方法</a></p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191609507.png" alt="image-20221118185055836"></p><ul><li>解释为什么邻接表的大小是n+2m</li></ul><h3 id="pseudo-code"><a href="#pseudo-code" class="headerlink" title="pseudo code"></a>pseudo code</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void graph<span class="hljs-constructor">Traverse(Graph<span class="hljs-operator">*</span> G)</span>&#123;<br><span class="hljs-built_in">int</span> v;<br><span class="hljs-keyword">for</span>(v = <span class="hljs-number">0</span>; v&lt;G-&gt;n<span class="hljs-literal">()</span>; v++)<br>G-&gt;set<span class="hljs-constructor">Mark(<span class="hljs-params">v</span>,UNVISITED)</span>;<br><span class="hljs-keyword">for</span>(v = <span class="hljs-number">0</span>; v&lt;G-&gt;n<span class="hljs-literal">()</span>; v++)&#123;<br><span class="hljs-keyword">if</span>(G-&gt;get<span class="hljs-constructor">Mark(<span class="hljs-params">v</span>)</span>==UNVISITED)<br><span class="hljs-keyword">do</span><span class="hljs-constructor">Traverse(G,<span class="hljs-params">v</span>)</span>;<br>&#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><ul><li>proceeds along a path from v as deeply into the graph as possible before backing up. </li><li>The depth-first traversal algorithm does not completely specify the order in which it should visit the vertices adjacent to v.We may visit the vertices adjacent to v in sorted order.</li><li>类似二叉树的先序访问</li></ul><h3 id="steps"><a href="#steps" class="headerlink" title="steps"></a>steps</h3><ul><li>starting from vertex v.</li><li>Visit a vertex, then visit a vertex adjacent to that vertex v as deeply into the graph as possible before backing up</li><li>If there is no unvisited vertex adjacent to visited vertex, back up to the previous step.</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li><img src="https://ucc.alicdn.com/pic/developer-ecology/90f80e5f92d149b8b81f8c2e2fb8fd34.gif" alt="1.gif"></li><li><a href="https://zhuanlan.zhihu.com/p/110160308">ref:code</a></li></ul><h4 id="recursive"><a href="#recursive" class="headerlink" title="recursive"></a>recursive</h4><ul><li><p>pseudo code</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">DFS</span><span class="hljs-params">(G, u)</span></span><br>    u<span class="hljs-selector-class">.visited</span> = true<br>    <span class="hljs-keyword">for</span> each v ∈ G<span class="hljs-selector-class">.Adj</span><span class="hljs-selector-attr">[u]</span><br>        <span class="hljs-keyword">if</span> v<span class="hljs-selector-class">.visited</span> == false<br>            <span class="hljs-built_in">DFS</span>(G,v)<br>     <br><span class="hljs-function"><span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    For each u ∈ G<br>        u<span class="hljs-selector-class">.visited</span> = false<br>     For each u ∈ G<br>       <span class="hljs-built_in">DFS</span>(G, u)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>&#96;&#96;&#96;c++<br>void graphm::DFS(graphm&amp; gt,int v)<br>{<br>g.mark[v]&#x3D;VISITED;<br>visit(g,v);&#x2F;&#x2F;执行输出<br>for(Edge e&#x3D;g.firstEdge(v);g.isEdge(e);e&#x3D;g.nextEdge(e)){<br>    if(g.mark[g.tovertex(e)]&#x3D;&#x3D;Unvisit)<br>        DFS(g,g.tovertex(e));<br>}<br>}</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br>  <br><br>#### Use a stack <br><br>- ```c++<br>  void graphm::<span class="hljs-constructor">DFS(<span class="hljs-params">graphm</span>&amp; <span class="hljs-params">gt</span>,<span class="hljs-params">int</span> <span class="hljs-params">v</span>)</span><br>  &#123;<br>  stack&lt;<span class="hljs-built_in">int</span>&gt; st;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;numvertex;i++)&#123;<br>  mark<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>=UNVISITED;<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;numvertex;i++)&#123;<br>  <span class="hljs-keyword">if</span>(mark<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>==UNVISITED)&#123;<br>  st.push(i);<br>  <span class="hljs-keyword">while</span>(!st.empty<span class="hljs-literal">()</span>)&#123;<br>  <span class="hljs-built_in">int</span> v;<br>                    v=st.top<span class="hljs-literal">()</span>;<br>  st.pop(v);<br>  <span class="hljs-keyword">if</span>(mark<span class="hljs-literal">[<span class="hljs-identifier">v</span>]</span>==UNVISITED)<br>  visit(v);<br>  mark<span class="hljs-literal">[<span class="hljs-identifier">v</span>]</span>=visited;<br>  <span class="hljs-keyword">for</span>(Edge e = <span class="hljs-constructor">FirstEdge(<span class="hljs-params">v</span>)</span>;g.is<span class="hljs-constructor">Edge(<span class="hljs-params">e</span>)</span>;e=<span class="hljs-constructor">NextEdge(<span class="hljs-params">e</span>)</span>)&#123;<br>  <span class="hljs-keyword">if</span>(mark<span class="hljs-literal">[<span class="hljs-identifier">e</span>.<span class="hljs-identifier">to</span>]</span>==UNVISITED)<br>  st.push(e.<span class="hljs-keyword">to</span>);<br>  &#125;<br>  &#125;<br>  &#125; <br>  &#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211172321119.png" alt="image-20221117205138496"></p></li></ul><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li><p>DFS算法是一一个递归算法，需要借助一个递归工作栈，故它的空间复杂度为O(N)。<br>遍历图的过程实质上是对每个顶点查找其邻接点的过程，其耗费的时间取决于所采用结构。</p><p>邻接表表示时，查找所有顶点的邻接点所需时间为O(E)，访问顶点的邻接点所花时间为O(N),此时，总的时间复杂度为O(N+E)。</p><p>邻接矩阵表示时，查找每个顶点的邻接点所需时间为O(N)，要查找整个矩阵，故总的时间度为O(N^2)。<br><a href="https://www.geeksforgeeks.org/difference-between-bfs-and-dfs/">ref</a></p></li></ul><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><ul><li>DFS算法是一一个递归算法，需要借助一个递归工作栈，故它的空问复杂度为O(V）。</li></ul><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><ul><li>After visiting a given vertex v, the breadth-first traversal algorithm visits every vertex adjacent to v before visiting any other vertex.</li><li>The breath-first traversal algorithm does not completely specify the order in which it should visit the vertices adjacent to v.</li><li>It is similar to level traversal.</li></ul><h3 id="steps-1"><a href="#steps-1" class="headerlink" title="steps"></a>steps</h3><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><ul><li><a href="https://stackoverflow.com/questions/2549541/performing-breadth-first-search-recursively">trick-不能使用递归进行BFS queue与stack</a></li></ul><h4 id="use-queue"><a href="#use-queue" class="headerlink" title="use queue"></a>use queue</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">graphm::BFS</span><span class="hljs-params">(graphm&amp; gt,<span class="hljs-type">int</span> v)</span></span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;numvertex;i++)&#123;<br>mark[i]=UNVISITED;<br>&#125;<br>q.<span class="hljs-built_in">push</span>(v);<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> v;<br>        <span class="hljs-comment">// dequeue front node and print it</span><br>        v = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(mark[v]==UNVISITED)<br>        <span class="hljs-built_in">visite</span>(v);<br>        mark[v]=VISITED;<br>        <span class="hljs-keyword">for</span>(Edge e = <span class="hljs-built_in">FirstEdge</span>(v),<span class="hljs-built_in">IsEdge</span>(e);e=<span class="hljs-built_in">NextEdge</span>(e))&#123;<br>        <span class="hljs-keyword">if</span>(mark[e.to]==UNVISITED)<br>        q.<span class="hljs-built_in">push</span>(e.to);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="pseudo-code-1"><a href="#pseudo-code-1" class="headerlink" title="pseudo code"></a>pseudo code</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">bft</span>(in v:Vertex) &#123;<br><span class="hljs-comment">// Traverses a graph beginning at vertex v </span><br><span class="hljs-comment">// by using breath-first strategy: Iterative Version</span><br><span class="hljs-selector-tag">q</span><span class="hljs-selector-class">.createQueue</span>();<br><span class="hljs-comment">// add v to the queue and mark it</span><br><span class="hljs-selector-tag">q</span><span class="hljs-selector-class">.enqueue</span>(v);<br><span class="hljs-selector-tag">Mark</span> v as visited;<br>while (!q.isEmpty()) &#123;<br>   <span class="hljs-selector-tag">q</span><span class="hljs-selector-class">.dequeue</span>(w);<br>   for (each unvisited vertex u adjacent to w) &#123;<br>      <span class="hljs-selector-tag">Mark</span> u as visited;<br>      <span class="hljs-selector-tag">q</span><span class="hljs-selector-class">.enqueue</span>(u);<br>   &#125;   <br>&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li><p><a href="https://so.csdn.net/so/search?q=%E9%82%BB%E6%8E%A5%E8%A1%A8&spm=1001.2101.3001.7020">邻接表</a>形式存储时，每个顶点均需搜索一次，时间复杂度T1&#x3D;O（v），从一个顶点开始搜索时，开始搜索，访问未被访问过的节点。最坏的情况下，每个顶点至少访问一次，每条边至少访问1次，这是因为在搜索的过程中，若某结点向下搜索时，其子结点都访问过了，这时候就会回退，故时间复 杂度为O(E)，算法总的时间复 度为O(|V|+|E|)。</p><p><a href="https://so.csdn.net/so/search?q=%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5&spm=1001.2101.3001.7020">邻接矩阵</a>存储方式时，查找每个顶点的邻接点所需时间为O(V)，即该节点所在的该行该列。又有n个顶点，故算总的时间复杂度为O(|V|^2)。</p></li><li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211172322430.png" alt="image-20221117211701421"></p><p><a href="https://stackoverflow.com/questions/11468621/why-is-the-time-complexity-of-both-dfs-and-bfs-o-v-e">ref</a></p></li></ul><h4 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><ul><li>BFS是一种借用<a href="https://so.csdn.net/so/search?q=%E9%98%9F%E5%88%97&spm=1001.2101.3001.7020">队列</a>来存储的过程，分层查找，优先考虑距离出发点近的点。无论是在邻接表还是邻接矩阵中存储，都需要借助一个辅助队列，v个顶点均需入队，最坏的情况下，空间复杂度为O（v）。</li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><a href="https://www.geeksforgeeks.org/difference-between-bfs-and-dfs/">ref</a></p><table><thead><tr><th align="left">14.</th><th align="left">Memory</th><th align="left">BFS requires more memory.</th><th align="left">DFS requires less memory.</th></tr></thead><tbody><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><table><thead><tr><th align="left">17.</th><th align="left">Speed</th><th align="left">BFS is slow as compared to DFS.</th><th align="left">DFS is fast as compared to BFS.</th></tr></thead><tbody><tr><td align="left">18.</td><td align="left">When to use?</td><td align="left">When the target is close to the source, BFS performs better.</td><td align="left">When the target is far from the source, DFS is preferable.</td></tr></tbody></table><ul><li>注意空间复杂度需要考虑原本图的类内成员存储结点和边（如果是邻接矩阵n^2 如果是邻接表n+2m)</li></ul><h2 id="树的遍历使用BFS-DFS"><a href="#树的遍历使用BFS-DFS" class="headerlink" title="树的遍历使用BFS DFS"></a>树的遍历使用BFS DFS</h2><p><a href="https://blog.csdn.net/mengmengdajuanjuan/article/details/84313361">reference</a></p><p>中序遍历：按照从小到大</p><p>kruskal 算法</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/11/19/01/"/>
    <url>/2022/11/19/01/</url>
    
    <content type="html"><![CDATA[<h1 id="graph"><a href="#graph" class="headerlink" title="graph"></a>graph</h1><h2 id="basics概念"><a href="#basics概念" class="headerlink" title="basics概念"></a>basics概念</h2><ul><li><p>弧：指的是<strong>有向图</strong>里面的<strong>边，</strong>他是有明确方向的。如果是无向图的边，直接叫做“边”。比如有向图的 v1 结点到 v2 结点的弧可能是：&lt;v1, v2&gt;；</p></li><li><p>路径：指的是图（包括有向图和无向图）里面连接两个结点之间的边的集合，也就是一个顶点序列。比如：v1 到 v3 的路径可能这样表示：&lt;v1, v2&gt;、&lt;v2, v3&gt;；</p></li><li><p>如果是有向图，那么路径里面是用弧来组成。如果是无向图，路径是用边来组成。</p></li><li><p>edge&#x3D;arc</p></li><li><p>vertex(pl: vertices) &#x3D;node</p></li><li><p>degree: The degree of a vertex is the number of edges incident to it. </p></li><li><p>path: A path in a graph is a sequence of vertices connected by edges. </p><p>​ A sequence of vertices v1,v2,. . .vk  such that consecutive vertices vi and vi+1 are adjacent.</p></li><li><p>simple path:  no repeated vertices</p></li><li><p>cycle: simple path, except that the last vertex is the same as the first vertex</p></li><li><p>simple cycle</p></li></ul><h4 id="无向图-undirected-graph"><a href="#无向图-undirected-graph" class="headerlink" title="无向图 undirected graph"></a><strong>无向图 undirected graph</strong></h4><ul><li>(v1,v2)</li><li>边数推导 &lt;&#x3D; n*(n-1)&#x2F;2</li><li>degree: The degree of vertex i is the number of edges incident on vertex i.</li><li>Sum of degrees &#x3D; 2e where e is the number of edges</li></ul><h4 id="有向图-directed-graph"><a href="#有向图-directed-graph" class="headerlink" title="有向图 directed graph"></a><strong>有向图 directed graph</strong></h4><ul><li>&lt;v1,v2&gt;</li><li>边数推导 &lt;&#x3D; n*(n-1)</li><li>in degree: In-degree of vertex i is the number of edges incident to i (i.e., the number of incoming edges).</li><li>out degree: Out-degree of vertex i is the number of edges incident from i  (i.e., the number of outgoing edges).</li><li>Sum of in-degrees &#x3D; sum of out-degrees &#x3D; e,where e is the number of edges in the digraph.</li></ul><h4 id="connected-graph"><a href="#connected-graph" class="headerlink" title="connected graph"></a>connected graph</h4><ul><li>A Connected graph has only one connected component.</li><li>Connected graph: G is connected iff there is a path between every pair of vertices in G</li><li>Subgraph: A subgraph S is formed from graph G by selecting a subset V of G’s vertices and a subset E of G’s edges such that for every edge e in E, both of e’s  vertices are in V. </li><li>Connected component: the maximally connected subgraphs of an undirected graph.</li></ul><h4 id="spanning-tree"><a href="#spanning-tree" class="headerlink" title="spanning tree"></a>spanning tree</h4><ul><li><p>acyclic graph: graph without circles</p></li><li><p>A tree is an acyclic connected graph.</p></li><li><p>A disjoint set of trees is called a forest. </p></li><li><p>A spanning tree of a connected graph is a subgraph that contains all of that graph’s vertices and is a single tree. </p></li><li><p>A spanning forest of a graph is the union of spanning trees of its connected components.</p></li><li><p>A graph is a tree if it is connected and there is a unique path between any two vertices</p><p><strong>The number of edges is |E| &#x3D; |V| – 1</strong> </p><p><strong>A spanning tree for a connected graph is not unique.</strong></p><p>The graph is acyclic, that is, it does not contain any cycles</p><p>Adding one more edge must create a cycle</p><p>Removing any one edge creates two disjoint non-empty sub-graphs</p></li></ul><h3 id="表示图的方法"><a href="#表示图的方法" class="headerlink" title="表示图的方法"></a>表示图的方法</h3><ul><li>Binary-relation list Adjacency matrix Adjacency list</li><li>adjacency matrix<ul><li>对于undirected graph只需要存储一个upper三角形或者lower三角形n*(n-1)&#x2F;2</li></ul></li><li>adjacency list<ul><li>most efficient</li></ul></li><li>orthogonal list</li></ul><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>space</li><li></li></ul><h2 id="theorem"><a href="#theorem" class="headerlink" title="theorem"></a>theorem</h2><p>- </p><ul><li><p>无向图或有向图中所有结点的度数之和&#x3D;边数的两倍</p><ul><li>每条边贡献两个度</li></ul></li><li><p>无向图或有向图中 度数为奇数的结点个数为偶数</p><ul><li><img src="https://img-blog.csdnimg.cn/20191229113456512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RlYW1fc3dhbl9nb29zZQ==,size_16,color_FFFFFF,t_70" alt="img"></li></ul></li><li><p><img src="https://img-blog.csdnimg.cn/20191229150529228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RlYW1fc3dhbl9nb29zZQ==,size_16,color_FFFFFF,t_70" alt="img"></p></li><li><p><strong>完全图一定属于连通图, 而连通图不一定属于完全图</strong></p><p>完全图要求任意一对顶点间均有边连接，而连通图只要求任意顶点间连通即有路径即可，并不一定有边连接这两顶点！</p></li></ul><h2 id="mooc"><a href="#mooc" class="headerlink" title="mooc"></a>mooc</h2><ul><li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191610155.png" alt="image-20220908130814983"></p></li><li><p>无向的连通图就是或者有向的强连通图通过任意一个顶点都能够（直接或者通过其他顶点间接地）访问到其他所有顶点,自然一次深度优先遍历就可以访问到所有顶点<br>无向非连通图一次遍历只能访问到起点所在的连通分量,一个非连通无向图中有几个连通分量就需要从各个分量分别开始遍历才能访问到所有的顶点<br>有向的非强连通图则需要看起点如何,可能有些起点可以访问到其他顶点,可能有些不能</p></li><li><p>简单回路：除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路</p><p>回路：第一个顶点和最后一个顶点相同的路径</p><p>简单路径：顶点不重复出现的路径</p><p>路径：由顶点和相邻路径序列构成的边的序列</p><p>简单路径限制了顶点不能重复出现，简单回路限制了除了第一个顶点和最后一个顶点外的其余顶点不能重复出现</p></li><li><p>首先，不是所有的有向图都是有拓扑序的，只有 有向无环图 才有拓扑序，所以 有向无环图又被称为拓扑图 。</p></li><li><p>在n个结点的无向图中，若该图是连通图,则其边数大于等于n-1，<br>在n个结点的无向图中，若边数大于(n-2)(n-1)&#x2F;2，则该图必是连通图</p></li><li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191610329.png" alt="image-20220909183524489"></p></li><li><p>出和入2* 剩下n-1个点 2*(n-1)</p></li><li><p>对图中任意顶点u,v,都存在路径使u、v连通。由于是无向图故为n-1，若是有向图为n</p></li><li></li><li><p><a href="https://zhidao.baidu.com/question/206530163.html">有n个顶点的强连通图最多有多少条边,最少有多少条边_百度知道 (baidu.com)</a></p></li><li><p><a href="https://www.nowcoder.com/questionTerminal/92e10613145b4ee0a25f2d6b8699a81c">下列关于无向连通图特性的叙述中，正确的是 Ⅰ.所有顶点的度_阿里巴巴笔试题_牛客网 (nowcoder.com)</a></p></li></ul><ol><li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191610434.png" alt="image-20220909192641993" style="zoom:50%;" /><p><a href="https://blog.csdn.net/Deam_swan_goose/article/details/103751863">reference</a></p></li><li><p>n个顶点，最多的情况是每两个点有一条边，所以用Cn2，结果是n(n-1)&#x2F;2</p><p><a href="https://www.nowcoder.com/questionTerminal/853066cc75dd4e7a8ac3529e39db418f">reference</a></p></li><li><p>()</p></li><li><p>无向的连通图就是或者有向的强连通图通过任意一个顶点都能够（直接或者通过其他顶点间接地）访问到其他所有顶点,自然一次深度优先遍历就可以访问到所有顶点<br>无向非连通图一次遍历只能访问到起点所在的连通分量,一个非连通无向图中有几个连通分量就需要从各个分量分别开始遍历才能访问到所有的顶点<br>有向的非强连通图则需要看起点如何,可能有些起点可以访问到其他顶点,可能有些不能</p></li><li><p>简单回路：除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路</p><p>回路：第一个顶点和最后一个顶点相同的路径</p><p>简单路径：顶点不重复出现的路径</p><p>路径：由顶点和相邻路径序列构成的边的序列</p><p>简单路径限制了顶点不能重复出现，简单回路限制了除了第一个顶点和最后一个顶点外的其余顶点不能重复出现</p><p>首先，不是所有的有向图都是有拓扑序的，只有 <strong>有向无环图 才有拓扑序</strong>，所以 有向无环图又被称为拓扑图 。</p></li><li><p><a href="https://www.nowcoder.com/questionTerminal/92e10613145b4ee0a25f2d6b8699a81c">下列关于无向连通图特性的叙述中，正确的是 Ⅰ.所有顶点的度_阿里巴巴笔试题_牛客网 (nowcoder.com)</a></p><p>  答案：A </p><p>  1，每条边连接两个顶点，所有顶点的度之和等于边数的2倍，是偶数，正确 </p><p>  2，如两个顶点一条边的图就不满足这个条件，错 </p><p>  3，如三个顶点三条边连成一个三角形的图每个顶点度为2，错 </p></li><li><p>强连通有向图的任何顶点到其他所有顶点都有路径但未必有弧 无向图任意顶点入度&#x3D;出度 有向图不一定</p><p>有向图边集的子集和顶点集的子集无法构成子图</p><p>有向完全图一定是强连通有向图</p></li><li><p><a href="https://www.nowcoder.com/questionTerminal/1966baf847db4f66900f0bed40f5f905">reference</a></p></li><li><p><a href="https://www.nowcoder.com/questionTerminal/af3696696d694fc288a5bf639e5342ae?source=relative">无向图G有23条边，度为4的顶点有5个，度为3的顶点有4个，__牛客网 (nowcoder.com)</a></p></li></ol><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191610747.png" alt="image-20220909194949393"></p><ol><li><a href="https://www.nowcoder.com/questionTerminal/545dbf92b60c4e209fc8e8b4e441bb9a">reference</a></li><li><a href="https://www.jianshu.com/p/f174c97e626b">reference1</a></li></ol><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191610107.png" alt="image-20220909200405207"></p><p>- </p><p>邻接表：只存储实际存在的信息</p><p>邻接矩阵：潜在的边也需要存 但是不用指针的开销</p><p>图的边很多 dense图 密集图 需要选邻接矩阵</p><p>系数图（sparse） 选择邻接表</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/11/19/06/"/>
    <url>/2022/11/19/06/</url>
    
    <content type="html"><![CDATA[<h1 id="Shortest-Path-Problem"><a href="#Shortest-Path-Problem" class="headerlink" title="Shortest Path Problem"></a>Shortest Path Problem</h1><h2 id="Dijkstra’s-Algorithm"><a href="#Dijkstra’s-Algorithm" class="headerlink" title="Dijkstra’s Algorithm"></a>Dijkstra’s Algorithm</h2><h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><ul><li><p>单源最短路径：求s到图中各顶带你的最短路径</p></li><li><p>relaxation：</p><p>Dijkstra’s and <a href="https://www.baeldung.com/cs/bellman-ford">Bellmann Ford’s</a> algorithm use a technique called edge relaxation. This means that during traversing our graph and finding our shortest path, we update the paths we have for already known nodes as soon as we find a shorter path to reach it.</p></li></ul><h4 id="if-weights-of-all-edges-are-the-same"><a href="#if-weights-of-all-edges-are-the-same" class="headerlink" title="if weights of all edges are the same"></a>if weights of all edges are the same</h4><ul><li>Breadth-first search can be used to solve the single-source shortest path problem. Indeed, the tree rooted at s in the BFS tree is the solution</li></ul><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><ul><li><p>&#96;&#96;&#96;<br>int map[1005][1005];<br>int vis[1005],dis[1005];<br>int n,m;&#x2F;&#x2F;n个点，m条边<br>void Init ()<br>{<br>memset(map,Inf,sizeof(map));<br>for(int i&#x3D;1;i&lt;&#x3D;n;i++)<br>{<br>    map[i][i]&#x3D;0;<br>}<br>}<br>void Getmap()<br>{<br>int u,v,w;<br>for(int t&#x3D;1;t&lt;&#x3D;m;t++)<br>{<br>      scanf(“%d%d%d”,&amp;u,&amp;v,&amp;w);<br>      if(map[u][v]&gt;w)<br>      {<br>      map[u][v]&#x3D;w;<br>      map[v][u]&#x3D;w;<br>      }<br>}<br>}<br>void Dijkstra(int u)<br>{<br>memset(vis,0,sizeof(vis));<br>for(int t&#x3D;1;t&lt;&#x3D;n;t++)<br>{<br>    dis[t]&#x3D;map[u][t];<br>}<br>vis[u]&#x3D;1;<br>for(int t&#x3D;1;t&lt;n;t++)<br>{<br>    int minn&#x3D;Inf,temp;<br>    for(int i&#x3D;1;i&lt;&#x3D;n;i++)<br>    {<br>        if(!vis[i]&amp;&amp;dis[i]&lt;minn)<br>        {<br>            minn&#x3D;dis[i];<br>            temp&#x3D;i;<br>        }<br>    }<br>    vis[temp]&#x3D;1;<br>    for(int i&#x3D;1;i&lt;&#x3D;n;i++)<br>    {<br>        if(map[temp][i]+dis[temp]&lt;dis[i])<br>        {<br>            dis[i]&#x3D;map[temp][i]+dis[temp];<br>        }<br>    }<br>}<br>}</p><p>int main()<br>{<br>scanf(“%d%d”,&amp;m,&amp;n);<br>Init();<br>Getmap();<br>Dijkstra(n);<br>printf(“%d\n”,dis[1]);<br>return 0;<br>}</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>  [ref](https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/lbperfect123/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">84281300</span>)<br><br><span class="hljs-comment">### 复杂度分析</span><br><br>- use a brute-force algorithm and spend 𝑂(|𝑉|) to look at all edges 𝑒=(𝑢,𝑣) (𝑢∈𝑆 and 𝑣∈𝑆′) <span class="hljs-keyword">for</span> finding the minimum one, which takes 𝑂(|𝑉|^<span class="hljs-number">2</span>) (because each time you are looking at the same edge that are not <span class="hljs-keyword">in</span> the shortest path).<br>- use a min-heap and spend 𝑂(log|𝑉|)<span class="hljs-keyword">for</span> finding that edge, and achieve 𝑂((|𝑉|+|𝐸|)⋅log|𝑉|) overall running time.<br><br><span class="hljs-comment">## Floyd&#x27;s algorithm</span><br><br><span class="hljs-comment">### 适用范围</span><br><br>- 顶点对之间的最短路径问题：任意顶点对&lt;vi,vj&gt;之间最短路径<br>- 动态规划 自底向上<br><br><span class="hljs-comment">### steps</span><br><br>- [速通推导](https:<span class="hljs-regexp">//</span>www.youtube.com/watch?v=oNI0rf2P9gE)<br>  - ![image-<span class="hljs-number">20221119141335481</span>](https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/pinkyrie/</span>pic<span class="hljs-regexp">/main/</span><span class="hljs-number">202211191608177</span>.png)<br><br>- ![image-<span class="hljs-number">20221119142345476</span>](https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/pinkyrie/</span>pic<span class="hljs-regexp">/main/</span><span class="hljs-number">202211191608587</span>.png)<br>- Floyd 算法是一个基于「贪心」、「动态规划」求一个图中 **所有点到所有点** 最短路径的算法，时间复杂度 O(n3)<br>- 从任意节点i到任意节点j的最短路径不外乎<span class="hljs-number">2</span>种可能，<span class="hljs-number">1</span>是直接从i到j，<span class="hljs-number">2</span>是从i经过若干个节点k到j。所以，我们假设Dis(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，我们检查Dis(i,k) + Dis(k,j) &lt; Dis(i,j)是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，我们便设置Dis(i,j) = Dis(i,k) + Dis(k,j)，这样一来，当我们遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。![image-<span class="hljs-number">20221119135257709</span>](https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/pinkyrie/</span>pic<span class="hljs-regexp">/main/</span><span class="hljs-number">202211191608516</span>.png)<br><br><span class="hljs-comment">### code</span><br><br>- ![image-<span class="hljs-number">20221119143235934</span>](https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/pinkyrie/</span>pic<span class="hljs-regexp">/main/</span><span class="hljs-number">202211191608786</span>.png)<br><br></code></pre></td></tr></table></figure></li></ul><p>for(int k&#x3D;0;k&lt;n;k++){<br>    for(int i&#x3D;0;i&lt;n;i++){<br>        for(int j&#x3D;0;j&lt;n;j++){<br>            A[i,j] &#x3D; min{A[i,j],A[i,k]+A[k,j]}; &#x2F;&#x2F;内层的两次for循环是对上一个k-1矩阵进行整个矩阵的更新 因此最外层共有k次据则矩阵的更新<br>        }<br>    }<br>}</p><p>&#96;&#96;&#96;</p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191609458.png" alt="image-20221119141125140"></p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191609098.png" alt="image-20221119141229306"></p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191609529.png" alt="image-20221119142814197"></p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>Time Complexity: O(V3) where V is the number of vertices</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/11/16/13/"/>
    <url>/2022/11/16/13/</url>
    
    <content type="html"><![CDATA[<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><ul><li>A hash function maps key values to positions.</li></ul><h3 id="basics"><a href="#basics" class="headerlink" title="basics"></a>basics</h3><ul><li>Load factor lambda λ&#x3D; (number of keys &#x2F; Table Size)</li><li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211162323021.png" alt="image-20221113220132476"></li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><h4 id="folding"><a href="#folding" class="headerlink" title="folding"></a>folding</h4><ul><li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211162323599.png" alt="image-20221113223514997"></li></ul><h2 id="开放定址法（不使用链表-也叫闭散列法）"><a href="#开放定址法（不使用链表-也叫闭散列法）" class="headerlink" title="开放定址法（不使用链表 也叫闭散列法）"></a>开放定址法（不使用链表 也叫闭散列法）</h2><ul><li>包括</li><li>线性探查法</li><li>二次探查法</li><li>伪随机探查法</li><li>二次散列法</li></ul><h2 id="linear-probing"><a href="#linear-probing" class="headerlink" title="linear probing"></a>linear probing</h2><h3 id="unsuccessful-ASL"><a href="#unsuccessful-ASL" class="headerlink" title="unsuccessful ASL"></a>unsuccessful ASL</h3><ul><li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211162323273.png" alt="image-20221027112336074"></li><li><a href="https://blog.csdn.net/calculate23/article/details/100577469">ref</a></li></ul><h3 id="primary-clustering"><a href="#primary-clustering" class="headerlink" title="primary clustering"></a>primary clustering</h3><ul><li><p><a href="https://stackoverflow.com/questions/27742285/what-is-primary-and-secondary-clustering-in-hash">ref</a></p></li><li><p>In computer programming, primary clustering is one of two major failure modes of open addressing based hash tables, especially those using linear probing. It occurs after a hash collision causes two of the records in the hash table to hash to the same position, and causes one of the records to be moved to the next location in its probe sequence. Once this happens, the cluster formed by this pair of records is more likely to grow by the addition of even more colliding records, regardless of whether the new records hash to the same location as the first two. This phenomenon causes searches for keys within the cluster to be longer.[1]</p><p>For instance, in linear probing, a record involved in a collision is always moved to the next available hash table cell subsequent to the position given by its hash function, creating a contiguous cluster of occupied hash table cells. Whenever another record is hashed to anywhere within the cluster, it grows in size by one cell. Because of this phenomenon, it is likely that a linear-probing hash table with a constant load factor (that is, with the size of the table proportional to the </p><p><a href="https://en.wikipedia.org/wiki/Primary_clustering">ref</a></p></li></ul><h2 id="quadratic-probing"><a href="#quadratic-probing" class="headerlink" title="quadratic probing"></a>quadratic probing</h2><ul><li>插入新元素：查找一次插入不成功 则i++ 而且要从最初的插入点开始+i^2 而不是上一次的插入点</li><li>解决了一次聚集</li><li>产生二次聚集</li></ul><p>奇怪的理论：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">If</span> the <span class="hljs-keyword">table</span> size <span class="hljs-keyword">is</span> prime <span class="hljs-keyword">and</span> <span class="hljs-keyword">load</span> factor <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> larger than <span class="hljs-number">0.5</span>, <span class="hljs-keyword">all</span> probes will be <span class="hljs-keyword">to</span> different locations <span class="hljs-keyword">and</span> an item can <span class="hljs-keyword">always</span> be inserted.<br>==<br><span class="hljs-keyword">If</span> quadratic probing <span class="hljs-keyword">is</span> used, <span class="hljs-keyword">and</span> the <span class="hljs-keyword">table</span> size <span class="hljs-keyword">is</span> prime, <span class="hljs-keyword">then</span> a <span class="hljs-built_in">new</span> element can <span class="hljs-keyword">always</span> be inserted <span class="hljs-keyword">if</span> the <span class="hljs-keyword">table</span> <span class="hljs-keyword">is</span> at least half empty.<br></code></pre></td></tr></table></figure><h2 id="伪随机探查法"><a href="#伪随机探查法" class="headerlink" title="伪随机探查法"></a>伪随机探查法</h2><ul><li>解决二次聚集</li><li>但是</li></ul><h2 id="double-hashing"><a href="#double-hashing" class="headerlink" title="double hashing"></a>double hashing</h2><ul><li>Techniques that eliminate secondary clustering are available. The most popular is <strong>double hashing.</strong></li><li><a href="https://www.geeksforgeeks.org/double-hashing/">Double Hashing - GeeksforGeeks</a></li></ul><h2 id="链接法-x2F-开散列法-x2F-拉链法"><a href="#链接法-x2F-开散列法-x2F-拉链法" class="headerlink" title="链接法&#x2F;开散列法&#x2F;拉链法"></a>链接法&#x2F;开散列法&#x2F;拉链法</h2><ul><li>不会出现冲突的聚集情况</li><li>如果散列表储存在内存中 链接法容易实现</li><li>如果散列表再磁盘中 一个同义词的链表可能存储在不同的磁盘块 导致查询一个特定记录时多次访问磁盘 增加查找时间</li><li></li></ul><h2 id="桶定址法"><a href="#桶定址法" class="headerlink" title="桶定址法"></a>桶定址法</h2><ul><li>每个槽位不一定放一个元素 可以放多个（类似于拉链）</li><li>但是一个槽位满了就线性探查（或开放寻址）</li><li>会有冲突聚集</li></ul><p>装填因子决定平均查找长度（不是存储的记录个数或散列长度）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> key_type, <span class="hljs-keyword">typename</span> hash_func, <span class="hljs-keyword">typename</span> key_equal&gt;<br><span class="hljs-type">bool</span> HashSet&lt;key_type, hash_func, key_equal&gt;::<span class="hljs-built_in">search</span>(<span class="hljs-type">const</span> key_type&amp; k) &#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> pos = <span class="hljs-built_in">hf</span>(k) % prime_list[prime];<br>    <span class="hljs-keyword">while</span> ((*ht)[pos].used == <span class="hljs-number">1</span> &amp;&amp; (*ht)[pos].key != k) &#123;<br>        pos = <span class="hljs-built_in">probe</span>(k, ++i);<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((*ht)[pos].used == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br><br>    <span class="hljs-comment">//TODO</span><br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> key_type, <span class="hljs-keyword">typename</span> hash_func, <span class="hljs-keyword">typename</span> key_equal&gt;<br><span class="hljs-type">void</span> HashSet&lt;key_type, hash_func, key_equal&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">const</span> key_type&amp; k) &#123;<br>    <span class="hljs-type">int</span> pos = <span class="hljs-built_in">hf</span>(k) % prime_list[prime];<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> ((*ht)[pos].used == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">eq</span>((*ht)[pos].key, k)) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        pos = <span class="hljs-built_in">probe</span>(k, ++i);<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((*ht)[pos].used == <span class="hljs-number">1</span>) &#123;<br>        (*ht)[pos] = <span class="hljs-built_in">Entry</span>();<br>        entries--;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;No element found in set&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//TODO</span><br><br>&#125;<br><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> key_type, <span class="hljs-keyword">typename</span> hash_func, <span class="hljs-keyword">typename</span> key_equal&gt;<br><span class="hljs-type">void</span> HashSet&lt;key_type, hash_func, key_equal&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">const</span> key_type&amp; k) &#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> pos = <span class="hljs-built_in">hf</span>(k) % prime_list[prime];<br>    Entry item&#123; k,<span class="hljs-number">1</span> &#125;;<br><br> <span class="hljs-comment">/*   if (entries != 0 &amp;&amp; entries &gt; prime_list[prime] * load_factor) &#123;</span><br><span class="hljs-comment">        resize();</span><br><span class="hljs-comment">    &#125;*/</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">load_factor</span>() &gt; <span class="hljs-number">0.75</span>) &#123;<br>        <span class="hljs-built_in">resize</span>(); <span class="hljs-comment">// emmm</span><br>    &#125;<br>    <span class="hljs-keyword">while</span> ((*ht)[pos].used == <span class="hljs-number">1</span> &amp;&amp; !<span class="hljs-built_in">eq</span>((*ht)[pos].key,k)) &#123;<br>        pos = <span class="hljs-built_in">probe</span>(k, ++i);<br>    &#125;<br>    (*ht)[pos] = item;<br>    entries++;<br><br>    <span class="hljs-comment">//TODO</span><br><br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> key_type, <span class="hljs-keyword">typename</span> hash_func, <span class="hljs-keyword">typename</span> key_equal&gt;<br><span class="hljs-type">int</span> HashSet&lt;key_type, hash_func, key_equal&gt;::<span class="hljs-built_in">resize</span>() &#123;<br><br>    <span class="hljs-keyword">if</span> (prime == num_primes - <span class="hljs-number">1</span>) &#123;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;maximal table size reached, aborting ... &quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> mm = prime_list[prime];<br>    prime++;<br>    <span class="hljs-type">int</span> m = prime_list[prime];<br>    vector&lt;Entry&gt;* ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt;Entry&gt;(m);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; mm; ++i) &#123;<br><br>        <span class="hljs-keyword">if</span> ((*ht)[i].used == <span class="hljs-number">1</span>) &#123;<br>            key_type kk = (*ht)[i].key;<br><br>            <span class="hljs-type">int</span> p = <span class="hljs-built_in">hf</span>(kk) % m; <span class="hljs-comment">//Ê¹ÓÃhash_func</span><br><br>            <span class="hljs-keyword">while</span> (p &lt; m &amp;&amp; (*ptr)[p].used == <span class="hljs-number">1</span>) &#123;<br>                p++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (p == m) &#123;<br>                p = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> ((*ptr)[p].used == <span class="hljs-number">1</span>) &#123;<br>                p++;<br>            &#125;<br><br>            (*ptr)[p].key = kk;<br>            (*ptr)[p].used = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">delete</span> ht;<br>    ht = ptr;<br>    <span class="hljs-keyword">return</span> m;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/11/16/12/"/>
    <url>/2022/11/16/12/</url>
    
    <content type="html"><![CDATA[<h2 id="sequential-search"><a href="#sequential-search" class="headerlink" title="sequential search"></a>sequential search</h2><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211192214030.png" alt="image-20221119221445097"></p><h2 id="binary-search"><a href="#binary-search" class="headerlink" title="binary search"></a>binary search</h2><h3 id="binary-search-tree（区分我们要学的判定树）"><a href="#binary-search-tree（区分我们要学的判定树）" class="headerlink" title="binary search tree（区分我们要学的判定树）"></a>binary search tree（区分我们要学的判定树）</h3><ul><li><p>[树的高度](<a href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree">Self-balancing binary search tree - Wikipedia</a>)</p></li><li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211162324256.png" alt="image-20221114205329151"></p></li><li><p>Binary Search Tree is a node-based binary tree data structure which has the following properties:</p><p>The left subtree of a node contains only nodes with keys lesser than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>The left and right subtree each must also be a binary search tree.</p></li><li><p><a href="https://www.cs.usfca.edu/~galles/visualization/BST.html">构建过程的动画</a></p></li></ul><h3 id="折半查找判定树"><a href="#折半查找判定树" class="headerlink" title="折半查找判定树"></a>折半查找判定树</h3><ul><li><img src="/assets/image-20221119222033400.png" alt="image-20221119222033400"></li></ul><p><a href="https://www.cnblogs.com/zipeilu/p/14626027.html">计算ASL</a></p><ul><li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211192218737.png" alt="image-20221119221824327"></p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211192218415.png" alt="image-20221119221854558"></p></li></ul><h2 id="B-tree-x2F-多分树"><a href="#B-tree-x2F-多分树" class="headerlink" title="B-tree&#x2F;多分树"></a>B-tree&#x2F;多分树</h2><h3 id="basics"><a href="#basics" class="headerlink" title="basics"></a>basics</h3><ul><li><p>balanced search tree</p></li><li><p>用途：disks or other direct access secondary storage devices (和红黑树相似 但是better at minimizing disk I&#x2F;O operations)</p><p>many database systems use B-trees or B树的变种 store information</p></li><li><p>如果一个node x有 n 个keys 那么 node x有n+1个children</p></li><li><p>the keys in node x serve as dividing points separating the range of keys handled by x into x.n+1 subranges, each handled by one child of x</p></li><li><p>树的高度是随着结点个数logarithmatically grow</p></li></ul><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li>所有叶子结点出现在同一层</li><li>m阶的B树每个结点至多有m棵子树（All non-leaf nodes (except the root) have at most m and at least m&#x2F;2 children.）</li><li>key的个数比该结点的孩子个数少1（隔板比分割区域少1）</li><li>根结点至少有两棵子树</li></ul><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><h4 id="order-vs-degree"><a href="#order-vs-degree" class="headerlink" title="order vs degree"></a>order vs degree</h4><p>Degree represents the lower bound on the number of children. i.e the minimum number possible. Whereas the Order represents the upper bound on the number of children.</p><ul><li><p>minimum degree: </p><ul><li><p>Nodes have lower and upper bounds on the number of keys they can contain. We express these bounds in terms of a fixed integer t &gt;&#x3D;2 called the <strong>minimum degree</strong> of the B-tree:</p><p>a. Every node other than the root must have at least t -1 keys. Every internal node other than the root thus has at least t children. If the tree is nonempty, the root must have at least one key.</p><p>b. Every node may contain at most 2t-1 keys. Therefore, an internal node may have at most 2t children. We say that a node is <strong>full</strong> if it contains exactly 2t -1 keys.</p></li></ul></li><li><p>t度的B树就是2t阶的B树 (这也是B树的分裂机制决定的)</p><p>因为t度的B树节点最多有2t个孩子，2t-1个关键字；m阶的B树最多有m个孩子，其实通过度定义的B树和通过阶数定义的B树，区别就是一个是用的这个B树节点的最小度数一个是用的这个树节点的最大度数。</p><p><a href="https://www.quora.com/Why-is-the-maximum-number-of-keys-in-a-B-tree-equal-to-2-t-1-where-t-is-the-minimum-degree">reference: 为什么是2t-1</a></p></li><li><p>[pointer,key,pointer,key,pointer]: pointer的个数就是degree 所以至少有t-1个key 如果最多的话 就是 2t-1（全都是key）</p></li><li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211162324799.png" alt="image-20221115203019698"></p><ul><li>为什么b-tree优于红黑树？</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211162326275.png" alt="image-20221115203845142"></p><ul><li><p>注意h是base t的log函数 我们通过调整t可以使得h的增长变得很慢 从而提高了访问效率</p><ul><li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211162326940.png" alt="image-20221115203945028"></li><li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211162324621.png" alt="image-20221022120147376" style="zoom:50%;" /></li><li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211162324305.png" alt="image-20221022120405193"></li></ul></li><li><p>order</p></li></ul><p>一棵m阶的B树满足下列条件：</p><p>1.树中每个结点至多有m个孩子。</p><p>2.除根结点和叶子结点外，其它每个结点至少有m&#x2F;2个孩子。</p><p>3.根结点至少有2个孩子（如果B树只有一个结点除外）,这条性质是由B树的插入分裂策略决定的。</p><p>4.所有叶结点在同一层，B树的叶结点可以看成一种外部节点，不包含任何信息。</p><p>4.有k个关键字(关键字按递增次序排列)的非叶结点恰好有k+1个孩子。</p><p>5.一个节点如果由n个关键字，则节点内数据结构为P0，K1，P1，K2，P2………Pn-1 Kn Pn 其中 p为指向其子节点的指针，因为父子的大小 关系和节点内大小关系，满足Kj 大于Pj指针所指向的子树上的所有关键字小雨Pj+1指针所指向子树上的所有关键字</p><ul><li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211162324077.png" alt="image-20221021112043966"></li></ul><h3 id="opeartion-search-x2F-insert"><a href="#opeartion-search-x2F-insert" class="headerlink" title="opeartion search&#x2F;insert"></a>opeartion search&#x2F;insert</h3><ul><li>The procedures we present are all “one-pass” algorithms that proceed downward from the root of the tree, without having to back up.</li></ul><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><ul><li><p>non-split insert</p></li><li><p>split insert</p><ul><li>普通split</li><li>root也满了需要h+1的split</li></ul></li><li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211162324189.png" alt="image-20221115205201747"></p></li></ul><h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><ul><li>Delete one record from a leaf node with two records.</li><li>Delete one record from a leaf node with one record. <ul><li>Borrow a record from a brother，modify the record of parent node. </li><li>Brother node does not have enough record，merge two nodes by deleting empty leaf and moving 21 down.</li><li>Brother node does not have enough record，merge two nodes by deleting the empty leaf and moving 12 down. Modify the parent nodes based on the similar process.</li><li>Brother node does not have enough record，merge two nodes，modify parent node. This may reduce the height of the tree.</li></ul></li><li>Delete a record from internal node. The least key Y of right subtree replace the deleted key. Y must be in a leaf node. Then delete it.</li></ul><h3 id="拓展：磁盘读取"><a href="#拓展：磁盘读取" class="headerlink" title="拓展：磁盘读取"></a>拓展：磁盘读取</h3><p><a href="https://tech.meituan.com/2017/05/19/about-desk-io.html">re1</a></p><ul><li>main memory vs secondary storage(disks)</li><li>增加磁盘platter(硬盘盘片)只是增加disk drive’s capacity not its performance</li></ul><p><a href="https://medium.com/@andrewjmarkham1/disk-storage-data-indexing-and-a-use-case-for-b-trees-608ff56bffdd">re2</a></p><ul><li><p>数据库应用b-tree metadata 即寻找data 的index是利用b tree储存索引查找</p></li><li><p>the running time of a B-tree algorithm depends primarily on the number of DISK-READ and DISK-WRITE operations it performs, we typically want each of these operations to read or write as much information aspossible. Thus, a B-tree node is usually <strong>as large as a whole disk page</strong>, and this size limits the number of children a B-tree node can have.</p></li><li><p>branching factor指的是这个结点下有多少个孩子 则factor<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E6%94%AF%E5%9B%A0%E5%AD%90">就是几</a></p></li></ul><h3 id="exercise"><a href="#exercise" class="headerlink" title="exercise"></a>exercise</h3><ul><li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211162324586.png" alt="image-20221115204159554"></li><li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211162324143.png" alt="image-20221115204217841"></li></ul><h2 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h2><ul><li>平衡树：任意节点的子树的高度差都小于等于1 2-3树的叶子结点都在同一层因此是平衡树</li><li>Comparison times are not larger than the height of 2-3 tree.</li></ul><h2 id="B-tree"><a href="#B-tree" class="headerlink" title="B+ tree"></a>B+ tree</h2><ul><li><strong>B+ -tree</strong>, stores all the satellite information in the leaves and stores only keys and child pointers in the internal nodes, thus maximizing the branching factor of the internal nodes.</li><li>Special cases: <ul><li>If the root is not a leaf, it has at least 2 children.</li><li>If the root is a leaf (that is, there are no other nodes in the tree), it can have between 0 and (n–1) values.</li></ul></li></ul><p><img src="/assets/image-20221119221136727.png" alt="image-20221119221136727"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/11/15/15/"/>
    <url>/2022/11/15/15/</url>
    
    <content type="html"><![CDATA[<h2 id="评价算法标准"><a href="#评价算法标准" class="headerlink" title="评价算法标准"></a>评价算法标准</h2><ul><li><p><a href="https://blog.csdn.net/qq_43721542/article/details/106001300">stability</a></p></li><li><p>时间（最好 最坏 平均）</p><ul><li>关键字比较次数</li><li>数据移动次数</li></ul></li><li><p>空间（最好 最坏 平均）</p></li></ul><h3 id="排序分为comparison-sorting-和-counting-sorting"><a href="#排序分为comparison-sorting-和-counting-sorting" class="headerlink" title="排序分为comparison sorting 和 counting sorting"></a>排序分为comparison sorting 和 counting sorting</h3><ul><li>In <a href="https://en.wikipedia.org/wiki/Computer_science">computer science</a>, <strong>counting sort</strong> is an <a href="https://en.wikipedia.org/wiki/Algorithm">algorithm</a> for <a href="https://en.wikipedia.org/wiki/Sorting_algorithm">sorting</a> a collection of objects according to keys that are small positive <a href="https://en.wikipedia.org/wiki/Integer">integers</a>; that is, it is an <a href="https://en.wikipedia.org/wiki/Integer_sorting">integer sorting</a> algorithm. It operates by counting the number of objects that possess distinct key values, and applying prefix sum on those counts to determine the positions of each key value in the output sequence. Like other algorithms this sorting algorithm is not a comparison-based algorithm, it hashes the value in a temporary count array and uses them for sorting.</li></ul><h3 id="排序分为internal-和-external"><a href="#排序分为internal-和-external" class="headerlink" title="排序分为internal 和 external"></a>排序分为internal 和 external</h3><h2 id="insertion-sorting"><a href="#insertion-sorting" class="headerlink" title="insertion sorting"></a>insertion sorting</h2><ul><li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309217.png" alt="image-20221113163100785"></li></ul><h3 id="basics："><a href="#basics：" class="headerlink" title="basics："></a>basics：</h3><ul><li><p>for small inputs</p></li><li><p><a href="https://www.runoob.com/w3cnote/insertion-sort.html">图演示</a></p></li></ul><h3 id="pseudo-code"><a href="#pseudo-code" class="headerlink" title="pseudo code"></a>pseudo code</h3><ul><li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309187.png" alt="image-20221113163648161"></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">mark the first element as sorted<br>for each unsorted element x<br>extract x <br>for j = lastSortedIndex down to 0<br>if current element j &gt; x<br>move sorted element to the right by 1<br>break the loop and insert x here<br><br></code></pre></td></tr></table></figure><h3 id="C-code"><a href="#C-code" class="headerlink" title="C++code"></a>C++code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insertion_Sort</span><span class="hljs-params">(ElementType A[], <span class="hljs-type">int</span> N)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;N;i++)&#123;<br><span class="hljs-type">int</span> tmp = A[i]; <span class="hljs-comment">//+1</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br><span class="hljs-keyword">if</span>(A[j]&gt;A[i])&#123;<br>A[i]=A[j];<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>A[j] = tmp; <span class="hljs-comment">//+1 解释了为什么是+2</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">int</span> i, key, j;<br>   <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>   &#123;<br>       key = arr[i];<br>       j = i<span class="hljs-number">-1</span>;<br>       <span class="hljs-comment">/* Move elements of arr[0..i-1], that are</span><br><span class="hljs-comment">          greater than key, to one position ahead</span><br><span class="hljs-comment">          of their current position */</span><br>       <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; key)<br>       &#123;<br>           arr[j+<span class="hljs-number">1</span>] = arr[j];<br>           j = j<span class="hljs-number">-1</span>;<br>       &#125;<br>       arr[j+<span class="hljs-number">1</span>] = key;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309028.png" alt="image-20221113170531829"></li></ul><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><h4 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p><a href="https://cs.stackexchange.com/questions/21455/how-can-i-quantify-the-number-of-swaps-required-for-insertion-sort">交换次数取决于逆序对的个数</a></p><p><a href="https://www.geeksforgeeks.org/time-complexity-insertion-sort-inversions/#:~:text=Therefore%20overall%20time%20complexity%20of,is%20sorted%20in%20reverse%20order.">详细解释时间复杂度与逆序对</a></p><p>If we take a closer look at the insertion sort code, we can notice that every iteration of while loop reduces one inversion. The while loop executes only if i &gt; j and arr[i] &lt; arr[j]. Therefore total number of while loop iterations (For all values of i) is same as number of inversions. Therefore overall time complexity of the insertion sort is O(n + f(n)) where f(n) is inversion count. If the inversion count is O(n), then the time complexity of insertion sort is O(n). In worst case, there can be n*(n-1)&#x2F;2 inversions. The worst case occurs when the array is sorted in reverse order. So the worst case time complexity of insertion sort is O(n2).</p><ul><li>第p趟插入<ul><li>最好：比较1次 <strong>移动两次</strong>（腾位置+插入新数）也就是两处+1</li><li>最坏：比较p次 移动<strong>p+2</strong>次 while loop里面会进行p次的移动 + 2</li></ul></li></ul><p>O(N^2)  最优情况下： O(N)  </p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191943514.png" alt="image-20221119194308341"></p><h4 id="空间复杂度："><a href="#空间复杂度：" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>O(1)原地排序（in place）</p><h2 id="shell-sort（改进直接插入排序-优化insertion-sort）"><a href="#shell-sort（改进直接插入排序-优化insertion-sort）" class="headerlink" title="shell sort（改进直接插入排序 优化insertion sort）"></a>shell sort（改进直接插入排序 优化insertion sort）</h2><ul><li><p>希尔排序，也称递减增量排序算法Shellsort is also known as diminishing increment sort.</p></li><li><p>增量：gap 该子数列相邻元素的下标差</p></li><li><p><a href="https://en.wikipedia.org/wiki/Shellsort">reference wiki</a></p></li><li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309764.png" alt="image-20221113214131923"></p></li><li><p><a href="https://algostructure.com/sorting/shellsort.php">Shell Sort Algorithm Animation - algostructure.com</a></p></li><li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309924.png" alt="image-20221113215111601"></p></li></ul><h3 id="特别：折半插入"><a href="#特别：折半插入" class="headerlink" title="特别：折半插入"></a>特别：折半插入</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/34914588">折半插入的增量</a><ul><li>增量：</li><li>增量取法 每次N&#x2F;2 &#x2F;2 &#x2F;2 &#x2F;2（折半）</li></ul></li></ul><h3 id="c-code"><a href="#c-code" class="headerlink" title="c++code"></a>c++code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Shell_Sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">// Start with a big gap, then reduce the gap</span><br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> gap = n / <span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-comment">// Do a gapped insertion sort for this gap size.</span><br>  <span class="hljs-comment">// The first gap elements arr[0..gap-1] are already in gapped order</span><br>  <span class="hljs-comment">// keep adding one more element until the entire array is</span><br>  <span class="hljs-comment">// gap sorted</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = gap; i &lt; n; i += <span class="hljs-number">1</span>) &#123;<br>   <span class="hljs-comment">// add arr[i] to the elements that have been gap sorted</span><br>   <span class="hljs-comment">// save arr[i] in temp and make a hole at position i</span><br>   <span class="hljs-type">int</span> temp = arr[i];<br> <br>   <span class="hljs-comment">// shift earlier gap-sorted elements up until the correct</span><br>   <span class="hljs-comment">// location for arr[i] is found</span><br>   <span class="hljs-type">int</span> j;<br>   <span class="hljs-keyword">for</span> (j = i; j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp; j -= gap)<br>    arr[j] = arr[j - gap];<br> <br>   <span class="hljs-comment">// put temp (the original arr[i]) in its correct location</span><br>   arr[j] = temp;<br>  &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li><p><strong>Best Case Complexity</strong><br>When the given array list is already sorted the total count of comparisons of each interval is equal to the size of the given array.<br><em>So best case complexity is Ω(n log(n))</em><br><strong>Average Case Complexity</strong></p><p>The shell sort Average Case Complexity depends on the interval selected by the programmer.<br><em>θ(n log(n)2)</em>.</p><p><em>THE Average Case Complexity: O(n*log n)~O(n1.25)</em></p></li></ul><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><ul><li>O(1)</li></ul><h2 id="bubble-sorting"><a href="#bubble-sorting" class="headerlink" title="bubble sorting"></a>bubble sorting</h2><ul><li>适用于链表和数组（因为只按照一个方向进行sort和比较）<ul><li>有的算法不一定适用于链表结构</li></ul></li><li>稳定算法</li><li>效率和排序序列的初始顺序有关</li></ul><h3 id="pseudo-code-1"><a href="#pseudo-code-1" class="headerlink" title="pseudo code"></a>pseudo code</h3><p><a href="https://www.jianshu.com/p/648d87dc4cfc">加入swapped优化 如果上一次遍历没有交换则已经有序</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">Bubble_sort(list):                         // list 表示待排序序列<br>    for i &lt;- 0 to length(list)-1:          // 对于元素个数为 n 的 list 序列，需遍历 n-1 次，这里用 [0,length(list)-1) 表示。<br>        for j &lt;- 1 to length(list) - i:    // 从第 1 个元素开始遍历，遍历区间为 [1,length(list)-i)。<br>            if list[j] &gt; list[j+1]:        // 若进行降序排序，则改成 &lt; 小于号<br>                 swap(list[j] , list[j+1]) // 交换 2 个相邻元素的位置<br>    return list                            // 返回排好序的序列<br></code></pre></td></tr></table></figure><h3 id="c-code-1"><a href="#c-code-1" class="headerlink" title="c++ code"></a>c++ code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Bubble_Sort</span><span class="hljs-params">(ElementType A[], <span class="hljs-type">int</span> N)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j =<span class="hljs-number">1</span>;j&lt;N-i;j++)&#123; <span class="hljs-comment">//经过第i趟冒泡 有i个元素已经排好（在队尾）是最大的元素</span><br><span class="hljs-keyword">if</span>(A[j]&lt;A[j<span class="hljs-number">-1</span>])&#123;<br><span class="hljs-built_in">swap</span>(A[j],A[j<span class="hljs-number">-1</span>]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>优化版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Bubble_Sort</span><span class="hljs-params">(ElementType A[], <span class="hljs-type">int</span> N)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br><span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j =<span class="hljs-number">1</span>;j&lt;N-i;j++)&#123; <span class="hljs-comment">//经过第i趟冒泡 有i个元素已经排好（在队尾）是最大的元素</span><br><span class="hljs-keyword">if</span>(A[j]&lt;A[j<span class="hljs-number">-1</span>])&#123;<br><span class="hljs-built_in">swap</span>(A[j],A[j<span class="hljs-number">-1</span>]);<br>flag = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(flag==<span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h3><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><ul><li>因为每次比较后如果两个相邻元素相等我们并不会将他们交换，所以冒泡不会改变相同元素的下标，所以冒泡排序是一个稳定的排序</li></ul><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li><p>最好情况下的时间复杂度：如果元素本来就是有序的，那么一趟冒泡排序既可以完成排序工作 因此最好情况的时间复杂度为O(n)</p><p>比较次数：n-1</p><p>移动次数：0</p></li><li><p>最差情况的时间复杂度：如果数据元素本来就是逆序的 最坏情况子下的时间复杂度为O(n^2)。</p><p>比较次数：n(n-1)&#x2F;2</p><p>移动次数：3n(n-1)&#x2F;2</p></li><li><p>平均时间复杂度：O(n^2)</p></li></ul><h4 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><ul><li>O(1)</li></ul><h2 id="selection-sort"><a href="#selection-sort" class="headerlink" title="selection sort"></a>selection sort</h2><ul><li><a href="https://zh.khanacademy.org/computing/computer-science/algorithms/sorting-algorithms/a/selection-sort-pseudocode#:~:text=%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E4%BC%AA%E4%BB%A3%E7%A0%81%201%20%E6%89%BE%E5%88%B0%E6%9C%80%E5%B0%8F%E7%9A%84%E5%8D%A1%E7%89%87%E3%80%82%20%E7%94%A8%E7%AC%AC%E4%B8%80%E5%BC%A0%E5%8D%A1%E4%BA%A4%E6%8D%A2%E5%AE%83%E3%80%82%202%20%E6%89%BE%E5%88%B0%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E5%8D%A1%E3%80%82,%E7%94%A8%E7%AC%AC%E4%BA%8C%E5%BC%A0%E5%8D%A1%E4%BA%A4%E6%8D%A2%E5%AE%83%E3%80%82%203%20%E6%89%BE%E5%88%B0%E7%AC%AC%E4%B8%89%E5%B0%8F%E7%9A%84%E5%8D%A1%E3%80%82%20%E7%94%A8%E7%AC%AC%E4%B8%89%E5%BC%A0%E5%8D%A1%E4%BA%A4%E6%8D%A2%E5%AE%83%E3%80%82%204%20%E9%87%8D%E5%A4%8D%E6%9F%A5%E6%89%BE%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9C%80%E5%B0%8F%E7%9A%84%E5%8D%A1%EF%BC%8C%E5%B9%B6%E5%B0%86%E5%85%B6%E4%BA%A4%E6%8D%A2%E5%88%B0%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%8C%E7%9B%B4%E5%88%B0%E5%AE%8C%E6%88%90%E5%AF%B9%E9%98%B5%E5%88%97%E7%9A%84%E6%8E%92%E5%BA%8F%E3%80%82">演示</a></li><li>类似bubble sort 优点是 交换次数只有n-1 </li><li>缺陷：没有利用前一趟比较遍历获取的信息</li></ul><h3 id="c-code-2"><a href="#c-code-2" class="headerlink" title="c++ code"></a>c++ code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Selection_Sort</span><span class="hljs-params">(ElementType A[], <span class="hljs-type">int</span> N)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;N<span class="hljs-number">-1</span>;i++)&#123;<br><span class="hljs-type">int</span> k = i<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;N;j++)&#123;<br><span class="hljs-keyword">if</span>(A[j]&gt;A[i])&#123;<br>k=j;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(k!=i<span class="hljs-number">-1</span>)<br><span class="hljs-built_in">swap</span>(A[k],A[i<span class="hljs-number">-1</span>]);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i, j, min_idx;<br> <br>    <span class="hljs-comment">// One by one move boundary of</span><br>    <span class="hljs-comment">// unsorted subarray</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n<span class="hljs-number">-1</span>; i++)<br>    &#123;<br>       <br>        <span class="hljs-comment">// Find the minimum element in</span><br>        <span class="hljs-comment">// unsorted array</span><br>        min_idx = i;<br>        <span class="hljs-keyword">for</span> (j = i+<span class="hljs-number">1</span>; j &lt; n; j++)<br>        <span class="hljs-keyword">if</span> (arr[j] &lt; arr[min_idx])<br>            min_idx = j;<br> <br>        <span class="hljs-comment">// Swap the found minimum element</span><br>        <span class="hljs-comment">// with the first element</span><br>        <span class="hljs-keyword">if</span>(min_idx!=i)<br>            <span class="hljs-built_in">swap</span>(&amp;arr[min_idx], &amp;arr[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度-3"><a href="#复杂度-3" class="headerlink" title="复杂度"></a>复杂度</h3><h4 id="稳定性-1"><a href="#稳定性-1" class="headerlink" title="稳定性"></a>稳定性</h4><ul><li>不稳定算法（存在非相邻元素的交换）</li></ul><h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li><p>选择排序的复杂度分析。第一次内循环比较N - 1次，然后是N-2次，N-3次，……，最后一次内循环比较1次。<br>共比较的次数是 <code>(N - 1) + (N - 2) + ... + 1</code>，求等差数列和，得 <code>(N - 1 + 1)* N / 2 = N^2 / 2</code>。<br>舍去最高项系数，其时间复杂度为 <code>O(N^2)</code>。</p><p>虽然选择排序和冒泡排序的时间复杂度一样，但实际上，选择排序进行的交换操作很少，最多会发生 N - 1次交换。</p></li><li><p>运行时间和输入无关</p></li><li><p>选择排序的交换操作介于0和(n-1)次之间。选择排序的比较操作为n(n-1)&#x2F;2次之间。选择排序的赋值操作介于0和3(n-1)次之间。</p><p>比较次数O(n^2)，比较次数与关键字的初始状态无关，总的比较次数N &#x3D; (n-1) + (n-2) +…+ 1 &#x3D; n x (n-1)&#x2F;2。交换次数O(n)，最好情况是，已经有序，交换0次；最坏情况是，逆序，交换n-1次。</p></li></ul><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191945893.png" alt="image-20221119194542763"></p><h2 id="heap-sort（优化selection-sort-快速找到最小元）"><a href="#heap-sort（优化selection-sort-快速找到最小元）" class="headerlink" title="heap sort（优化selection sort 快速找到最小元）"></a>heap sort（优化selection sort 快速找到最小元）</h2><ul><li>充分利用了每一趟遍历比较的信息</li><li>堆分为<a href="https://so.csdn.net/so/search?q=%E5%A4%A7%E6%A0%B9%E5%A0%86&spm=1001.2101.3001.7020">大根堆</a>和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;&#x3D; A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。<ul><li>heap可以用priority queue实现</li><li>Heapsort, sorts n numbers in place in O(n lg n) time. It uses an important data structure, called a heap, with which we can also implement a priority queue.</li><li>Using this model, we prove a lower bound of Ω(n lg n) on the worst-case running time of any comparison sort on n inputs, thus showing that heapsort and merge sort are asymptotically optimal comparison sorts.</li></ul></li><li>调整heap的时间复杂度（lgn）</li><li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309412.png" alt="image-20221027133800119"></li></ul><p><a href="https://visualgo.net/zh/heap?slide=1">建堆演示</a></p><p><a href="https://blog.csdn.net/u010711495/article/details/117386069">建堆代码</a></p><ul><li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309584.png" alt="image-20221110220027078"></p></li><li><p><a href="https://cs.stackexchange.com/questions/141748/how-is-the-reccurence-of-max-heapify-tn-t2n-3-theta1">堆的左子树的结点个数的限制</a></p></li><li><p>计算父节点或者左右子节点的时候*2 或&#x2F;2 可以用计算机的shift bit进行计算</p></li></ul><h4 id="max-heapify的时间复杂度（粗略的O-和-更贴合的Ω）"><a href="#max-heapify的时间复杂度（粗略的O-和-更贴合的Ω）" class="headerlink" title="max-heapify的时间复杂度（粗略的O 和 更贴合的Ω）"></a>max-heapify的时间复杂度（粗略的O 和 更贴合的Ω）</h4><p>We can compute a simple upper bound on the running time of BUILD-MAX- HEAP as follows. Each call to MAX-HEAPIFY costs O(nlgn) time, and BUILD- MAX-HEAP makes O(n) such calls. Thus, the running time is O(nlgn). This upper bound, though correct, is not asymptotically tight.</p><p>We can derive a tighter bound by observing that the time for MAX-HEAPIFY torun at a node varies with the height of the node in the tree, and the heights of most nodes are small. Our tighter analysis relies on the properties that an  n-element heap has height </p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309702.png" alt="image-20221112091149489"></p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309638.png" alt="image-20221112203441025"></p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309827.png" alt="image-20221112203427151"></p><p><a href="https://blog.csdn.net/feliciafay/article/details/12869179">叶子节点开始的下标</a></p><ul><li><p>只需要求出叶子节点上一层的结点个数 大概为总结点个数的一半</p></li><li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152310023.png" alt="image-20221112092704508"></p></li><li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152310505.png" alt="image-20221112094046683"></p></li><li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152310044.png" alt="image-20221112203126918"></p></li></ul><h3 id="time-complexity"><a href="#time-complexity" class="headerlink" title="time complexity"></a>time complexity</h3><ul><li><p>best case(all elements are identical) <a href="https://cs.stackexchange.com/questions/138432/running-time-of-heap-sort-when-all-number-are-identical">proof</a></p><ul><li><p>The best case for heapsort would happen when all elements in the list to be sorted are identical. In such a case, for ‘n’ number of nodes-</p></li><li><p>Removing each node from the heap would take only a constant runtime, O(1). There would be no need to bring any node down or bring max valued node up, as all items are identical.</p></li><li><p>Since we do this for every node, the total number of moves would be n * O(1).</p><p>Therefore, the runtime in the best case would be O(n).</p></li></ul></li></ul><h3 id="code-c"><a href="#code-c" class="headerlink" title="code c++"></a>code c++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> N, <span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Find largest among root, left child and right child</span><br> <br>    <span class="hljs-comment">// Initialize largest as root</span><br>    <span class="hljs-type">int</span> largest = i;<br> <br>    <span class="hljs-comment">// left = 2*i + 1</span><br>    <span class="hljs-type">int</span> left = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br> <br>    <span class="hljs-comment">// right = 2*i + 2</span><br>    <span class="hljs-type">int</span> right = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>;<br> <br>    <span class="hljs-comment">// If left child is larger than root</span><br>    <span class="hljs-keyword">if</span> (left &lt; N &amp;&amp; arr[left] &gt; arr[largest])<br> <br>        largest = left;<br> <br>    <span class="hljs-comment">// If right child is larger than largest</span><br>    <span class="hljs-comment">// so far</span><br>    <span class="hljs-keyword">if</span> (right &lt; N &amp;&amp; arr[right] &gt; arr[largest])<br> <br>        largest = right;<br> <br>    <span class="hljs-comment">// Swap and continue heapifying if root is not largest</span><br>    <span class="hljs-comment">// If largest is not root</span><br>    <span class="hljs-keyword">if</span> (largest != i) &#123;<br> <br>        <span class="hljs-built_in">swap</span>(&amp;arr[i], &amp;arr[largest]);<br> <br>        <span class="hljs-comment">// Recursively heapify the affected</span><br>        <span class="hljs-comment">// sub-tree</span><br>        <span class="hljs-built_in">heapify</span>(arr, N, largest);<br>    &#125;<br>&#125;<br> <br><span class="hljs-comment">// Main function to do heap sort</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> N)</span></span><br><span class="hljs-function"></span>&#123;<br> <br>    <span class="hljs-comment">// Build max heap</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = N / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br> <br>        <span class="hljs-built_in">heapify</span>(arr, N, i);<br> <br>    <span class="hljs-comment">// Heap sort</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = N - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br> <br>        <span class="hljs-built_in">swap</span>(&amp;arr[<span class="hljs-number">0</span>], &amp;arr[i]);<br> <br>        <span class="hljs-comment">// Heapify root element to get highest element at</span><br>        <span class="hljs-comment">// root again</span><br>        <span class="hljs-built_in">heapify</span>(arr, i, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br> <br><span class="hljs-comment">// A utility function to print array of size n</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> N)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, arr[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br> <br><span class="hljs-comment">// Driver&#x27;s code</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">12</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span> &#125;;<br>    <span class="hljs-type">int</span> N = <span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>]);<br> <br>    <span class="hljs-comment">// Function call</span><br>    <span class="hljs-built_in">heapSort</span>(arr, N);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Sorted array is\n&quot;</span>);<br>    <span class="hljs-built_in">printArray</span>(arr, N);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.geeksforgeeks.org/cpp-program-for-heap-sort/">reference</a></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="merge-sorting"><a href="#merge-sorting" class="headerlink" title="merge sorting"></a>merge sorting</h2><ul><li><p>对两个有序的子序列 </p></li><li><p><a href="https://zhuanlan.zhihu.com/p/124356219">basics</a></p></li><li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152309476.png" alt="image-20221112232227825"></p></li><li><p>The recursion “bottoms out” when the sequence to be sorted has length 1, in which</p><p>case there is no work to be done, since every sequence of length 1 is already in</p><p>sorted order.</p></li></ul><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>When merging two sorted arrays into a single larger one, we need space to hold the merged result. Since the arrays we’ll be combining have O(n) items, we’ll need O(n) space in total but because we are doing recursion calls so this extra array is goin to be copied log (n) times so the space complexity is O(n log n) here.</p><ul><li>merge用两个辅助数组</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">void</span> Merge(T Data[], <span class="hljs-type">int</span> <span class="hljs-keyword">start</span>, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> <span class="hljs-keyword">end</span>)&#123;<br><span class="hljs-type">int</span> len1 = mid-<span class="hljs-keyword">start</span>+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>merge用一个辅助数组</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> high)</span></span>&#123;<br><span class="hljs-type">int</span> i = low; <span class="hljs-type">int</span> j = mid + <span class="hljs-number">1</span>; <span class="hljs-type">int</span> k = low;<br><span class="hljs-type">int</span>[] auxiliaryArr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[high+<span class="hljs-number">1</span>];<br><span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high)&#123;<br><span class="hljs-keyword">if</span> (arr[i] &lt; arr[j])&#123;<br>auxiliaryArr[k++] = arr[i++];&#125;<br><span class="hljs-keyword">else</span>&#123;<br>auxiliaryArr[k++] = arr[j++];&#125;<br>         &#125;<br><span class="hljs-keyword">while</span> (i &lt;= mid)&#123;<br>auxiliaryArr[k++] = arr[i++];&#125;<br><span class="hljs-keyword">while</span> (j &lt;= high)&#123;<br>         auxiliaryArr[k++] = arr[j++];&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = low; r &lt;= high; r++)&#123;<br>arr[r] = auxiliaryArr[r];&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152310564.png" alt="image-20221113111430021"></p></li><li><p>&#96;&#96;&#96;c++<br>void merge(vector<Comparable>&amp; a, int L, int R, int RightEnd) {<br>int size &#x3D; a.size();<br>int LeftEnd &#x3D; R - 1;<br>int p &#x3D; L;<br>int num &#x3D; RightEnd - L + 1;<br>vector<Comparable> tmp(size);<br>while (L &lt;&#x3D; LeftEnd &amp;&amp; R &lt;&#x3D; RightEnd) {<br>    if (a[L] &lt;&#x3D; a[R])<br>        tmp[p++] &#x3D; a[L++];<br>    else<br>        tmp[p++] &#x3D; a[R++];<br>}<br>while (L &lt;&#x3D; LeftEnd)<br>    tmp[p++] &#x3D; a[L++];<br>while (R &lt;&#x3D; RightEnd)<br>    tmp[p++] &#x3D; a[R++];<br>for (int i &#x3D; 0; i &lt;num; i++,RightEnd–)<br>    a[RightEnd] &#x3D; tmp[RightEnd];<br>}</p><p>template <class Comparable><br>void mergeImproved( vector<Comparable> &amp;a ) {<br>int n &#x3D; a.size();<br>int i, s;<br>int t &#x3D; 1;<br>while (t &lt; n) {<br>    s &#x3D; t;<br>    t <em>&#x3D; 2;<br>    i &#x3D; 0;<br>    while (i + t &lt; n) {<br>        merge(a, i, i + s, i + 2</em>s - 1);<br>        i &#x3D; i + t;<br>    }<br>    if (i + s &lt; n) {<br>        merge(a, i, i + s, n - 1);<br>    }<br>}<br>}</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><br>  <br><br>### top-down(recursive)<br><br>- References: http://csg.sph.umich.edu/abecasis/class/<span class="hljs-number">2006</span>/<span class="hljs-number">615.09</span>.pdf<br><br>### bottom-up(non-recursive)<br><br>- ![image<span class="hljs-number">-20221113112739158</span>](https://raw.githubusercontent.com/pinkyrie/pic/main/<span class="hljs-number">202211152309346</span>.png)<br><br>### time complexity<br><br>#### 次数分析（时间复杂度）<br><br>- ![image<span class="hljs-number">-20221113113901708</span>](https://raw.githubusercontent.com/pinkyrie/pic/main/<span class="hljs-number">202211152309672</span>.png)<br><br>[reference](https://zhuanlan.zhihu.com/p/<span class="hljs-number">341225128</span>#:~:text<span class="hljs-operator">=</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%90</span><span class="hljs-variable">%88</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%B9</span><span class="hljs-variable">%B6</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%93</span><span class="hljs-variable">%8</span>D<span class="hljs-variable">%E4</span><span class="hljs-variable">%BD</span><span class="hljs-variable">%9</span>C<span class="hljs-variable">%E7</span><span class="hljs-variable">%9</span>A<span class="hljs-variable">%84</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%9</span>C<span class="hljs-variable">%80</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%9</span>D<span class="hljs-variable">%8</span>F<span class="hljs-variable">%E6</span><span class="hljs-variable">%97</span><span class="hljs-variable">%B6</span><span class="hljs-variable">%E9</span><span class="hljs-variable">%97</span><span class="hljs-variable">%B4</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%A4</span><span class="hljs-variable">%8</span>D<span class="hljs-variable">%E6</span><span class="hljs-variable">%9</span>D<span class="hljs-variable">%82</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%BA</span><span class="hljs-variable">%A6</span><span class="hljs-variable">%3</span>A<span class="hljs-variable">%20</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%A0</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%BF</span><span class="hljs-variable">%83</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%82</span><span class="hljs-variable">%B9</span><span class="hljs-variable">%3</span>A<span class="hljs-variable">%E4</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%A4</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%AA</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%BA</span><span class="hljs-variable">%8</span>F<span class="hljs-variable">%E5</span><span class="hljs-variable">%88</span><span class="hljs-variable">%97</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%90</span><span class="hljs-variable">%84</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%AA</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%85</span><span class="hljs-variable">%83</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%B4</span><span class="hljs-variable">%A0</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%9</span>A<span class="hljs-variable">%84</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%A4</span><span class="hljs-variable">%A7</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%B0</span><span class="hljs-variable">%8</span>F<span class="hljs-variable">%E4</span><span class="hljs-variable">%BA</span><span class="hljs-variable">%A4</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%8</span>F<span class="hljs-variable">%89</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%8</span>E<span class="hljs-variable">%92</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%88</span><span class="hljs-variable">%97</span><span class="hljs-variable">%EF</span><span class="hljs-variable">%BC</span><span class="hljs-variable">%8</span>C<span class="hljs-variable">%E6</span><span class="hljs-variable">%AD</span><span class="hljs-variable">%A4</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%97</span><span class="hljs-variable">%B6</span><span class="hljs-variable">%E9</span><span class="hljs-variable">%9</span>C<span class="hljs-variable">%80</span><span class="hljs-variable">%E8</span><span class="hljs-variable">%A6</span><span class="hljs-variable">%81</span><span class="hljs-variable">%20</span>m<span class="hljs-variable">%2</span>Bn<span class="hljs-number">-1</span><span class="hljs-variable">%20</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%AD</span><span class="hljs-variable">%A4</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%AF</span><span class="hljs-variable">%94</span><span class="hljs-variable">%E8</span><span class="hljs-variable">%BE</span><span class="hljs-variable">%83</span><span class="hljs-variable">%20</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%BD</span><span class="hljs-variable">%92</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%B9</span><span class="hljs-variable">%B6</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%AE</span><span class="hljs-variable">%97</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%B3</span><span class="hljs-variable">%95</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%97</span><span class="hljs-variable">%B6</span><span class="hljs-variable">%E9</span><span class="hljs-variable">%97</span><span class="hljs-variable">%B4</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%A4</span><span class="hljs-variable">%8</span>D<span class="hljs-variable">%E6</span><span class="hljs-variable">%9</span>D<span class="hljs-variable">%82</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%BA</span><span class="hljs-variable">%A6</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%88</span><span class="hljs-variable">%86</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%9</span>E<span class="hljs-variable">%90</span><span class="hljs-variable">%3</span>A<span class="hljs-variable">%20</span><span class="hljs-variable">%E8</span><span class="hljs-variable">%AE</span><span class="hljs-variable">%BE</span><span class="hljs-variable">%20</span>n<span class="hljs-variable">%20</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%BA</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%BE</span><span class="hljs-variable">%85</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%8</span>E<span class="hljs-variable">%92</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%BA</span><span class="hljs-variable">%8</span>F<span class="hljs-variable">%E6</span><span class="hljs-variable">%95</span><span class="hljs-variable">%B0</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%BB</span><span class="hljs-variable">%84</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%AD</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%9</span>A<span class="hljs-variable">%84</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%85</span><span class="hljs-variable">%83</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%B4</span><span class="hljs-variable">%A0</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%AA</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%95</span><span class="hljs-variable">%B0</span><span class="hljs-variable">%EF</span><span class="hljs-variable">%BC</span><span class="hljs-variable">%8</span>C<span class="hljs-punctuation">,</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%AA</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%95</span><span class="hljs-variable">%B0</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%8</span>D<span class="hljs-variable">%AE</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%85</span><span class="hljs-variable">%83</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%B4</span><span class="hljs-variable">%A0</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%9</span>A<span class="hljs-variable">%84</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%BA</span><span class="hljs-variable">%8</span>F<span class="hljs-variable">%E5</span><span class="hljs-variable">%88</span><span class="hljs-variable">%97</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%90</span><span class="hljs-variable">%88</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%B9</span><span class="hljs-variable">%B6</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%BA</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%80</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%AA</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%90</span><span class="hljs-variable">%AB</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%9</span>C<span class="hljs-variable">%89</span><span class="hljs-variable">%20</span>n<span class="hljs-variable">%20</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%AA</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%95</span><span class="hljs-variable">%B0</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%8</span>D<span class="hljs-variable">%AE</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%85</span><span class="hljs-variable">%83</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%B4</span><span class="hljs-variable">%A0</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%9</span>A<span class="hljs-variable">%84</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%BA</span><span class="hljs-variable">%8</span>F<span class="hljs-variable">%E5</span><span class="hljs-variable">%88</span><span class="hljs-variable">%97</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%89</span><span class="hljs-variable">%80</span><span class="hljs-variable">%E9</span><span class="hljs-variable">%9</span>C<span class="hljs-variable">%80</span><span class="hljs-variable">%E8</span><span class="hljs-variable">%A6</span><span class="hljs-variable">%81</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%9</span>A<span class="hljs-variable">%84</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%AF</span><span class="hljs-variable">%94</span><span class="hljs-variable">%E8</span><span class="hljs-variable">%BE</span><span class="hljs-variable">%83</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%93</span><span class="hljs-variable">%8</span>D<span class="hljs-variable">%E4</span><span class="hljs-variable">%BD</span><span class="hljs-variable">%9</span>C<span class="hljs-variable">%E6</span><span class="hljs-variable">%AC</span><span class="hljs-variable">%A1</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%95</span><span class="hljs-variable">%B0</span><span class="hljs-variable">%20</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%A9</span><span class="hljs-variable">%BA</span><span class="hljs-variable">%E9</span><span class="hljs-variable">%97</span><span class="hljs-variable">%B4</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%A4</span><span class="hljs-variable">%8</span>D<span class="hljs-variable">%E6</span><span class="hljs-variable">%9</span>D<span class="hljs-variable">%82</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%BA</span><span class="hljs-variable">%A6</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%88</span><span class="hljs-variable">%86</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%9</span>E<span class="hljs-variable">%90</span><span class="hljs-variable">%3</span>A<span class="hljs-variable">%20</span>O<span class="hljs-variable">%20</span><span class="hljs-variable">%28</span>n<span class="hljs-variable">%29</span><span class="hljs-variable">%2</span>C<span class="hljs-variable">%E9</span><span class="hljs-variable">%9</span>C<span class="hljs-variable">%80</span><span class="hljs-variable">%E8</span><span class="hljs-variable">%A6</span><span class="hljs-variable">%81</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%80</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%AA</span><span class="hljs-variable">%E9</span><span class="hljs-variable">%A2</span><span class="hljs-variable">%9</span>D<span class="hljs-variable">%E5</span><span class="hljs-variable">%A4</span><span class="hljs-variable">%96</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%9</span>A<span class="hljs-variable">%84</span>n<span class="hljs-variable">%E7</span><span class="hljs-variable">%BB</span><span class="hljs-variable">%B4</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%95</span><span class="hljs-variable">%B0</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%BB</span><span class="hljs-variable">%84</span><span class="hljs-variable">%20</span>I<span class="hljs-variable">%20</span><span class="hljs-variable">%5</span>B<span class="hljs-variable">%5</span>D)<br><br>[数比较次数](https://math.stackexchange.com/questions/<span class="hljs-number">3649182</span>/merge-sort-maximum-comparisons)<br><br>- 例子：<br>  假设二路归并<br>  <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br>  <span class="hljs-number">12</span>  <span class="hljs-number">34</span>   **<span class="hljs-number">2</span>次**<br>  <span class="hljs-number">2</span>&lt;<span class="hljs-number">4</span>  <span class="hljs-number">2</span>&lt;<span class="hljs-number">3</span>  **<span class="hljs-number">2</span>次**   不用再继续  共<span class="hljs-number">4</span>次<br>  <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> 有序<br><br>  <span class="hljs-number">2314</span> <br>  <span class="hljs-number">23</span>  <span class="hljs-number">14</span>  **<span class="hljs-number">2</span>次**<br>  <span class="hljs-number">3</span>&lt;<span class="hljs-number">4</span>  <span class="hljs-number">3</span>&gt;<span class="hljs-number">1</span>  **<span class="hljs-number">2</span>次**   再用<span class="hljs-number">2</span>比较<br>  <span class="hljs-number">2</span>&gt;<span class="hljs-number">1</span>       **<span class="hljs-number">1</span>次**   插入<br>  <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> 有序  共<span class="hljs-number">5</span>次<br><br>- 极端的例子 <span class="hljs-number">1357</span> <span class="hljs-number">2468</span> ：每一个都要互相比较 m+n<span class="hljs-number">-1</span>可以比完一个序列 然后最后一个数字没有比较直接加在尾巴就好<br><br>- [非递归](https://www.cnblogs.com/xing<span class="hljs-number">901022</span>/p/<span class="hljs-number">3671771</span>.html)<br><br>- [非递归](https://www.cnblogs.com/liushang<span class="hljs-number">0419</span>/archive/<span class="hljs-number">2011</span>/<span class="hljs-number">09</span>/<span class="hljs-number">19</span>/<span class="hljs-number">2181476</span>.html#:~:text<span class="hljs-operator">=</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%BD</span><span class="hljs-variable">%92</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%B9</span><span class="hljs-variable">%B6</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%8</span>E<span class="hljs-variable">%92</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%BA</span><span class="hljs-variable">%8</span>F<span class="hljs-variable">%E7</span><span class="hljs-variable">%9</span>A<span class="hljs-variable">%84</span><span class="hljs-variable">%E9</span><span class="hljs-variable">%9</span>D<span class="hljs-variable">%9</span>E<span class="hljs-variable">%E9</span><span class="hljs-variable">%80</span><span class="hljs-variable">%92</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%BD</span><span class="hljs-variable">%92</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%AE</span><span class="hljs-variable">%9</span>E<span class="hljs-variable">%E7</span><span class="hljs-variable">%8</span>E<span class="hljs-variable">%B0</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%A6</span><span class="hljs-variable">%82</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%8</span>B<span class="hljs-variable">%EF</span><span class="hljs-variable">%BC</span><span class="hljs-variable">%8</span>C<span class="hljs-variable">%E6</span><span class="hljs-variable">%80</span><span class="hljs-variable">%9</span>D<span class="hljs-variable">%E6</span><span class="hljs-variable">%83</span><span class="hljs-variable">%B3</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%92</span><span class="hljs-variable">%8</span>C<span class="hljs-variable">%E9</span><span class="hljs-variable">%80</span><span class="hljs-variable">%92</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%BD</span><span class="hljs-variable">%92</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%AD</span><span class="hljs-variable">%A3</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%A5</span><span class="hljs-variable">%BD</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%9</span>B<span class="hljs-variable">%B8</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%8</span>F<span class="hljs-variable">%8</span>D<span class="hljs-variable">%EF</span><span class="hljs-variable">%BC</span><span class="hljs-variable">%8</span>C<span class="hljs-variable">%E5</span><span class="hljs-variable">%8</span>E<span class="hljs-variable">%9</span>F<span class="hljs-variable">%E6</span><span class="hljs-variable">%9</span>D<span class="hljs-variable">%A5</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%9</span>A<span class="hljs-variable">%84</span><span class="hljs-variable">%E9</span><span class="hljs-variable">%80</span><span class="hljs-variable">%92</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%BD</span><span class="hljs-variable">%92</span><span class="hljs-variable">%E8</span><span class="hljs-variable">%BF</span><span class="hljs-variable">%87</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%A8</span><span class="hljs-variable">%8</span>B<span class="hljs-variable">%E6</span><span class="hljs-variable">%98</span><span class="hljs-variable">%AF</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%B0</span><span class="hljs-variable">%86</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%BE</span><span class="hljs-variable">%85</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%8</span>E<span class="hljs-variable">%92</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%BA</span><span class="hljs-variable">%8</span>F<span class="hljs-variable">%E9</span><span class="hljs-variable">%9</span>B<span class="hljs-variable">%86</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%90</span><span class="hljs-variable">%88</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%80</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%88</span><span class="hljs-variable">%86</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%BA</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%BA</span><span class="hljs-variable">%8</span>C<span class="hljs-variable">%EF</span><span class="hljs-variable">%BC</span><span class="hljs-variable">%8</span>C<span class="hljs-variable">%E7</span><span class="hljs-variable">%9</span>B<span class="hljs-variable">%B4</span><span class="hljs-variable">%E8</span><span class="hljs-variable">%87</span><span class="hljs-variable">%B3</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%8</span>E<span class="hljs-variable">%92</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%BA</span><span class="hljs-variable">%8</span>F<span class="hljs-variable">%E9</span><span class="hljs-variable">%9</span>B<span class="hljs-variable">%86</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%90</span><span class="hljs-variable">%88</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%B0</span><span class="hljs-variable">%B1</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%89</span><span class="hljs-variable">%A9</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%8</span>B<span class="hljs-variable">%E4</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%80</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%AA</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%85</span><span class="hljs-variable">%83</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%B4</span><span class="hljs-variable">%A0</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%BD</span><span class="hljs-variable">%8</span>D<span class="hljs-variable">%E7</span><span class="hljs-variable">%BD</span><span class="hljs-variable">%AE</span><span class="hljs-variable">%EF</span><span class="hljs-variable">%BC</span><span class="hljs-variable">%8</span>C<span class="hljs-variable">%E7</span><span class="hljs-variable">%84</span><span class="hljs-variable">%B6</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%90</span><span class="hljs-variable">%8</span>E<span class="hljs-variable">%E4</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%8</span>D<span class="hljs-variable">%E6</span><span class="hljs-variable">%96</span><span class="hljs-variable">%AD</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%9</span>A<span class="hljs-variable">%84</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%90</span><span class="hljs-variable">%88</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%B9</span><span class="hljs-variable">%B6</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%A4</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%AA</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%8</span>E<span class="hljs-variable">%92</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%A5</span><span class="hljs-variable">%BD</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%BA</span><span class="hljs-variable">%8</span>F<span class="hljs-variable">%E7</span><span class="hljs-variable">%9</span>A<span class="hljs-variable">%84</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%95</span><span class="hljs-variable">%B0</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%BB</span><span class="hljs-variable">%84</span><span class="hljs-variable">%E3</span><span class="hljs-variable">%80</span><span class="hljs-variable">%82</span><span class="hljs-punctuation">,</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%89</span><span class="hljs-variable">%80</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%BB</span><span class="hljs-variable">%A5</span><span class="hljs-variable">%E9</span><span class="hljs-variable">%9</span>D<span class="hljs-variable">%9</span>E<span class="hljs-variable">%E9</span><span class="hljs-variable">%80</span><span class="hljs-variable">%92</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%BD</span><span class="hljs-variable">%92</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%80</span><span class="hljs-variable">%9</span>D<span class="hljs-variable">%E6</span><span class="hljs-variable">%83</span><span class="hljs-variable">%B3</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%BA</span><span class="hljs-variable">%EF</span><span class="hljs-variable">%BC</span><span class="hljs-variable">%8</span>C<span class="hljs-variable">%E5</span><span class="hljs-variable">%B0</span><span class="hljs-variable">%86</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%95</span><span class="hljs-variable">%B0</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%BB</span><span class="hljs-variable">%84</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%AD</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%9</span>A<span class="hljs-variable">%84</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%9</span>B<span class="hljs-variable">%B8</span><span class="hljs-variable">%E9</span><span class="hljs-variable">%82</span><span class="hljs-variable">%BB</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%85</span><span class="hljs-variable">%83</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%B4</span><span class="hljs-variable">%A0</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%A4</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%A4</span><span class="hljs-variable">%E9</span><span class="hljs-variable">%85</span><span class="hljs-variable">%8</span>D<span class="hljs-variable">%E5</span><span class="hljs-variable">%AF</span><span class="hljs-variable">%B9</span><span class="hljs-variable">%E3</span><span class="hljs-variable">%80</span><span class="hljs-variable">%82</span><span class="hljs-variable">%20</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%94</span><span class="hljs-variable">%A8merge</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%87</span><span class="hljs-variable">%BD</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%95</span><span class="hljs-variable">%B0</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%B0</span><span class="hljs-variable">%86</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%BB</span><span class="hljs-variable">%96</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%BB</span><span class="hljs-variable">%AC</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%8</span>E<span class="hljs-variable">%92</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%BA</span><span class="hljs-variable">%8</span>F<span class="hljs-variable">%EF</span><span class="hljs-variable">%BC</span><span class="hljs-variable">%8</span>C<span class="hljs-variable">%E6</span><span class="hljs-variable">%9</span>E<span class="hljs-variable">%84</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%88</span><span class="hljs-variable">%90</span>n<span class="hljs-variable">%2</span>F<span class="hljs-number">2</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%BB</span><span class="hljs-variable">%84</span><span class="hljs-variable">%E9</span><span class="hljs-variable">%95</span><span class="hljs-variable">%BF</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%BA</span><span class="hljs-variable">%A6</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%BA2</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%9</span>A<span class="hljs-variable">%84</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%8</span>E<span class="hljs-variable">%92</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%BA</span><span class="hljs-variable">%8</span>F<span class="hljs-variable">%E5</span><span class="hljs-variable">%A5</span><span class="hljs-variable">%BD</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%9</span>A<span class="hljs-variable">%84</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%AD</span><span class="hljs-variable">%90</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%95</span><span class="hljs-variable">%B0</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%BB</span><span class="hljs-variable">%84</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%AE</span><span class="hljs-variable">%B5</span><span class="hljs-variable">%EF</span><span class="hljs-variable">%BC</span><span class="hljs-variable">%8</span>C<span class="hljs-variable">%E7</span><span class="hljs-variable">%84</span><span class="hljs-variable">%B6</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%90</span><span class="hljs-variable">%8</span>E<span class="hljs-variable">%E5</span><span class="hljs-variable">%86</span><span class="hljs-variable">%8</span>D<span class="hljs-variable">%E5</span><span class="hljs-variable">%B0</span><span class="hljs-variable">%86</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%BB</span><span class="hljs-variable">%96</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%BB</span><span class="hljs-variable">%AC</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%8</span>E<span class="hljs-variable">%92</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%BA</span><span class="hljs-variable">%8</span>F<span class="hljs-variable">%E6</span><span class="hljs-variable">%88</span><span class="hljs-variable">%90</span><span class="hljs-variable">%E9</span><span class="hljs-variable">%95</span><span class="hljs-variable">%BF</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%BA</span><span class="hljs-variable">%A6</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%BA4</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%9</span>A<span class="hljs-variable">%84</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%AD</span><span class="hljs-variable">%90</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%95</span><span class="hljs-variable">%B0</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%BB</span><span class="hljs-variable">%84</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%AE</span><span class="hljs-variable">%B5</span><span class="hljs-variable">%EF</span><span class="hljs-variable">%BC</span><span class="hljs-variable">%8</span>C<span class="hljs-variable">%E5</span><span class="hljs-variable">%A6</span><span class="hljs-variable">%82</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%AD</span><span class="hljs-variable">%A4</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%BB</span><span class="hljs-variable">%A7</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%BB</span><span class="hljs-variable">%AD</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%8</span>B<span class="hljs-variable">%E5</span><span class="hljs-variable">%8</span>E<span class="hljs-variable">%BB</span><span class="hljs-variable">%EF</span><span class="hljs-variable">%BC</span><span class="hljs-variable">%8</span>C<span class="hljs-variable">%E7</span><span class="hljs-variable">%9</span>B<span class="hljs-variable">%B4</span><span class="hljs-variable">%E8</span><span class="hljs-variable">%87</span><span class="hljs-variable">%B3</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%95</span><span class="hljs-variable">%B4</span><span class="hljs-variable">%E4</span><span class="hljs-variable">%B8</span><span class="hljs-variable">%AA</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%95</span><span class="hljs-variable">%B0</span><span class="hljs-variable">%E7</span><span class="hljs-variable">%BB</span><span class="hljs-variable">%84</span><span class="hljs-variable">%E6</span><span class="hljs-variable">%8</span>E<span class="hljs-variable">%92</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%A5</span><span class="hljs-variable">%BD</span><span class="hljs-variable">%E5</span><span class="hljs-variable">%BA</span><span class="hljs-variable">%8</span>F<span class="hljs-variable">%E3</span><span class="hljs-variable">%80</span><span class="hljs-variable">%82</span>)<br><br>#### every element is same<br><br>- [还是O(nlogn)](https://stackoverflow.com/questions/<span class="hljs-number">66921626</span>/running-time-of-merge-sort-all-elements-are-identical)<br><br>### space complexity<br><br>- ![image<span class="hljs-number">-20221117230415591</span>](https://raw.githubusercontent.com/pinkyrie/pic/main/<span class="hljs-number">202211172318365</span>.png)<br><br>- O(n)<br><br>## redix sort<br><br>- [animation](https://yongdanielliang.github.io/animation/web/RadixSort.html)<br><br>- 次位优先 （least significant digit first<br><br>  ![image<span class="hljs-number">-20221027144856339</span>](https://raw.githubusercontent.com/pinkyrie/pic/main/<span class="hljs-number">202211152309963</span>.png)<br><br>- ![image<span class="hljs-number">-20221112231135913</span>](https://raw.githubusercontent.com/pinkyrie/pic/main/<span class="hljs-number">202211152309253</span>.png)<br><br>- ![image<span class="hljs-number">-20221119214322667</span>](https://raw.githubusercontent.com/pinkyrie/pic/main/<span class="hljs-number">202211192143157</span>.png)<br><br>## heap sort<br><br>- heap可以用priority queue实现<br>- Heapsort<span class="hljs-punctuation">,</span> presented in Chapter <span class="hljs-number">6</span><span class="hljs-punctuation">,</span> sorts n numbers in place in O(n lg n) time. It uses an important data structure<span class="hljs-punctuation">,</span> called a heap<span class="hljs-punctuation">,</span> with which we can also implement a priority queue.<br>- Using this model<span class="hljs-punctuation">,</span> we prove a lower bound of Ω(n lg n) on the worst-case running time of any comparison sort on n inputs<span class="hljs-punctuation">,</span> thus showing that heapsort <span class="hljs-keyword">and</span> merge sort are asymptotically optimal comparison sorts.<br><br>堆总是一棵完全二叉树。<br><br>[建堆演示](https://visualgo.net/zh/heap?slide<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<br><br>[建堆代码](https://blog.csdn.net/u<span class="hljs-number">010711495</span>/article/details/<span class="hljs-number">117386069</span>)<br><br>- ![image<span class="hljs-number">-20221110220027078</span>](https://raw.githubusercontent.com/pinkyrie/pic/main/<span class="hljs-number">202211152309584</span>.png)<br><br>- [堆的左子树的结点个数的限制](https://cs.stackexchange.com/questions/<span class="hljs-number">141748</span>/how-is-the-reccurence-of-<span class="hljs-keyword">max</span>-heapify-tn-t<span class="hljs-number">2</span>n<span class="hljs-number">-3</span>-theta<span class="hljs-number">1</span>)<br><br>- 计算父节点或者左右子节点的时候*<span class="hljs-number">2</span> 或/<span class="hljs-number">2</span> 可以用计算机的shift bit进行计算<br><br>#### <span class="hljs-keyword">max</span>-heapify的时间复杂度（粗略的O 和 更贴合的Ω）<br><br>We can compute a simple upper bound on the running time of BUILD-MAX- HEAP as follows. Each <span class="hljs-keyword">call</span> <span class="hljs-keyword">to</span> MAX-HEAPIFY costs O(nlgn) time<span class="hljs-punctuation">,</span> <span class="hljs-keyword">and</span> BUILD- MAX-HEAP makes O(n) such calls. Thus<span class="hljs-punctuation">,</span> the running time is O(nlgn). This upper bound<span class="hljs-punctuation">,</span> though correct<span class="hljs-punctuation">,</span> is not asymptotically tight.<br><br>We can derive a tighter bound by observing that the time for MAX-HEAPIFY torun at a node varies with the height of the node in the tree<span class="hljs-punctuation">,</span> <span class="hljs-keyword">and</span> the heights of most nodes are small. Our tighter analysis relies on the properties that an  n-element heap has height <br><br>![image<span class="hljs-number">-20221112091149489</span>](https://raw.githubusercontent.com/pinkyrie/pic/main/<span class="hljs-number">202211152309702</span>.png)<br><br>![image<span class="hljs-number">-20221112203441025</span>](https://raw.githubusercontent.com/pinkyrie/pic/main/<span class="hljs-number">202211152309638</span>.png)<br><br>![image<span class="hljs-number">-20221112203427151</span>](https://raw.githubusercontent.com/pinkyrie/pic/main/<span class="hljs-number">202211152309827</span>.png)<br><br>[叶子节点开始的下标](https://blog.csdn.net/feliciafay/article/details/<span class="hljs-number">12869179</span>)<br><br>- 只需要求出叶子节点上一层的结点个数 大概为总结点个数的一半<br>- ![image<span class="hljs-number">-20221112092704508</span>](https://raw.githubusercontent.com/pinkyrie/pic/main/<span class="hljs-number">202211152310023</span>.png)<br>- ![image<span class="hljs-number">-20221112094046683</span>](https://raw.githubusercontent.com/pinkyrie/pic/main/<span class="hljs-number">202211152310505</span>.png)<br><br>- ![image<span class="hljs-number">-20221112203126918</span>](https://raw.githubusercontent.com/pinkyrie/pic/main/<span class="hljs-number">202211152310044</span>.png)<br><br><br><br>### time complexity <br><br>- best case(all elements are identical) [proof](https://cs.stackexchange.com/questions/<span class="hljs-number">138432</span>/running-time-of-heap-sort-when-all-number-are-identical)<br><br>  - The best case for heapsort would happen when all elements in the list <span class="hljs-keyword">to</span> be sorted are identical. In such a case<span class="hljs-punctuation">,</span> for &#x27;n&#x27; number of nodes-<br><br>  - Removing each node from the heap would take only a <span class="hljs-keyword">constant</span> runtime<span class="hljs-punctuation">,</span> O(<span class="hljs-number">1</span>). There would be no need <span class="hljs-keyword">to</span> bring any node down <span class="hljs-keyword">or</span> bring <span class="hljs-keyword">max</span> valued node up<span class="hljs-punctuation">,</span> as all items are identical.<br><br>  - Since we do this for every node<span class="hljs-punctuation">,</span> the total number of moves would be n * O(<span class="hljs-number">1</span>).<br><br>    Therefore<span class="hljs-punctuation">,</span> the runtime in the best case would be O(n).<br><br>### code <span class="hljs-keyword">c</span>++<br><br>[reference](https://www.geeksforgeeks.org/cpp-program-for-heap-sort/)<br><br>## quick sort<br><br>- ![image<span class="hljs-number">-20221112205348607</span>](https://raw.githubusercontent.com/pinkyrie/pic/main/<span class="hljs-number">202211152310677</span>.png)<br><br>### features:<br><br>-  divide-<span class="hljs-keyword">and</span>-conquer<br><br>  - <span class="hljs-number">1</span>. Divide: Partition the list.To partition the list<span class="hljs-punctuation">,</span> we first choose some element from the list for which we hope about half the elements will come before <span class="hljs-keyword">and</span> half after. Call this element the pivot. Then we partition the elements so that all those with values less than the pivot come in <span class="hljs-keyword">one</span> sublist <span class="hljs-keyword">and</span> all those with greater values come in another. <span class="hljs-number">2</span>. Recursion: Recursively sort the sublists separately. <span class="hljs-number">3</span>. Conquer: Put the sorted sublists together.<br><br>  - <span class="hljs-number">3</span> steps<br><br>  - ![image<span class="hljs-number">-20221112205710744</span>](https://raw.githubusercontent.com/pinkyrie/pic/main/<span class="hljs-number">202211152310063</span>.png)<br><br>    <br>  <br>  ![image<span class="hljs-number">-20221112205746761</span>](https://raw.githubusercontent.com/pinkyrie/pic/main/<span class="hljs-number">202211152310327</span>.png)<br><br>### partitioning: <br><br>- ![image<span class="hljs-number">-20221112211056367</span>](https://raw.githubusercontent.com/pinkyrie/pic/main/<span class="hljs-number">202211152310514</span>.png)<br><br>- The running time of quicksort depends on whether the partitioning is balanced <span class="hljs-keyword">or</span> unbalanced<span class="hljs-punctuation">,</span> which in turn depends on which elements are used for partitioning. If the partitioning is balanced<span class="hljs-punctuation">,</span> the algorithm runs asymptotically as <span class="hljs-keyword">fast</span> as merge sort. If the partitioning is unbalanced<span class="hljs-punctuation">,</span> however<span class="hljs-punctuation">,</span> it can run asymptotically as slowly as insertion sort.<br><br>#### wost case partition<br><br>- ![image<span class="hljs-number">-20221112212238759</span>](https://raw.githubusercontent.com/pinkyrie/pic/main/<span class="hljs-number">202211152310967</span>.png)<br><br>#### bast case partition<br><br>- ![image<span class="hljs-number">-20221112212327125</span>](https://raw.githubusercontent.com/pinkyrie/pic/main/<span class="hljs-number">202211152310289</span>.png)<br><br>### code<br><br>```<span class="hljs-keyword">c</span>++<br>template &lt;class Comparable&gt;<br>void choosePivot( vector&lt;Comparable&gt; &amp;a<span class="hljs-punctuation">,</span> int first<span class="hljs-punctuation">,</span> int last ) &#123;<br>srand(time(NULL))<span class="hljs-comment">;</span><br>int random <span class="hljs-operator">=</span> first + rand() % (last - first)<span class="hljs-comment">;</span><br>objectSwap(a[random]<span class="hljs-punctuation">,</span> a[first])<span class="hljs-comment">;//随机找到第一个数字作为pivot</span><br>&#125;<br><br>template &lt;class Comparable&gt;<br>void partition( vector&lt;Comparable&gt; &amp;a<span class="hljs-punctuation">,</span> int first<span class="hljs-punctuation">,</span> int last<span class="hljs-punctuation">,</span> int &amp;pivotIndex )&#123;<br>choosePivot(a<span class="hljs-punctuation">,</span> first<span class="hljs-punctuation">,</span> last)<span class="hljs-comment">;</span><br>int i <span class="hljs-operator">=</span> first<span class="hljs-punctuation">,</span> j <span class="hljs-operator">=</span> last<span class="hljs-comment">;</span><br>while (i &lt;<span class="hljs-operator">=</span> j) &#123;<br>while (i &lt;<span class="hljs-operator">=</span> j &amp;&amp; a[i] &lt;<span class="hljs-operator">=</span> a[pivotIndex])<br>i++<span class="hljs-comment">;</span><br>while (i &lt;<span class="hljs-operator">=</span> j &amp;&amp; a[j] &gt; a[pivotIndex])<br>j--<span class="hljs-comment">;</span><br>if (i &lt; j) &#123;<br>objectSwap(a[j]<span class="hljs-punctuation">,</span> a[i])<span class="hljs-comment">;</span><br>i++<span class="hljs-comment">;</span><br>j--<span class="hljs-comment">;</span><br>&#125;<br>&#125;<br>objectSwap(a[pivotIndex]<span class="hljs-punctuation">,</span> a[j])<span class="hljs-comment">;</span><br>pivotIndex <span class="hljs-operator">=</span> j<span class="hljs-comment">;</span><br><span class="hljs-comment"></span><br>&#125;<br><br>template &lt;class Comparable&gt;<br>void quicksort( vector&lt;Comparable&gt; &amp;a<span class="hljs-punctuation">,</span> int first<span class="hljs-punctuation">,</span> int last ) &#123;<br>if (last &lt;<span class="hljs-operator">=</span> first)<br>return<span class="hljs-comment">;</span><br>if (first &lt; last) &#123;<br>int pivotIndex <span class="hljs-operator">=</span> first<span class="hljs-comment">;</span><br>partition(a<span class="hljs-punctuation">,</span> first<span class="hljs-punctuation">,</span> last<span class="hljs-punctuation">,</span> pivotIndex)<span class="hljs-comment">;</span><br>quicksort(a<span class="hljs-punctuation">,</span> first<span class="hljs-punctuation">,</span> pivotIndex - <span class="hljs-number">1</span>)<span class="hljs-comment">;</span><br>quicksort(a<span class="hljs-punctuation">,</span> pivotIndex + <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> last)<span class="hljs-comment">;</span><br>&#125;<br>&#125;<br><br>template &lt;class Comparable&gt;<br>void quicksort( vector&lt;Comparable&gt; &amp;a ) &#123;<br>int first <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>int last <span class="hljs-operator">=</span> a.size() - <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>quicksort(a<span class="hljs-punctuation">,</span> first<span class="hljs-punctuation">,</span> last)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="比较次数-x2F-移动次数"><a href="#比较次数-x2F-移动次数" class="headerlink" title="比较次数&#x2F;移动次数"></a>比较次数&#x2F;移动次数</h3><ul><li><a href="https://blog.csdn.net/XueWang1/article/details/78118758">compare times</a></li></ul><h3 id="time-complexity-1"><a href="#time-complexity-1" class="headerlink" title="time complexity"></a>time complexity</h3><h4 id="worst-case"><a href="#worst-case" class="headerlink" title="worst case"></a>worst case</h4><ul><li><p><a href="https://www.geeksforgeeks.org/when-does-the-worst-case-of-quicksort-occur/">reference</a></p></li><li><p>\1) Array is already sorted in the same order.<br>\2) Array is already sorted in reverse order.<br>\3) All elements are the same (a special case of cases 1 and 2) </p></li><li><p>演示比较次数和交换次数（worst case）<a href="https://iq.opengenus.org/worst-case-of-quick-sort/">reference</a></p></li></ul><h3 id="space-complexity"><a href="#space-complexity" class="headerlink" title="space complexity"></a>space complexity</h3><ul><li>Choose a pivot somehow.</li><li>Partition the array into two parts (smaller than the pivot, larger than the pivot).</li><li>Recursively sort the first part, then recursively sort the second part.</li></ul><p>Each recursive call uses O(1) words in local variables, hence the total space complexity is proportional to the height of the recursion tree.</p><p>The height of the recursion tree is always at least Ω(log⁡n), hence this is a <em>lower bound</em> on the space complexity. If you choose the pivot at random or using a good heuristic, then the recursion tree will have height O(log⁡n), and so the space complexity is Θ(logn)Θ(log⁡n). If the pivot can be chosen adversarially, you can cause the recursion tree to have height Θ(n)Θ(n), causing the worst-case space complexity to be Θ(n).</p><h2 id="decision-tree-model"><a href="#decision-tree-model" class="headerlink" title="decision tree model"></a>decision tree model</h2><p>- </p><h2 id="递归树推算递归的时间复杂度"><a href="#递归树推算递归的时间复杂度" class="headerlink" title="递归树推算递归的时间复杂度"></a>递归树推算递归的时间复杂度</h2><ul><li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152310697.png" alt="image-20221113103554258"></p></li><li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211152310442.png" alt="image-20221113103710337"></p></li></ul><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211192134408.png" alt="image-20221119213401509"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1-n的数字中一共出现了多少个1</title>
    <link href="/2022/10/16/leetcode/"/>
    <url>/2022/10/16/leetcode/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/submissions/">题目</a></p><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="数字-gt-字符串"><a href="#数字-gt-字符串" class="headerlink" title="数字-&gt;字符串"></a>数字-&gt;字符串</h3><ul><li>统计所有1出现的次数 &#x3D; 每一位上1出现次数的和</li><li>拆成每个数位单独进行计算</li></ul><h3 id="sidenote：数字和字符串的互换"><a href="#sidenote：数字和字符串的互换" class="headerlink" title="sidenote：数字和字符串的互换"></a>sidenote：数字和字符串的互换</h3><ul><li><a href="https://stackoverflow.com/questions/11830979/c-strcpy-function-copies-null">strcpy会把string的结尾0也复制过去</a></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/10/16/leetcode-1/"/>
    <url>/2022/10/16/leetcode-1/</url>
    
    <content type="html"><![CDATA[<h2 id="十种常见排序算法可以分为两大类："><a href="#十种常见排序算法可以分为两大类：" class="headerlink" title="十种常见排序算法可以分为两大类："></a>十种常见排序算法可以分为两大类：</h2><p><a href="https://www.jianshu.com/p/796f23a96596">reference</a></p><ul><li><strong>比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</li><li><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</li></ul><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/08/26/springboot/"/>
    <url>/2022/08/26/springboot/</url>
    
    <content type="html"><![CDATA[<h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><ul><li>新建spring initializer 选择java18 </li><li>注意新建文件的目录需要再入口程序的同级目录<ul><li>入口程序是xx application</li></ul></li></ul><h3 id="jar包生成"><a href="#jar包生成" class="headerlink" title="jar包生成"></a>jar包生成</h3><ul><li>可以打包idea项目成单个直接在命令行运行的程序（微服务 分离成小的板块）</li><li></li></ul><h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><ul><li>实现页面的请求 和 页面行为<ul><li><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220826100556038.png" alt="image-20220826100556038"></li></ul></li></ul><h3 id="启动器"><a href="#启动器" class="headerlink" title="启动器"></a>启动器</h3><ul><li>实现各种功能</li><li></li></ul><h2 id="javabean是什么"><a href="#javabean是什么" class="headerlink" title="javabean是什么"></a>javabean是什么</h2><ul><li>简单笼统的说就是一个类，一个可复用的类。<br>javaBean在MVC设计模型中是model，又称模型层，在一般的程序中，我们称它为数据层，就是用来设置数据的属性和一些行为，然后我会提供获取属性和设置属性的get&#x2F;set方法JavaBean是一种JAVA语言写成的可重用组件。为写成JavaBean，类必须是具体的和公共的，并且具有无参数的构造器。JavaBean<br>通过提供符合一致性设计模式的公共方法将内部域暴露成员属性。众所周知，属性名称符合这种模式，其他Java<br>类可以通过自身机制发现和操作这些JavaBean 属性。　<br>用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以用java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。用户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。<br>　　JavaBean可分为两种：一种是有用户界面（UI，User<br>Interface）的JavaBean；还有一种是没有用户界面，主要负责处理事务（如数据运算，操纵数据库）的JavaBean。JSP通常访问的是后一种JavaBean。</li><li><a href="https://zhuanlan.zhihu.com/p/410730923">more details</a></li></ul><h2 id="spring注解"><a href="#spring注解" class="headerlink" title="spring注解"></a>spring注解</h2><p>- </p><h2 id="spring配置文件"><a href="#spring配置文件" class="headerlink" title="spring配置文件"></a>spring配置文件</h2><ul><li><p>yaml标记语言的形式</p></li><li><p><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220826112003830.png" alt="image-20220826112003830"></p></li><li><p>properties只保存键值对</p></li><li><p>对缩进是敏感的</p></li><li><p>yaml可以直接对实体类赋值</p><ul><li><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220826130145968.png" alt="image-20220826130145968"></li><li>yaml的类对应pojo的configuration的类</li><li><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220826130315657.png" alt="image-20220826130315657"></li><li><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220826130914861.png" alt="image-20220826130914861"></li><li>用占位符表达式去填值</li></ul></li></ul><h2 id="JSR303数据校验"><a href="#JSR303数据校验" class="headerlink" title="JSR303数据校验"></a>JSR303数据校验</h2><ul><li><p><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220826132011197.png" alt="image-20220826132011197"></p></li><li><p>表示这个属性必须经过校验 如果不是合法格式就会报错</p></li></ul><h2 id="静态资源放置目录"><a href="#静态资源放置目录" class="headerlink" title="静态资源放置目录"></a>静态资源放置目录</h2><ul><li><p><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220826201709867.png" alt="image-20220826201709867"></p></li><li><p>通过controller跳到首页</p></li><li><p><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220826203301788.png" alt="image-20220826203301788"></p></li><li><p>templates目录下的所有界面只能通过controller来跳转 而且需要模板引擎</p></li><li><p><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220826205926854.png" alt="image-20220826205926854"></p></li><li><p><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220826205940428.png" alt="image-20220826205940428"></p></li><li><p>thymeleaf <a href="https://www.thymeleaf.org/documentation.html">doc</a></p></li></ul><h2 id="功能-登录实现-x2F-拦截器"><a href="#功能-登录实现-x2F-拦截器" class="headerlink" title="功能-登录实现&#x2F;拦截器"></a>功能-登录实现&#x2F;拦截器</h2><p>- </p><h2 id="crud"><a href="#crud" class="headerlink" title="crud"></a>crud</h2><ul><li><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220827101718157.png" alt="image-20220827101718157"></li></ul><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><ul><li><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220827131058505.png" alt="image-20220827131058505"></li></ul><h2 id="ModelAndView共有三个作用"><a href="#ModelAndView共有三个作用" class="headerlink" title="ModelAndView共有三个作用"></a><strong>ModelAndView共有三个作用</strong></h2><p>其一：ModelAndView 实现后台与前端页面数据交互；</p><p>其二：可以用于重定向与转发到指定页面，</p><p>其三：可以保存数据继而渲染到页面</p><p><a href="http://localhost:8080/login">http://localhost:8080/login</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/08/25/note_mybatis/"/>
    <url>/2022/08/25/note_mybatis/</url>
    
    <content type="html"><![CDATA[<h2 id="navicat"><a href="#navicat" class="headerlink" title="navicat"></a>navicat</h2><h3 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h3><h3 id="建立数据库"><a href="#建立数据库" class="headerlink" title="建立数据库"></a>建立数据库</h3><h3 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h3><h2 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h2><h3 id="导入dependency"><a href="#导入dependency" class="headerlink" title="导入dependency"></a>导入dependency</h3><p>- </p><h4 id="mysql-connector版本问题"><a href="#mysql-connector版本问题" class="headerlink" title="mysql connector版本问题"></a>mysql connector版本问题</h4><ul><li>注意idea中的mysql版本和mysql的本地查看的版本不是一个概念</li><li><a href="https://stackoverflow.com/questions/60238703/how-to-determine-mysql-mariadb-version-for-maven-dependency">reference</a></li><li>The one specified in <a href="https://stackoverflow.com/questions/tagged/maven">maven</a> is the client version while one the you checked with <code>mysql -V</code> is the server version. The JDBC client version does not needed to be exactly matched with the server version.</li></ul><h3 id="mybatis-configuration-xml"><a href="#mybatis-configuration-xml" class="headerlink" title="mybatis configuration xml"></a>mybatis configuration xml</h3><ul><li><p><a href="https://mybatis.org/mybatis-3/zh/configuration.html">reference</a></p><ul><li><p>​          如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器，因为          Spring 模块会使用自带的管理器来覆盖前面的配置。        </p><p>​          这两种事务管理器类型都不需要设置任何属性。它们其实是类型别名，换句话说，你可以用          TransactionFactory 接口实现类的全限定名或类型别名代替它们。</p></li></ul></li></ul><h4 id="sidenote"><a href="#sidenote" class="headerlink" title="sidenote:"></a>sidenote:</h4><ul><li><p>All HTML documents must start with a <code>&lt;!DOCTYPE&gt;</code> declaration.</p><p>The declaration is not an HTML tag. It is an “information” to the browser about what document type to expect.</p></li><li></li></ul><h3 id="获取sqlsession实例-创建factory"><a href="#获取sqlsession实例-创建factory" class="headerlink" title="获取sqlsession实例-创建factory"></a>获取sqlsession实例-创建factory</h3><ul><li>加载资源并辅助执行sql语句</li><li>等价于jdbc的connection</li></ul><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><h4 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h4><h4 id="dao接口"><a href="#dao接口" class="headerlink" title="dao接口"></a>dao接口</h4><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/08/25/log/"/>
    <url>/2022/08/25/log/</url>
    
    <content type="html"><![CDATA[<h2 id="8-24"><a href="#8-24" class="headerlink" title="8.24"></a>8.24</h2><ul><li>监听器和过滤器的功能学习完毕<ul><li>（实现）应用于jsp的编码设置可以不用每一个都character encoding（貌似这样子还没有效果）</li><li>（待实现）识别登录用户并存入session然后转到成功登录界面</li></ul></li><li>【解决】引入jstl标签问题（需要reload maven项目）了解jakarta包的版本适配问题</li><li>【未解决】navicat破解版 </li><li>【未解决】数据库设计（满足范式的设计，虚表，多表联查）</li></ul><h2 id="8-25"><a href="#8-25" class="headerlink" title="8.25"></a>8.25</h2><ul><li>javaweb的基本操作可以实现 搭建完毕jsp和servlet</li><li>（实现）登录后的转发请求</li><li>（修正）使用springboot和mybatis优化项目 不使用原始的javaweb（为了用配置文件简洁性取代繁杂代码量）</li><li>【解决】navicat的破解和创建 连接数据库</li><li>【未解决】mybatis的测试还未尝试</li><li>【为结局】springboot搭建以及适配mybatis</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/08/21/Untitled/"/>
    <url>/2022/08/21/Untitled/</url>
    
    <content type="html"><![CDATA[<h2 id="html文法"><a href="#html文法" class="headerlink" title="html文法"></a>html文法</h2><ul><li><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220821154415128.png" alt="image-20220821154415128"></li></ul><h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><ul><li>标签选择器</li><li>类选择器</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>post</title>
    <link href="/2022/08/16/post-3/"/>
    <url>/2022/08/16/post-3/</url>
    
    <content type="html"><![CDATA[<h2 id="qt-输入的validator"><a href="#qt-输入的validator" class="headerlink" title="qt 输入的validator"></a>qt 输入的validator</h2><ul><li>Qt provides three built-in validator classes: <strong>QIntValidator</strong>, <strong>QDoubleValidator</strong>, and <strong>QRegExpValidator</strong>. Here we use a <strong>QRegExpValidator</strong> with the regular expression “[A-Za-z][1-9][0-9]{0,2}”, which means: Allow one uppercase or lowercase letter, followed by one digit in the range 1 to 9, followed by zero, one, or two digits each in the range 0 to 9. </li><li>如果是某个窗口的child it will be deleted automatically when its parent is deleted.</li></ul><h2 id="ui的导入方式"><a href="#ui的导入方式" class="headerlink" title="ui的导入方式"></a>ui的导入方式</h2><ul><li>Dynamic dialogs are dialogs that are created from Qt Designer .ui files at run-time. Instead of converting the .ui file to C++ code using uic, we can load the file at run-time using the QUiLoader class:</li></ul><h2 id="qt-xml"><a href="#qt-xml" class="headerlink" title="qt xml"></a>qt xml</h2><h4 id="xml是什么"><a href="#xml是什么" class="headerlink" title="xml是什么"></a>xml是什么</h4><ul><li><p>Extensible Markup Language file</p></li><li><p>For reading or writing XML documents iteratively (SAX), we recommend using  Qt Core’s <a href="https://doc.qt.io/qt-5/qxmlstreamreader.html">QXmlStreamReader</a> and <a href="https://doc.qt.io/qt-5/qxmlstreamwriter.html">QXmlStreamWriter</a> classes. The classes are both easier to use and more compliant with the XML standard.</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>post</title>
    <link href="/2022/08/16/post-2/"/>
    <url>/2022/08/16/post-2/</url>
    
    <content type="html"><![CDATA[<h2 id="range-based-for-loops"><a href="#range-based-for-loops" class="headerlink" title="range-based for-loops"></a>range-based for-loops</h2><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3853.htm">reference</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> elem : range) <span class="hljs-comment">//equals to auto elem = *__begin</span><br></code></pre></td></tr></table></figure><ul><li><p>不是好的写法 但经常被误用</p><ul><li><pre><code class="hljs">* It might not compile - for example, unique_ptr elements aren&#39;t copyable.        This is problematic both for users who won&#39;t understand the resulting        compiler errors, and for users writing generic code that&#39;ll happily        compile until someone instantiates it for movable-only elements.* It might misbehave at runtime - for example, &quot;elem = val;&quot; will modify        the copy, but not the original element in the range. Additionally,        &amp;elem will be invalidated after each iteration.* It might be inefficient - for example, unnecessarily copying std::string.</code></pre></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-位运算</title>
    <link href="/2022/08/11/post-1/"/>
    <url>/2022/08/11/post-1/</url>
    
    <content type="html"><![CDATA[<h2 id="basics-位运算"><a href="#basics-位运算" class="headerlink" title="basics-位运算"></a>basics-位运算</h2><p><a href="https://www.runoob.com/w3cnote/bit-operation.html">reference</a></p><h3 id="与运算"><a href="#与运算" class="headerlink" title="与运算"></a>与运算</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>&amp;<span class="hljs-number">0</span>=<span class="hljs-number">0</span> <span class="hljs-number">0</span>&amp;<span class="hljs-number">1</span>=<span class="hljs-number">0</span> <span class="hljs-number">1</span>&amp;<span class="hljs-number">0</span>=<span class="hljs-number">0</span> <span class="hljs-number">1</span>&amp;<span class="hljs-number">1</span>=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ul><li><p>1）清零</p><p>如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。</p><p>2）取一个数的指定位</p><p>比如取数 X&#x3D;1010 1110 的低4位，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y&#x3D;0000 1111，然后将X与Y进行按位与运算（X&amp;Y&#x3D;0000 1110）即可得到X的指定位。</p><p>3）判断奇偶</p><p>只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((a &amp; 1) &#x3D;&#x3D; 0)代替if (a % 2 &#x3D;&#x3D; 0)来判断a是不是偶数。</p></li></ul><h3 id="或运算"><a href="#或运算" class="headerlink" title="或运算"></a>或运算</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>|<span class="hljs-number">0</span>=<span class="hljs-number">0</span>  <span class="hljs-number">0</span>|<span class="hljs-number">1</span>=<span class="hljs-number">1</span>  <span class="hljs-number">1</span>|<span class="hljs-number">0</span>=<span class="hljs-number">1</span>  <span class="hljs-number">1</span>|<span class="hljs-number">1</span>=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ul><li><p>1）常用来对一个数据的某些位设置为1</p><p>比如将数 X&#x3D;1010 1110 的低4位设置为1，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y&#x3D;0000 1111，然后将X与Y进行按位或运算（X|Y&#x3D;1010 1111）即可得到。</p></li></ul><h3 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>^<span class="hljs-number">0</span>=<span class="hljs-number">0</span>  <span class="hljs-number">0</span>^<span class="hljs-number">1</span>=<span class="hljs-number">1</span>  <span class="hljs-number">1</span>^<span class="hljs-number">0</span>=<span class="hljs-number">1</span>  <span class="hljs-number">1</span>^<span class="hljs-number">1</span>=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><ul><li><p>1、交换律</p></li><li><p>2、结合律 (a^b)^c &#x3D;&#x3D; a^(b^c)</p></li><li><p>3、对于任何数x，都有 x^x&#x3D;0，x^0&#x3D;x</p></li><li><p>4、自反性: a^b^b&#x3D;a^0&#x3D;a;</p></li><li><p>1）翻转指定位</p><p>比如将数 X&#x3D;1010 1110 的低4位进行翻转，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y&#x3D;0000 1111，然后将X与Y进行异或运算（X^Y&#x3D;1010 0001）即可得到。</p><p>2）与0相异或值不变</p><p>例如：1010 1110 ^ 0000 0000 &#x3D; 1010 1110</p><p>3）交换两个数</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">void</span> Swap(int &amp;a, int &amp;b)&#123;<br>   <span class="hljs-attribute">if</span> (a != b)&#123;<br>     <span class="hljs-attribute">a</span><span class="hljs-regexp"> ^=</span> b;<br>     <span class="hljs-attribute">b</span><span class="hljs-regexp"> ^=</span> a;<br>     <span class="hljs-attribute">a</span><span class="hljs-regexp"> ^=</span> b;<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="取反运算"><a href="#取反运算" class="headerlink" title="取反运算"></a>取反运算</h3><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><ul><li><pre><code class="hljs">给出两个32位的整数N和M，以及两个二进制位的位置i和j。写一个方法来使得N中的第i到j位等于M（M会是N中从第i为开始到第j位的子串）样例：输入: N=(10000000000)2 M=(10101)2 i=2 j=6输出: N=(10001010100)2输入: N=(10000000000)2 M=(11111)2 i=2 j=6输出: N=(10001111100)2</code></pre></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>post</title>
    <link href="/2022/08/10/note_javaweb/"/>
    <url>/2022/08/10/note_javaweb/</url>
    
    <content type="html"><![CDATA[<h2 id="下载maven镜像"><a href="#下载maven镜像" class="headerlink" title="下载maven镜像"></a>下载maven镜像</h2><p><a href="https://maven.apache.org/guides/mini/guide-mirror-settings.html">reference</a></p><ul><li>镜像的作用：指定了下载的来源location</li><li>通常是在maven的 <code>settings.xml</code> 文件中配置</li><li>注意：很多mirror配置都没有mirrorOf 这个不可以省略 是指定了使用镜像仓库的ID</li></ul><p><a href="https://www.jianshu.com/p/c4f02c5bdfc7">reference</a></p><ul><li>对仓库的request进行拦截并且重定向 – mirrorOf</li></ul><p><a href="https://www.cnblogs.com/alexgl2008/p/13949291.html">reference</a></p><ul><li><p>这里，mirrorOf 配置成 <code>*</code> 就代表我们通过访问阿里云的maven仓库从而访问网路上所有的远程仓库 也就是说，我们只会从 <strong>阿里云</strong> 现有仓库下包，如果阿里云没有，我们必须手动更改配置！</p><p>因此，我们需要改成 central</p><blockquote><ul><li>如果配置成central，就代表我们访问阿里云的central仓库，就是阿里的中央库(<a href="http://central.maven.org/maven2">http://central.maven.org/maven2</a>)</li><li>如果配置成repo1，就代表通过阿里云访问<a href="http://repo1.maven.org/maven2%EF%BC%8C">http://repo1.maven.org/maven2，</a><br>阿里云和这些远程仓库之间必须可以镜像，存在一定的镜像关系。</li></ul></blockquote></li></ul><h2 id="创建maven本地仓库"><a href="#创建maven本地仓库" class="headerlink" title="创建maven本地仓库"></a>创建maven本地仓库</h2><ul><li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202208122318667.png" alt="image-20220812231801152"></li></ul><h2 id="maven作用，在idea中创建一个maven-webapp项目"><a href="#maven作用，在idea中创建一个maven-webapp项目" class="headerlink" title="maven作用，在idea中创建一个maven_webapp项目"></a>maven作用，在idea中创建一个maven_webapp项目</h2><ul><li><p>在idea中创建一个 maven web的项目 然后maven会自己进行下载</p></li><li><p>可以自动导入jar包 并且导入这个jar包所依赖的其他jar包</p></li><li><p>如果遇到dependencies not found: 可以右键单击项目-&gt;选择maven-&gt;选择reload project即可在maven目录中找到dependencies 解决问题</p></li></ul><p><a href="https://www.jetbrains.com/help/idea/2022.1/new-project-wizard.html#maven-archetype">reference</a></p><p><a href="https://www.jetbrains.com/help/idea/2022.1/new-project-wizard.html#javafx">java new project各个选项的解释</a></p><ul><li>maven的archetype分别是什么</li></ul><h3 id="资源导出失败问题"><a href="#资源导出失败问题" class="headerlink" title="资源导出失败问题"></a>资源导出失败问题</h3><ul><li>在build中<strong>配置</strong>resources</li></ul><h3 id="启动tomcat"><a href="#启动tomcat" class="headerlink" title="启动tomcat"></a>启动tomcat</h3><ul><li><a href="https://devdojo.com/devdojo/local-vs-remote-servers">选择local or remote tomcat</a><ul><li>If you are referring to a Local Server, this means that you have a  server setup on your current machine. When the server is Remote, this  just means that it is on another computer.</li></ul></li></ul><h3 id="explode-or-war"><a href="#explode-or-war" class="headerlink" title="explode or war?"></a>explode or war?</h3><p><a href="https://www.jetbrains.com/help/idea/configure-web-app-deployment.html">reference</a></p><ul><li>A Web application can be deployed to the server as an exploded directory where files and folders are presented in the file system as separate items or as a Web archive (WAR file) which contains all the required files.</li><li></li></ul><h3 id="sidenote：jar-vs-war"><a href="#sidenote：jar-vs-war" class="headerlink" title="sidenote：jar vs war"></a>sidenote：jar vs war</h3><p><a href="https://www.w3cschool.cn/article/24070619.html">reference</a></p><ul><li>jar 包全称 Java Archive ，中文名叫 java  归档文件，这是一种与平台无关的文件格式，它允许将许多文件组合成一个压缩文件（是的，jar 包就是一种压缩文件，甚至 jar  这个单词就有罐子的意思，实际上 jar 包采用的也是 zip 的压缩方式，只不过将文件后缀定义为 jar）。javaSE 程序可以打包成 jar 包。</li><li>war 包与 jar 包是很类似的，不过 war 包通常用于网站，它是一个可以直接运行的 web 模块。我们在开发 web 项目一般都会使用一个 webapp 文件夹来进行开发，这个文件夹直接放在 Tomcat 的 webapps 文件夹下就可以启动该项目了。而 war  包，就是对这个文件夹进行打包。</li></ul><h3 id="如果没有生成src和webapp文件夹"><a href="#如果没有生成src和webapp文件夹" class="headerlink" title="如果没有生成src和webapp文件夹"></a>如果没有生成src和webapp文件夹</h3><p><a href="https://blog.csdn.net/ningmengshuxiawo/article/details/107562109">reference</a></p><ul><li>maven的web.xml可以参考tomcat的webapp中的web.xml文件 然后配置同样的version（直接复制粘贴）</li><li></li></ul><h3 id="创建java目录和resources目录"><a href="#创建java目录和resources目录" class="headerlink" title="创建java目录和resources目录"></a>创建java目录和resources目录</h3><ul><li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202208132124391.png" alt="image-20220813212403394"></li></ul><h2 id="servelet导入"><a href="#servelet导入" class="headerlink" title="servelet导入"></a>servelet导入</h2><ul><li>首先可以参考tomcat的localhost:8080中的examples（发现依赖的jar包servelet-api.jar）</li><li>在maven repository中下载找到 并且下载使用量最多的</li><li>出现问题：dependency not found（解决：勾选override 覆盖idea自带的maven）<ul><li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202208141534198.png" alt="image-20220814153420246"></li><li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202208170926618.png" alt="image-20220817092612227"></li></ul></li></ul><h3 id="jarkata-servelet-vs-javax-servelet"><a href="#jarkata-servelet-vs-javax-servelet" class="headerlink" title="jarkata servelet vs javax servelet"></a>jarkata servelet vs javax servelet</h3><ul><li><strong>tomcat10中的javax.servlet-api 已经变成 jakarta.servlet-api了，与我在pom.xml里面添加的依赖不匹配</strong>，导致服务器无法实例化servlet类</li></ul><h3 id="servelet-版本对应"><a href="#servelet-版本对应" class="headerlink" title="servelet 版本对应"></a>servelet 版本对应</h3><ul><li><p><a href="https://www.cnblogs.com/tongying/p/13284140.html">reference</a></p></li><li><p>tomcat的servelet需要在web.xml中进行configure</p></li></ul><h3 id="servelet需要编写mapping"><a href="#servelet需要编写mapping" class="headerlink" title="servelet需要编写mapping"></a>servelet需要编写mapping</h3><ul><li>in pom.xml</li><li>java程序通过浏览器访问 链接web服务 所以要在web中进行注册</li><li>给一个浏览器能够访问的接口</li></ul><h4 id="servlet方法"><a href="#servlet方法" class="headerlink" title="servlet方法"></a>servlet方法</h4><ul><li><p><strong><code>void setContentType(java.lang.String type)</code>:</strong>  Sets the  content type of the response being sent to the client, if the response  has not been committed yet. The given content type may include a  character encoding specification, for example, text&#x2F;html;charset&#x3D;UTF-8.  The response’s character encoding is only set from the given content  type if this method is called before getWriter is called.</p><p>Before sending data to client (displayed by <strong>Browser</strong>  on client machine), the Servlet container informs the client browser of  what type of data is being sent now.  The data that can be sent may be  simple plain text, html form, xml form, image form of type gif or jpg,  excel sheet etc.  <strong>To send this information, the Servlet container uses response object with the method setContentType()</strong>.</p></li></ul><h3 id="servlet-context"><a href="#servlet-context" class="headerlink" title="servlet context"></a>servlet context</h3><h4 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h4><ul><li>每一个web app都会创造一个servlet context servlet可存储所有servlet的数据 从而实现共享数据</li></ul><h4 id="获取初始化参数"><a href="#获取初始化参数" class="headerlink" title="获取初始化参数"></a>获取初始化参数</h4><h3 id="httpservletResponse"><a href="#httpservletResponse" class="headerlink" title="httpservletResponse"></a>httpservletResponse</h3><ul><li>给客户端相应一些消息</li></ul><h3 id="httpservletRequest"><a href="#httpservletRequest" class="headerlink" title="httpservletRequest"></a>httpservletRequest</h3><ul><li>获取客户端传来的参数</li><li></li></ul><h4 id="download-from-browser"><a href="#download-from-browser" class="headerlink" title="download from browser"></a>download from browser</h4><p><a href="https://initialcommit.com/blog/download-file-from-web-application/">reference</a></p><ul><li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202208201929342.png" alt="image-20220820192912391"></p></li><li><p><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220820195656072.png" alt="image-20220820195656072"></p></li></ul><h4 id="验证码功能"><a href="#验证码功能" class="headerlink" title="验证码功能"></a>验证码功能</h4><ul><li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202208202013946.png" alt="image-20220820201315657"></p></li><li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202208202027451.png" alt="image-20220820202717866"></p></li></ul><h3 id="重定向的实现"><a href="#重定向的实现" class="headerlink" title="重定向的实现"></a>重定向的实现</h3><ul><li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202208202053893.png" alt="image-20220820205356368"></li></ul><h3 id="jsp"><a href="#jsp" class="headerlink" title="jsp"></a>jsp</h3><h4 id="用户名密码登录"><a href="#用户名密码登录" class="headerlink" title="用户名密码登录"></a>用户名密码登录</h4><ul><li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202208202251252.png" alt="image-20220820225016727"></p></li><li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202208202251123.png" alt="image-20220820225125749"></p></li><li><p><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220820232719501.png" alt="image-20220820232719501"></p></li><li><p>可以对登录进行参数的获取 然后重定向到新的jsp页面</p></li><li><p><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220820232811798.png" alt="image-20220820232811798"></p></li></ul><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><h3 id="基本知识："><a href="#基本知识：" class="headerlink" title="基本知识："></a>基本知识：</h3><ul><li>cookie存储在用户文件下的appdata</li><li>一个cookie只能保存一个信息</li><li>一个web站点可以给浏览器发送多个cookie 最多存放20哥cookie</li><li>cookie的大小限制是4kb</li></ul><h4 id="删除cookie"><a href="#删除cookie" class="headerlink" title="删除cookie"></a>删除cookie</h4><ul><li>设置有效期为0</li></ul><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><ul><li>为每个用户（浏览器）打开时创建session</li><li>关闭浏览器则关闭session</li><li>不同的请求都会共用一个session</li></ul><p>用户登录后可以访问所有的不同页面 通过session实现（保存用户的信息）</p><h4 id="remove-session"><a href="#remove-session" class="headerlink" title="remove session"></a>remove session</h4><ul><li><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220821215458281.png" alt="image-20220821215458281"></li></ul><h3 id="java中新建类"><a href="#java中新建类" class="headerlink" title="java中新建类"></a>java中新建类</h3><ul><li><p><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220821213009803.png" alt="image-20220821213009803"></p></li><li><p>定义为en（实体）或者pojo</p></li></ul><h3 id="jsp-java-server-pages"><a href="#jsp-java-server-pages" class="headerlink" title="jsp java server pages"></a>jsp java server pages</h3><ul><li><p>所用的语言就是html</p></li><li><p>参考古早的写页面实在servlet中一行一行敲进去</p><p><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220822094905206.png" alt="image-20220822094905206"></p></li><li><p>区别jsp和html</p><ul><li>html只提供静态的数据</li><li>jsp可以嵌入java代码提供动态数据</li></ul></li></ul><h4 id="jsp原理"><a href="#jsp原理" class="headerlink" title="jsp原理"></a>jsp原理</h4><h4 id="取出值的选择和流程"><a href="#取出值的选择和流程" class="headerlink" title="取出值的选择和流程"></a>取出值的选择和流程</h4><ul><li><p>大体分类：</p><ul><li>每一个浏览器&#x2F;用户单独开的session</li><li>所有的用户共同访问的数据（在线人数&#x2F;…）</li></ul></li><li><p><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220823142636295.png" alt="image-20220823142636295"></p></li><li><p>jsp对象</p><p><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220823163052197.png" alt="image-20220823163052197"></p></li><li><p><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220823163303339.png" alt="image-20220823163303339"></p></li><li><p><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220823163324307.png" alt="image-20220823163324307">转发</p></li><li></li></ul><h3 id="EL表达式-取得参数-x2F-执行运算-x2F-获取web开发的常用对象"><a href="#EL表达式-取得参数-x2F-执行运算-x2F-获取web开发的常用对象" class="headerlink" title="EL表达式 取得参数&#x2F;执行运算&#x2F;获取web开发的常用对象"></a>EL表达式 取得参数&#x2F;执行运算&#x2F;获取web开发的常用对象</h3><ul><li><p><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220823175058267.png" alt="image-20220823175058267"></p></li><li><p><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220823175119920.png" alt="image-20220823175119920"></p></li></ul><h3 id="JSTL标签"><a href="#JSTL标签" class="headerlink" title="JSTL标签"></a>JSTL标签</h3><ul><li><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220823175313567.png" alt="image-20220823175313567"></li></ul><p>逻辑代码写在servlet 然后转发给jsp</p><p>jstl 和 el表达式可以替代内嵌脚本的写法（不好维护）</p><ul><li><p><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220823201827976.png" alt="image-20220823201827976"></p></li><li><p><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220823205137954.png" alt="image-20220823205137954"></p></li><li><p><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220823205502074.png" alt="image-20220823205502074"></p></li></ul><p>servlet转发给jsp</p><ul><li><p><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220823211101033.png" alt="image-20220823211101033"></p></li><li><p><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220824162224406.png" alt="image-20220824162224406"></p></li><li><p><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220824163110194.png" alt="image-20220824163110194"></p></li><li><p><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220824163535144.png" alt="image-20220824163535144"></p></li></ul><h4 id="sidenote"><a href="#sidenote" class="headerlink" title="sidenote"></a>sidenote</h4><ul><li><p>对应的servlet和<a href="https://tomcat.apache.org/whichversion.html">tomcat</a></p></li><li><p>如果遇到找不到dependency 需要重新import maven</p></li><li><img src="E:\codepractice\Pinkypie\source\_posts\2022\08\assets\image-20220824202521105.png" alt="image-20220824202521105" style="zoom:50%;" /></li><li><p>右键项目-&gt;maven-&gt;reload project</p></li><li></li></ul><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><ul><li><p><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220824213156788.png" alt="image-20220824213156788"></p></li><li><p><img src="E:\codepractice\Pinkypie\source_posts\2022\08\assets\image-20220824213216822.png" alt="image-20220824213216822"></p></li><li><p>过滤器中代码在过滤时都会执行 必须继续让代码通行就要用chain（很多个filter串联）</p></li><li><p>web服务器刚启动就初始化filter 关闭了服务器才会销毁（关掉浏览器网页并不会销毁filter）</p></li><li></li></ul><h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><ul><li>可以实现监听事件</li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
