<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="过期的jk">
<meta property="og:type" content="website">
<meta property="og:title" content="rye is coding">
<meta property="og:url" content="https://pinkyrie.github.io/page/3/index.html">
<meta property="og:site_name" content="rye is coding">
<meta property="og:description" content="过期的jk">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="rye">
<meta name="twitter:card" content="summary"><title>rye is coding</title><link ref="canonical" href="https://pinkyrie.github.io/page/3/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fa fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">rye is coding</div><div class="header-banner-info__subtitle"></div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/11/19/11/">[ 文章无标题 ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-11-19</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-11-19</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="顺序查找法"   >
          <a href="#顺序查找法" class="heading-link"><i class="fas fa-link"></i></a><a href="#顺序查找法" class="headerlink" title="顺序查找法"></a>顺序查找法</h1>
      <ul>
<li><p>如果查找的关键字不在线性表中 需要进行n+1次关键字的比较</p>
</li>
<li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211192211924.png" alt="image-20221013134306357"></p>
</li>
</ul>

        <h3 id="sequential-search"   >
          <a href="#sequential-search" class="heading-link"><i class="fas fa-link"></i></a><a href="#sequential-search" class="headerlink" title="sequential search"></a>sequential search</h3>
      <ul>
<li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211192212152.png" alt="image-20221013135040886"></li>
</ul>

        <h2 id="折半查找"   >
          <a href="#折半查找" class="heading-link"><i class="fas fa-link"></i></a><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2>
      
        <h3 id="basics"   >
          <a href="#basics" class="heading-link"><i class="fas fa-link"></i></a><a href="#basics" class="headerlink" title="basics"></a>basics</h3>
      <ul>
<li>需要对数据元素进行编号访问 必须存储在数组中</li>
<li></li>
</ul>

        <h3 id="折半查找树"   >
          <a href="#折半查找树" class="heading-link"><i class="fas fa-link"></i></a><a href="#折半查找树" class="headerlink" title="折半查找树"></a>折半查找树</h3>
      <ul>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/zhupengqq/article/details/51837908" >计算平均查找长度（成功&#x2F;不成功</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><ul>
<li>成功：从根结点数到待查找结点一共经过的结点数</li>
<li>不成功：补缺失的结点</li>
</ul>
</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/zipeilu/p/14626027.html" >折半查找平均查找长度推导 - zipeilu - 博客园 (cnblogs.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li></li>
</ul>
<p>binary search</p>
<ul>
<li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211192212440.png" alt="image-20221013141320990"></li>
</ul>

        <h3 id="block-search-（linear-search的改进）"   >
          <a href="#block-search-（linear-search的改进）" class="heading-link"><i class="fas fa-link"></i></a><a href="#block-search-（linear-search的改进）" class="headerlink" title="block search （linear search的改进）"></a><strong>block search （linear search的改进）</strong></h3>
      <ul>
<li><p>不要求等分块儿（块儿里元素个数不要求都相等）</p>
</li>
<li><p>不限制顺序</p>
</li>
<li><p>前一块的最大键码 小于 第二块的最小键码</p>
</li>
</ul>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.tutorialspoint.com/implementing-block-search-in-javascript" >实现code</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="B-tree-–balanced-tree-amp-多分树"   >
          <a href="#B-tree-–balanced-tree-amp-多分树" class="heading-link"><i class="fas fa-link"></i></a><a href="#B-tree-–balanced-tree-amp-多分树" class="headerlink" title="B-tree –balanced tree&amp;多分树"></a>B-tree –balanced tree&amp;多分树</h3>
      
        <h4 id="basics-1"   >
          <a href="#basics-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#basics-1" class="headerlink" title="basics"></a>basics</h4>
      <ul>
<li>控制树的高度比较小 所以磁盘的读取比较少</li>
<li></li>
<li>所有叶子结点必须在同一层（方便查找失败的处理）</li>
<li>k个子节点的非叶子节点包含k-1个关键码</li>
<li></li>
</ul>

        <h3 id="2-3-tree"   >
          <a href="#2-3-tree" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-3-tree" class="headerlink" title="2-3 tree"></a>2-3 tree</h3>
      <ul>
<li><p>b-tree的延申</p>
</li>
<li></li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43305485/article/details/120619942" >二分查找 的 树的结构</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
</ul>
<p><img src="/assets/image-20221018104651165.png" alt="image-20221018104651165"></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/11/19/10/">[ 文章无标题 ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-11-19</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-13</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="二部图"   >
          <a href="#二部图" class="heading-link"><i class="fas fa-link"></i></a><a href="#二部图" class="headerlink" title="二部图"></a>二部图</h2>
      <ul>
<li>边的限制（两个顶点分别在两个子集）</li>
</ul>

        <h3 id="判断二部图"   >
          <a href="#判断二部图" class="heading-link"><i class="fas fa-link"></i></a><a href="#判断二部图" class="headerlink" title="判断二部图"></a>判断二部图</h3>
      
        <h4 id="染色法"   >
          <a href="#染色法" class="heading-link"><i class="fas fa-link"></i></a><a href="#染色法" class="headerlink" title="染色法"></a>染色法</h4>
      <ul>
<li>对于二分图的判断方法最常见的是染色法，顾名思义就是我们对每一个点进行染色操作，我们只用黑白两种颜色，问能不能使所有的点都染上了色，而且相邻两个点的颜色不同，如果可以那么这个图就是一个二分图，对于判断是否是一个二分图的方法可以用dfs和bfs两种方式去实现。</li>
<li>定理：<strong>一张图是二分图，当且仅当图中不存在奇环（长度为奇数的环）。一定不含有奇数环，可能包含长度为偶数的环， 不一定是连通图</strong>定理：</li>
<li><strong>当且仅当</strong>无向图G的<strong>每一个环</strong><br>的结点数<strong>均是偶数</strong>时，图G才是一个二分图。<strong>如果无环，相当于每的结点数为 0，故也视为二分图。</strong></li>
<li>使用深度优先搜索对图进行染色，共两种颜色。有边相连的两个点染成不同的颜色。若染色过程中出现冲突，则该图不是二分图。否则是二分图。</li>
<li>通过顶点的neighbor染色：BFS</li>
</ul>

        <h3 id="对于无权二部图的最大匹配"   >
          <a href="#对于无权二部图的最大匹配" class="heading-link"><i class="fas fa-link"></i></a><a href="#对于无权二部图的最大匹配" class="headerlink" title="对于无权二部图的最大匹配"></a>对于无权二部图的最大匹配</h3>
      <ul>
<li>matching是edges的子集 matching不能含有有共同顶点的边</li>
<li>Bipartite matching is the problem of finding a <strong>subgraph</strong> in a bipartite graph where no two edges share an endpoint.</li>
</ul>

        <h3 id="有权二部图的最大匹配"   >
          <a href="#有权二部图的最大匹配" class="heading-link"><i class="fas fa-link"></i></a><a href="#有权二部图的最大匹配" class="headerlink" title="有权二部图的最大匹配"></a>有权二部图的最大匹配</h3>
      <ul>
<li>如果权重有正有负-&gt;等价于找到最小化匹配（即不喜欢为正 喜欢为负）</li>
</ul>

        <h4 id="匈牙利算法"   >
          <a href="#匈牙利算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h4>
      <ul>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/smuxiaolei/p/8343472.html" >简单理解思想—-递归的腾位置</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ul>
<p>先把最大匹配转化为最小匹配然后使用匈牙利算法</p>
<ul>
<li>限制条件：必须二部图的两个子集是元素个数相等的</li>
<li>O(n^3)</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/11/19/09/">[ 文章无标题 ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-11-19</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-16</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h3 id="basics"   >
          <a href="#basics" class="heading-link"><i class="fas fa-link"></i></a><a href="#basics" class="headerlink" title="basics"></a>basics</h3>
      
        <h4 id="流网络"   >
          <a href="#流网络" class="heading-link"><i class="fas fa-link"></i></a><a href="#流网络" class="headerlink" title="流网络"></a>流网络</h4>
      <ul>
<li><p>flow network: the graph is connected and since each vertex other than s(source) has at least one entering edge</p>
<ul>
<li>so |E| &gt;&#x3D; |V| - 1</li>
</ul>
</li>
<li><p>两个constraints</p>
<ul>
<li>capacity constraint:</li>
<li>flow conservation: flow in equals flow out</li>
</ul>
</li>
<li><p>flow：实际流量</p>
</li>
<li><p>capacity：最大容量</p>
</li>
<li><p>residual：余量&#x3D;最大容量-实际流量</p>
</li>
<li><p>blocking flow: A blocking flow is a union of flows along admissible paths that <strong>saturate at least one arc</strong> on every admissible path. (也就是naive algorithm得到的解)</p>
</li>
</ul>

        <h4 id="最小割-min-cut"   >
          <a href="#最小割-min-cut" class="heading-link"><i class="fas fa-link"></i></a><a href="#最小割-min-cut" class="headerlink" title="最小割 min cut"></a>最小割 min cut</h4>
      <ul>
<li><p>a cut whose capacity is minimum over all cuts of the network</p>
<ul>
<li>区分一下capacity and flow</li>
<li>flow是有方向的 （向量）必须带符号进行加减</li>
<li>capacity是无方向（标量） 只考虑一个方向最大的即可</li>
</ul>
</li>
<li><p>最小割的capacity 会 限制最大流的值 因为最大流</p>
</li>
</ul>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/flying_coding/article/details/106973854" >reference</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ul>
<li>思考这样一个问题：在给定的图中，如何判断一个源点s到终点t是否有路径存在呢？<ul>
<li><strong>若从S到T的路径为零，则不存在s到t的路径，其中s∈S，t∈T。</strong></li>
<li><strong>一个图中从s到t的路径最多不超过其S,T最小割的数量,其中s∈S，t∈T。</strong></li>
</ul>
</li>
</ul>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/65793018" >reference</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ul>
<li>[对最大流最小割定理的证明]([Max-flow Min-cut Algorithm | Brilliant Math &amp; Science Wiki](<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://brilliant.org/wiki/max-flow-min-cut-algorithm/#:~:text=The" >https://brilliant.org/wiki/max-flow-min-cut-algorithm/#:~:text=The</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> max-flow min-cut theorem is a network flow,would totally disconnect the source from the sink.))</li>
<li></li>
</ul>

        <h3 id="Naive-algorithm"   >
          <a href="#Naive-algorithm" class="heading-link"><i class="fas fa-link"></i></a><a href="#Naive-algorithm" class="headerlink" title="Naive algorithm"></a>Naive algorithm</h3>
      
        <h4 id="步骤"   >
          <a href="#步骤" class="heading-link"><i class="fas fa-link"></i></a><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4>
      <ul>
<li>初始化的residual 图 &#x3D;&#x3D; original 图</li>
<li>选择Augmenting path（a path from 𝑠 to 𝑡 that does not contain cycles.）</li>
</ul>

        <h3 id="Ford-Fulkerson"   >
          <a href="#Ford-Fulkerson" class="heading-link"><i class="fas fa-link"></i></a><a href="#Ford-Fulkerson" class="headerlink" title="Ford-Fulkerson"></a>Ford-Fulkerson</h3>
      
        <h4 id="basics-1"   >
          <a href="#basics-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#basics-1" class="headerlink" title="basics"></a>basics</h4>
      <ul>
<li><p>核心：residual networks, augmenting paths, cuts</p>
</li>
<li><p>although each iteration of the method increases the value of the flow, we shall see that the flow on any particular edge of G may increase or decrease.</p>
<p>decreasing the flow on some edges may INCREASE the total flow from source to sink.</p>
</li>
<li><p>residual graph中引入了相反方向的edge是为了表达decrease这条边的流量（sending the flow back along an edge is equivalent to decreasing the flow on the edge)</p>
<p>residual graph中的edge数量小于等于原本edges数量的两倍</p>
</li>
<li><p>结束条件：residual network contains no augmenting path</p>
</li>
</ul>

        <h4 id="reference"   >
          <a href="#reference" class="heading-link"><i class="fas fa-link"></i></a><a href="#reference" class="headerlink" title="reference"></a>reference</h4>
      <ul>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.desgard.com/algo/docs/part4/ch03/2-ford-fulkerson/" >basics</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ul>
<li><strong>通过将流量推回这种操作，从而得到新的流</strong> 。为什么要这么做呢？其实原因就是 <strong>因为对一条增广路不一定输入这条增广路的上限流量就能保证全局的最大流量</strong> 。再提高一个维度来看我们之前的思路，<strong>其实一直是“贪心”思想在引导我们加流和拆边操作，但是贪心并不能获得全局最大流量，这也是之前动态规划能够解决贪心对于全局最优解无法实现的问题</strong> 。</li>
<li>贪心只能得到局部的最优解 因此naive算法得到的不会是最终的最大流解</li>
</ul>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://emory.gitbook.io/dsa-java/network-flow/ford-fulkerson-algorithm" >演示worst case为什么是f*m</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p>Ford-Fulkerson算法的时间复杂度取决于增广路径如何决定</p>
<p>如果所有的容量都是整数，有一个Ford-Fulkerson算法的直接实现的时间复杂度O(|E||f*|),其中f*由算法决定</p>
</li>
</ul>

        <h4 id="步骤-1"   >
          <a href="#步骤-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4>
      <ul>
<li><p>允许undo path</p>
</li>
<li><p>最后删除所有的undo path</p>
</li>
<li><p>时间复杂度</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://stackoverflow.com/questions/33565995/time-complexity-of-the-ford-fulkerson-method-in-a-flow-network-with-unit-capacit" >algorithm - Time complexity of the Ford-Fulkerson method in a flow network with unit capacity edges - Stack Overflow</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
</ul>

        <h3 id="Edmonds-Karp-algorithm"   >
          <a href="#Edmonds-Karp-algorithm" class="heading-link"><i class="fas fa-link"></i></a><a href="#Edmonds-Karp-algorithm" class="headerlink" title="Edmonds-Karp algorithm"></a>Edmonds-Karp algorithm</h3>
      
        <h4 id="基本思想"   >
          <a href="#基本思想" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4>
      <ul>
<li><p><strong>Edmonds–Karp algorithm</strong> is an optimized implementation of the Ford–Fulkerson method for computing the maximum flow in a flow network in <strong>O(V E^2)</strong> time instead of <strong>O(E |max_flow|)</strong> in case of Ford-Fulkerson algorithm.</p>
</li>
<li><p>The algorithm is identical to the Ford–Fulkerson algorithm, except that the search order when finding the augmenting path is defined. The path found must be a shortest path that has available capacity.</p>
</li>
<li><p><img src="/assets/image-20221006221449948.png" alt="image-20221006221449948"></p>
</li>
<li><p>This can be found by a <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Breadth-first_search" >breadth-first search</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>, where we apply a weight of 1 to each edge. The running time of {\displaystyle O(|V||E|^{2})}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ae5bc5dfaecce53a04efd47719ac640aa983e706" alt="{\displaystyle O(|V||E|^{2})}"> is found by showing that each augmenting path can be found in {\displaystyle O(|E|)}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/976fe7f1e011d0dcdb3d6163754c877aaad5187f" alt="O(|E|)"> time, that every time at least one of the {\displaystyle E}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4232c9de2ee3eec0a9c0a19b15ab92daa6223f9b" alt="E"> edges becomes saturated (an edge which has the maximum possible flow), that the distance from the saturated edge to the source along the augmenting path must be longer than last time it was saturated, and that the length is at most {\displaystyle |V|}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9ddcffc28643ac01a14dd0fb32c3157859e365a7" alt="|V|">.</p>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/11/19/07/">[ 文章无标题 ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-11-19</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-11-19</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="拓扑排序"   >
          <a href="#拓扑排序" class="heading-link"><i class="fas fa-link"></i></a><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1>
      
        <h2 id="basics"   >
          <a href="#basics" class="heading-link"><i class="fas fa-link"></i></a><a href="#basics" class="headerlink" title="basics"></a>basics</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">小明有 2 个小时的作业，回家一共有 4 个小时做作业的时间。他可以选择一开始就做，或者因为「ddl 综合征」最后 2 小时才开始做。此时「做作业最早的时间」和「做作业的最晚时间」是不等的。</span><br><span class="line">老师知道小明的情况后将小明的作业增加到了 4 个小时的量，小明做作业的时间还是 4 个小时。小明只能回家就开始做作业才能做完。此时「做作业最早的时间」和「做作业的最晚时间」是相等的。</span><br><span class="line">「做作业最早的时间」和「做作业的最晚时间」是相等的说明：如果做作业的时间延误，将会导致整个工期延误，做作业的时间缩短，整个工期的最短时间就会缩短。</span><br><span class="line">我们将「做作业」抽象为「活动」Activity，「作业完成」抽象为「事件」Event</span><br><span class="line">关键路径定义：活动的最早发生时间和最晚发生时间相等的路径就是关键路径</span><br></pre></td></tr></table></div></figure>

<ul>
<li>DAG（Directed Acyclic Graph简称DAG），就是有向无环图，DAG这种图中的所有边都是有向边，而且从任意一个顶点开始，都找不到回到起始点的环路。当且仅当一个有向图为有向无环图（directed acyclic graph，或称DAG）时，才能得到对应于该图的拓扑排序。每一个有向无环图都至少存在一种拓扑排序</li>
<li>一个可以进行拓扑排序的DAG图的基本特征，必然存在至少一个入度为0的节点，如此才可以排序。有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。</li>
<li>顶点表示事件 边表示活动 边的权值表示活动所需要的时间</li>
<li>边的方向表示活动可以在起点事件之后开始 在终点事件之前完成</li>
<li>AOE网</li>
<li>完成工程的最短时间是从源点到汇点的最长路径的长度 称为关键路径</li>
</ul>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://tiemchart.com/blogs/training/forward-pass-and-backward-pass/#:~:text=Forward%20pass%20is%20a%20technique%20to%20move%20forward,if%20there%20is%20any%20slack%20in%20the%20activity." >reference</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ul>
<li><p>forward pass：计算最早结束时间</p>
<p>In order to calculate Early Finish, we use forward pass. Means moving from Early Start towards right to come up with Early Finish of the project.</p>
</li>
<li><p>backward pass：计算最晚开始时间</p>
<p>Late Start (LS) is the latest date that the activity can finish without causing a delay to the project completion date.</p>
</li>
</ul>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/337438327" >reference</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ul>
<li><strong>最早发生时间：从前往后，前驱结点到当前结点所需时间，取最大值。</strong></li>
<li><strong>最迟发生时间：从后往前，后继结点的最迟发生时间-边权值，取最小值。</strong></li>
</ul>
<p>1  3 2 4 5 6</p>
<p>13246</p>
<p>13256</p>

        <h2 id="steps"   >
          <a href="#steps" class="heading-link"><i class="fas fa-link"></i></a><a href="#steps" class="headerlink" title="steps"></a>steps</h2>
      <ul>
<li>Identify vertices that have no incoming edges （The “in-degree” of these vertices is zero）<ul>
<li>If no such vertices, graph has only cycle(s) (cyclic graph) Topological sort not possible – Halt.</li>
</ul>
</li>
<li>Delete this vertex of in-degree 0 and all its outgoing edges from the graph. Place it in the output.</li>
<li>Repeat Step 1 and Step 2 until graph is empty</li>
</ul>

        <h3 id="判断是否为有向图"   >
          <a href="#判断是否为有向图" class="heading-link"><i class="fas fa-link"></i></a><a href="#判断是否为有向图" class="headerlink" title="判断是否为有向图"></a>判断是否为有向图</h3>
      <ul>
<li>在图论中，如果一个<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%89%E5%90%91%E5%9B%BE?fromModule=lemma_inlink" >有向图</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>无法从某个顶点出发经过若干条边回到该点，则这个图是一个<strong>有向无环图</strong>（DAG图）。</li>
<li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211192229111.png" alt="image-20221119150809245"></li>
</ul>
<p>这是有向无环图</p>

        <h3 id="code"   >
          <a href="#code" class="heading-link"><i class="fas fa-link"></i></a><a href="#code" class="headerlink" title="code"></a>code</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; adj;</span><br><span class="line">vector&lt;int&gt; indegree(n,0);</span><br><span class="line">int n,m;</span><br><span class="line">int cnt=0;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">	int u,v;</span><br><span class="line">	cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">	adj[u].push_back(v);</span><br><span class="line">	indeg[v]++</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;int&gt; pq;</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">	if(indeg[i]==0)&#123;</span><br><span class="line">		pq.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">while(!pq.empty())&#123;</span><br><span class="line">	cnt++;</span><br><span class="line">	int x = pq.front();</span><br><span class="line">	pq.pop();</span><br><span class="line">	cout&lt;&lt;x&lt;&lt;&quot; &quot;;</span><br><span class="line">	for(auto it:adj[x])&#123;</span><br><span class="line">		indeg[it]--;</span><br><span class="line">		if(indeg[it]==0)</span><br><span class="line">			pq.push(it);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/cpp-program-for-topological-sorting/" >stack实现</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ul>
<p>复杂度分析</p>
<ul>
<li><p>version 1</p>
<ul>
<li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211192229814.png" alt="image-20221119160556133"></li>
</ul>
</li>
<li><p>version 2 Initialize and maintain a queue (or stack) of vertices with In-Degree 0</p>
<ul>
<li>Store each vertex’s In-Degree in an array Initialize a queue with all in-degree zero vertices While there are vertices remaining in the queue:       ➭ Dequeue and output a vertex       ➭ Reduce In-Degree of all vertices adjacent to it by 1       ➭ Enqueue any of these vertices whose In-Degree became zero</li>
<li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211192229866.png" alt="image-20221119160658194"></li>
<li><img src="/assets/image-20221119160731648.png" alt="image-20221119160731648"></li>
</ul>
</li>
</ul>
<p>​		</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/11/19/05/">[ 文章无标题 ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-11-19</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-11-19</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="Minimum-cost-spanning-trees"   >
          <a href="#Minimum-cost-spanning-trees" class="heading-link"><i class="fas fa-link"></i></a><a href="#Minimum-cost-spanning-trees" class="headerlink" title="Minimum-cost spanning trees"></a>Minimum-cost spanning trees</h1>
      <ul>
<li>connected undirected weighted graph</li>
<li></li>
</ul>

        <h2 id="基本概念"   >
          <a href="#基本概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2>
      
        <h3 id="最小生成树的性质"   >
          <a href="#最小生成树的性质" class="heading-link"><i class="fas fa-link"></i></a><a href="#最小生成树的性质" class="headerlink" title="最小生成树的性质"></a>最小生成树的性质</h3>
      <ul>
<li>A minimum spanning tree is a subgraph of an undirected weighted graph G, such that<ul>
<li>It is a tree (i.e. it is acyclic)</li>
<li>It covers all the vertices and contains |V| - 1 edges</li>
</ul>
</li>
<li>Not necessarily unique A graph may have many spanning trees.</li>
</ul>
<blockquote>
<p>prim and kruskal 算法用于generate最小生成树</p>
</blockquote>

        <h2 id="prim"   >
          <a href="#prim" class="heading-link"><i class="fas fa-link"></i></a><a href="#prim" class="headerlink" title="prim"></a>prim</h2>
      <ul>
<li><p>Prim: (build tree incrementally)</p>
<p>Pick lower cost edge connected to known (incomplete) spanning tree that does not create a cycle and expand to include it in the tree</p>
</li>
</ul>

        <h3 id="steps"   >
          <a href="#steps" class="heading-link"><i class="fas fa-link"></i></a><a href="#steps" class="headerlink" title="steps"></a>steps</h3>
      <ul>
<li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191609200.png" alt="image-20221117221621810"></p>
</li>
<li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191609807.png" alt="image-20221117221005358"></p>
</li>
</ul>

        <h3 id="code"   >
          <a href="#code" class="heading-link"><i class="fas fa-link"></i></a><a href="#code" class="headerlink" title="code"></a>code</h3>
      <ul>
<li><pre><code class="c++">
// A C++ program for Prim&#39;s Minimum
// Spanning Tree (MST) algorithm. The program is
// for adjacency matrix representation of the graph
#include &lt;bits/stdc++.h&gt;
using namespace std;
 
// Number of vertices in the graph
#define V 5
 
// A utility function to find the vertex with
// minimum key value, from the set of vertices
// not yet included in MST
int minKey(int key[], bool mstSet[])
&#123;
    // Initialize min value
    int min = INT_MAX, min_index;
 
    for (int v = 0; v &lt; V; v++)
        if (mstSet[v] == false &amp;&amp; key[v] &lt; min)
            min = key[v], min_index = v;
 
    return min_index;
&#125;
 
// A utility function to print the
// constructed MST stored in parent[]
void printMST(int parent[], int graph[V][V])
&#123;
    cout &lt;&lt; &quot;Edge \tWeight\n&quot;;
    for (int i = 1; i &lt; V; i++)
        cout &lt;&lt; parent[i] &lt;&lt; &quot; - &quot; &lt;&lt; i &lt;&lt; &quot; \t&quot;
             &lt;&lt; graph[i][parent[i]] &lt;&lt; &quot; \n&quot;;
&#125;
 
// Function to construct and print MST for
// a graph represented using adjacency
// matrix representation
void primMST(int graph[V][V])
&#123;
    // Array to store constructed MST
    int parent[V];
 
    // Key values used to pick minimum weight edge in cut
    int key[V];
 
    // To represent set of vertices included in MST
    bool mstSet[V];
 
    // Initialize all keys as INFINITE
    for (int i = 0; i &lt; V; i++)
        key[i] = INT_MAX, mstSet[i] = false;
 
    // Always include first 1st vertex in MST.
    // Make key 0 so that this vertex is picked as first
    // vertex.
    key[0] = 0;
    parent[0] = -1; // First node is always root of MST
 
    // The MST will have V vertices
    for (int count = 0; count &lt; V - 1; count++) &#123;
        // Pick the minimum key vertex from the
        // set of vertices not yet included in MST
        int u = minKey(key, mstSet);
 
        // Add the picked vertex to the MST Set
        mstSet[u] = true;
 
        // Update key value and parent index of
        // the adjacent vertices of the picked vertex.
        // Consider only those vertices which are not
        // yet included in MST
        for (int v = 0; v &lt; V; v++)
 
            // graph[u][v] is non zero only for adjacent
            // vertices of m mstSet[v] is false for vertices
            // not yet included in MST Update the key only
            // if graph[u][v] is smaller than key[v]
            if (graph[u][v] &amp;&amp; mstSet[v] == false
                &amp;&amp; graph[u][v] &lt; key[v])
                parent[v] = u, key[v] = graph[u][v];
    &#125;
 
    // print the constructed MST
    printMST(parent, graph);
&#125;
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  bool Graph&lt;T&gt;::Prim(int from,LinkList&lt;Edge&lt;T&gt;&gt; &amp;mst)&#123;</span><br><span class="line">  	T* nearest = new T[vertexNum];</span><br><span class="line">  	int* neighbor = new int[vertexNum];s</span><br><span class="line">  	for(int i=0;i&lt;vertexNum;i++)&#123;</span><br><span class="line">  		neighbor[i]=from;</span><br><span class="line">  		nearest[i]=MAX_VALUE;</span><br><span class="line">  	&#125;</span><br><span class="line">  	for(Edge&lt;T&gt; e=FirstEdge(from);IsEdge(e);e=NextEdgge(e))&#123;</span><br><span class="line">  		nearest[e.end] = e.weight; //从start开始到start相连的边的权值初始化</span><br><span class="line">  	&#125;</span><br><span class="line">  	neighbor[from] = -1;</span><br><span class="line">  	for(int i =1;i&lt;vertexNum;i++)&#123; //最小生成树是n-1条边</span><br><span class="line">  		T min = MAX_VALUE;</span><br><span class="line">  		int v = -1;</span><br><span class="line">  		for(int j=0;j&lt;vertexNum;j++)&#123;</span><br><span class="line">  			if(nearest[j]&lt;min &amp;&amp; neighbor[j]&gt;-1)&#123;</span><br><span class="line">  				min = nearest[j];</span><br><span class="line">  				v=j;</span><br><span class="line">  			&#125;</span><br><span class="line">  		&#125;</span><br><span class="line">  		if(v&gt;=0)&#123;</span><br><span class="line">  			Edge&lt;T&gt; tmp = (neighbor[v],v,min);</span><br><span class="line">  			mst.insertTail(tmp);</span><br><span class="line">  			neighbor[v] = -1;</span><br><span class="line">  		&#125;</span><br><span class="line">  		for(Edge&lt;T&gt; e=firstEdge(v);IsEdge(e);e=NextEdge(e))&#123;</span><br><span class="line">  			int u = e.end;</span><br><span class="line">  			//更新nearest和neighbor需要注意判断是否已加入mst 以及到目前该点的距离是不是需要更新成最短的</span><br><span class="line">  			if(neighbor[u]!=-1&amp;&amp;nearest[u]&gt;e.weight)&#123;</span><br><span class="line">  				neighbor[u] = v;</span><br><span class="line">  				nearest[u] = e.weight;</span><br><span class="line">  			&#125;</span><br><span class="line">  		&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></div></figure>
</code></pre>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.prepbytes.com/blog/queues/prims-algorithm-using-priority_queue-in-stl/" >priority queue实现</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/prims-algorithm-using-priority_queue-stl/" >priority queue实现</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191609619.png" alt="image-20221119105020849"></p>
</li>
</ul>

        <h3 id="复杂度分析"   >
          <a href="#复杂度分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3>
      <ul>
<li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191609618.png" alt="image-20221119104837149"></li>
<li>使用priority queue可以提升到O(elogv)</li>
</ul>

        <h2 id="kruskal"   >
          <a href="#kruskal" class="heading-link"><i class="fas fa-link"></i></a><a href="#kruskal" class="headerlink" title="kruskal"></a>kruskal</h2>
      <ul>
<li><p>Kruskal: (build forest that will finish as a tree)</p>
<p>Pick lower cost edge not yet in a tree that does not create a cycle and expand to include it somewhere in the forest</p>
</li>
<li><p>Work with <strong>edges</strong>, rather than nodes</p>
</li>
<li><p>基于greedy思想</p>
</li>
</ul>

        <h3 id="steps-1"   >
          <a href="#steps-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#steps-1" class="headerlink" title="steps"></a>steps</h3>
      <ul>
<li><p>Sort edges by increasing edge weight</p>
</li>
<li><p>Select the first |V| – 1 edges that do not generate a cycle</p>
</li>
<li><p>Initialize a forest of trees, each tree being a single nodeBuild a priority queue of edges with priority being lowest costRepeat until |V| -1 edges have been accepted {	Delete min edge from priority queue	If it forms a cycle then discard it      else accept the edge – It will join 2 existing trees yielding a larger tree 	and reducing the forest by one tree}</p>
</li>
<li><p>The accepted edges form the minimum spanning tree</p>
<p>Every step will have joined two trees in the forest together, so that at the end, there will only be one tree</p>
</li>
</ul>

        <h3 id="code-1"   >
          <a href="#code-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#code-1" class="headerlink" title="code"></a>code</h3>
      
        <h4 id="UNION-x2F-FIND-algorithm"   >
          <a href="#UNION-x2F-FIND-algorithm" class="heading-link"><i class="fas fa-link"></i></a><a href="#UNION-x2F-FIND-algorithm" class="headerlink" title="UNION&#x2F;FIND algorithm"></a>UNION&#x2F;FIND algorithm</h4>
      <ul>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://book.huihoo.com/data-structures-and-algorithms-with-object-oriented-design-patterns-in-c++/html/page579.html" >ref</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191609955.png" alt="image-20221118221116048"></p>
</li>
<li><pre><code class="c++">class UFsets&#123;
private:
    int n;
    int* root;
    int* next;
    int* length;
public:
    UFsets(int size)&#123;
        n = size;
        root = new int[n];
        next = new int[n];
        length = new int[n];
        for(int i = 0;i&lt;n;i++)&#123;
            root[i] = i;
            next[i] = i;
            length[i] = 1;
        &#125;
    &#125;
    int UFsets::Find(int v)&#123;
        if(v&lt;n)
            return root[v];
        else
            return -1;
    &#125;
    void UFsets::Union(int v, int u)&#123;
        if(root[u] == root[v])
            return;
        else if(length[v]&gt;length[u])&#123;
            int uRoot = root[u];
            length[v] = length[v]+length[u];
            root[u] = root[v];
            for(int uNext = next[uRoot];next[u]!=uRoot;uNext=next[uNext])&#123;
                root[uNext] = root[v];
        &#125;
            next[u] = root[v];
            next[v] = uRoot;
        &#125;
        else if(length[u]&gt;length[v])&#123;
            int vRoot = root[v];
            length[u] = length[u] + length[v];
            root[v] = root[u];
            for(int vNext = next[vRoot];next[vNext]!=vRoot;vNext=next[vNext])&#123;
                root[vNext] = root[u];
            &#125;
            next[v] = root[u];
            next[u] = vRoot;		
        &#125;
    &#125;
&#125;
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```c++</span><br><span class="line">  bool Graph&lt;T&gt;::Kruskal(LinkList&lt;Edge&lt;T&gt;&gt; &amp;mst)&#123;</span><br><span class="line">  	int *vertexArray = new int[vertexNum];</span><br><span class="line">  	for(int i=0;i&lt;vertexNum;i++)&#123;</span><br><span class="line">  		vertexArray[i] = i;</span><br><span class="line">  	&#125;</span><br><span class="line">  	UFsets set(vertexNum);s</span><br><span class="line">  	MinHeap&lt;Edge&lt;T&gt;&gt; heap(edgeCount());</span><br><span class="line">  	for(int i = 0;i&lt;vertexNum;i++)&#123;</span><br><span class="line">  		for(Edge&lt;T&gt; edge=firstEdge(i);IsEdge(edge);edge = nextEdge(edge))&#123;</span><br><span class="line">  			if(edge.start&lt;edge.end)&#123;</span><br><span class="line">  				heap.Insert(edge);</span><br><span class="line">  			&#125;</span><br><span class="line">  		&#125;		</span><br><span class="line">  	&#125;</span><br><span class="line">  	int mstEdgeNum = 0;</span><br><span class="line">  	while(!heap.IsEmpty())&#123;</span><br><span class="line">  		Edge&lt;T&gt; edge = heap.RemoveFirst();</span><br><span class="line">  		int start = edge.start;</span><br><span class="line">  		int end = edge.end;</span><br><span class="line">  		if(set.Find(start)!=set.Find(end))&#123;</span><br><span class="line">  			set.Union(start,end);</span><br><span class="line">  			mst.insertTail(edge);</span><br><span class="line">  			mstEdgeNum++;</span><br><span class="line">  		&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	if(mst.Count() == edgeCount()-1)</span><br><span class="line">  		return true;</span><br><span class="line">  	else</span><br><span class="line">  		return false;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></div></figure>

</code></pre>
</li>
<li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191609129.png" alt="image-20221119100816009"></p>
</li>
</ul>

        <h3 id="复杂度分析-1"   >
          <a href="#复杂度分析-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3>
      <ul>
<li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191609307.png" alt="image-20221119104727507"></li>
</ul>

        <h2 id="总结对比"   >
          <a href="#总结对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结对比" class="headerlink" title="总结对比"></a>总结对比</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/difference-between-prims-and-kruskals-algorithm-for-mst/#:~:text=Prim's%20algorithm%20has%20a%20time,works%20only%20on%20connected%20graph." >ref</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<div class="table-container"><table>
<thead>
<tr>
<th align="left">Prim’s Algorithm</th>
<th align="left">Kruskal’s Algorithm</th>
</tr>
</thead>
<tbody><tr>
<td align="left">It starts to build the Minimum Spanning Tree from any vertex in the graph.</td>
<td align="left">It starts to build the Minimum Spanning Tree from the vertex carrying minimum weight in the graph.</td>
</tr>
<tr>
<td align="left">It traverses one node more than one time to get the minimum distance.</td>
<td align="left">It traverses one node only once.</td>
</tr>
<tr>
<td align="left">Prim’s algorithm has a time complexity of O(V2), V being the number of vertices and can be improved up to O(E log V) using Fibonacci heaps.</td>
<td align="left">Kruskal’s algorithm’s time complexity is O(E log V), V being the number of vertices.</td>
</tr>
<tr>
<td align="left">Prim’s algorithm gives connected component as well as it works only on connected graph.</td>
<td align="left">Kruskal’s algorithm can generate forest(disconnected components) at any instant as well as it can work on disconnected components</td>
</tr>
<tr>
<td align="left">Prim’s algorithm runs faster in dense graphs.</td>
<td align="left">Kruskal’s algorithm runs faster in sparse graphs.</td>
</tr>
<tr>
<td align="left">It generates the minimum spanning tree starting from the root vertex.</td>
<td align="left">It generates the minimum spanning tree starting from the least weighted edge.</td>
</tr>
<tr>
<td align="left">Applications of prim’s algorithm are Travelling Salesman Problem, Network for roads and Rail tracks connecting all the cities etc.</td>
<td align="left">Applications of Kruskal algorithm are LAN connection, TV Network etc.</td>
</tr>
</tbody></table></div>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/11/19/02/">[ 文章无标题 ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-11-19</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-11-19</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="Graph-Traversals"   >
          <a href="#Graph-Traversals" class="heading-link"><i class="fas fa-link"></i></a><a href="#Graph-Traversals" class="headerlink" title="Graph Traversals"></a>Graph Traversals</h1>
      <p>A graph-traversal algorithm visits all vertices if and only if the graph is connected.</p>

        <h2 id="图的存储"   >
          <a href="#图的存储" class="heading-link"><i class="fas fa-link"></i></a><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h2>
      
        <h3 id="存储结构-邻接矩阵"   >
          <a href="#存储结构-邻接矩阵" class="heading-link"><i class="fas fa-link"></i></a><a href="#存储结构-邻接矩阵" class="headerlink" title="存储结构-邻接矩阵"></a>存储结构-邻接矩阵</h3>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span>  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> from;</span><br><span class="line">	<span class="type">int</span> to;</span><br><span class="line">	<span class="type">int</span> weight;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Edge</span>();</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="type">int</span> from,<span class="type">int</span> to,<span class="type">int</span> weight);</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Edge</span>();</span><br><span class="line">&#125;;</span><br><span class="line">Edge::<span class="built_in">Edge</span>()</span><br><span class="line">&#123;</span><br><span class="line">	from=to=<span class="number">-1</span>;</span><br><span class="line">	weight=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Edge::<span class="built_in">Edge</span>(<span class="type">int</span> from,<span class="type">int</span> to,<span class="type">int</span> weight)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;from=from;</span><br><span class="line">	<span class="keyword">this</span>-&gt;to=to;</span><br><span class="line">	<span class="keyword">this</span>-&gt;weight=weight;</span><br><span class="line">&#125;</span><br><span class="line">Edge::~<span class="built_in">Edge</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UNVISITED 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VISITED 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Edge.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">graph</span>  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> numvertex;</span><br><span class="line">	<span class="type">int</span> numEdge;</span><br><span class="line">	<span class="type">int</span> *mark;</span><br><span class="line">	<span class="type">int</span> *indegree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">graph</span>(<span class="type">int</span> numvertex);</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isEdge</span><span class="params">(Edge oneEdge)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">tovertex</span><span class="params">(Edge oneEdge)</span></span>;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">graph</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//返回边的起始点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">graph::tovertex</span><span class="params">(Edge oneEdge)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> oneEdge.to;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">graphm</span> : <span class="keyword">public</span> graph  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> **martix;</span><br><span class="line">	<span class="built_in">graphm</span>(<span class="type">int</span> numvertex);</span><br><span class="line">	<span class="function">Edge <span class="title">firstEdge</span><span class="params">(<span class="type">int</span> onevertex)</span></span>;</span><br><span class="line">	<span class="function">Edge <span class="title">nextEdge</span><span class="params">(Edge oneEdge)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setEdge</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to,<span class="type">int</span> weight)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(graphm g,<span class="type">int</span> v)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(graphm&amp; g,<span class="type">int</span> v)</span></span>;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">graphm</span>();</span><br><span class="line">&#125;;</span><br><span class="line">graphm::<span class="built_in">graphm</span>(<span class="type">int</span> numvertex):<span class="built_in">graph</span>(numvertex)</span><br><span class="line">&#123;</span><br><span class="line">	martix=(<span class="type">int</span> **) <span class="keyword">new</span> <span class="type">int</span>*[numvertex];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numvertex;i++)</span><br><span class="line">		martix[i]=<span class="keyword">new</span> <span class="type">int</span>[numvertex];</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;numvertex;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;numvertex;j++)</span><br><span class="line">			martix[i][j]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回顶点onevertex的第一条边</span></span><br><span class="line"><span class="function">Edge <span class="title">graphm::firstEdge</span><span class="params">(<span class="type">int</span> onevertex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Edge temp;</span><br><span class="line">	temp.from=onevertex;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numvertex;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(martix[onevertex][i]!=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			temp.to=i;</span><br><span class="line">			temp.weight=martix[onevertex][i];</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回与边oneEdge有相同起始点的下一条边</span></span><br><span class="line"><span class="function">Edge <span class="title">graphm::nextEdge</span><span class="params">(Edge oneEdge)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Edge temp;</span><br><span class="line">	temp.from=oneEdge.from;</span><br><span class="line">	<span class="keyword">if</span>(oneEdge.to&lt;numvertex)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=oneEdge.to+<span class="number">1</span>;i&lt;numvertex;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(martix[oneEdge.from][i]!=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			temp.to=i;</span><br><span class="line">			temp.weight=martix[oneEdge.from ][i];</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="存储结构-邻接表"   >
          <a href="#存储结构-邻接表" class="heading-link"><i class="fas fa-link"></i></a><a href="#存储结构-邻接表" class="headerlink" title="存储结构-邻接表"></a>存储结构-邻接表</h3>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListGraph</span>: <span class="keyword">public</span> Graph&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LinkList&lt;Edge&gt; * vertexList;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://linuxhint.com/adjacency-list-cpp/#:~:text=The%20adjacency%20list%20is%20a,to%20other%20nodes%20or%20vertices.&text=In%20the%20undirected%20graph%2C%20we%20can%20move%20to%20any%20vertex." >我看得懂的实现方法</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191609507.png" alt="image-20221118185055836"></p>
<ul>
<li>解释为什么邻接表的大小是n+2m</li>
</ul>

        <h3 id="pseudo-code"   >
          <a href="#pseudo-code" class="heading-link"><i class="fas fa-link"></i></a><a href="#pseudo-code" class="headerlink" title="pseudo code"></a>pseudo code</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void graphTraverse(Graph* G)&#123;</span><br><span class="line">	int v;</span><br><span class="line">	for(v = 0; v&lt;G-&gt;n(); v++)</span><br><span class="line">		G-&gt;setMark(v,UNVISITED);</span><br><span class="line">	for(v = 0; v&lt;G-&gt;n(); v++)&#123;</span><br><span class="line">		if(G-&gt;getMark(v)==UNVISITED)</span><br><span class="line">		doTraverse(G,v);</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="DFS"   >
          <a href="#DFS" class="heading-link"><i class="fas fa-link"></i></a><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2>
      <ul>
<li>proceeds along a path from v as deeply into the graph as possible before backing up. </li>
<li>The depth-first traversal algorithm does not completely specify the order in which it should visit the vertices adjacent to v.We may visit the vertices adjacent to v in sorted order.</li>
<li>类似二叉树的先序访问</li>
</ul>

        <h3 id="steps"   >
          <a href="#steps" class="heading-link"><i class="fas fa-link"></i></a><a href="#steps" class="headerlink" title="steps"></a>steps</h3>
      <ul>
<li>starting from vertex v.</li>
<li>Visit a vertex, then visit a vertex adjacent to that vertex v as deeply into the graph as possible before backing up</li>
<li>If there is no unvisited vertex adjacent to visited vertex, back up to the previous step.</li>
</ul>

        <h3 id="实现"   >
          <a href="#实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#实现" class="headerlink" title="实现"></a>实现</h3>
      <ul>
<li><img src="https://ucc.alicdn.com/pic/developer-ecology/90f80e5f92d149b8b81f8c2e2fb8fd34.gif" alt="1.gif"></li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/110160308" >ref:code</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ul>

        <h4 id="recursive"   >
          <a href="#recursive" class="heading-link"><i class="fas fa-link"></i></a><a href="#recursive" class="headerlink" title="recursive"></a>recursive</h4>
      <ul>
<li><p>pseudo code</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DFS(G, u)</span><br><span class="line">    u.visited = true</span><br><span class="line">    for each v ∈ G.Adj[u]</span><br><span class="line">        if v.visited == false</span><br><span class="line">            DFS(G,v)</span><br><span class="line">     </span><br><span class="line">init() &#123;</span><br><span class="line">    For each u ∈ G</span><br><span class="line">        u.visited = false</span><br><span class="line">     For each u ∈ G</span><br><span class="line">       DFS(G, u)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>&#96;&#96;&#96;c++<br>void graphm::DFS(graphm&amp; gt,int v)<br>{<br>g.mark[v]&#x3D;VISITED;<br>visit(g,v);&#x2F;&#x2F;执行输出<br>for(Edge e&#x3D;g.firstEdge(v);g.isEdge(e);e&#x3D;g.nextEdge(e)){<br>    if(g.mark[g.tovertex(e)]&#x3D;&#x3D;Unvisit)<br>        DFS(g,g.tovertex(e));<br>}		<br>}</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">#### Use a stack </span><br><span class="line"></span><br><span class="line">- ```c++</span><br><span class="line">  void graphm::DFS(graphm&amp; gt,int v)</span><br><span class="line">  &#123;	</span><br><span class="line">  	stack&lt;int&gt; st;</span><br><span class="line">  	for(int i=0;i&lt;numvertex;i++)&#123;</span><br><span class="line">  		mark[i]=UNVISITED;</span><br><span class="line">  	&#125;</span><br><span class="line">  	for(int i=0;i&lt;numvertex;i++)&#123;</span><br><span class="line">  		if(mark[i]==UNVISITED)&#123;</span><br><span class="line">  			st.push(i);</span><br><span class="line">  			while(!st.empty())&#123;</span><br><span class="line">  				int v;</span><br><span class="line">                    v=st.top();</span><br><span class="line">  				st.pop(v);</span><br><span class="line">  				if(mark[v]==UNVISITED)</span><br><span class="line">  					visit(v);</span><br><span class="line">  				mark[v]=visited;</span><br><span class="line">  				for(Edge e = FirstEdge(v);g.isEdge(e);e=NextEdge(e))&#123;</span><br><span class="line">  					if(mark[e.to]==UNVISITED)</span><br><span class="line">  						st.push(e.to);</span><br><span class="line">  				&#125;</span><br><span class="line">  			&#125;</span><br><span class="line">  		&#125; 		</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></div></figure>

<p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211172321119.png" alt="image-20221117205138496"></p>
</li>
</ul>

        <h3 id="复杂度分析"   >
          <a href="#复杂度分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3>
      
        <h4 id="时间复杂度"   >
          <a href="#时间复杂度" class="heading-link"><i class="fas fa-link"></i></a><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4>
      <ul>
<li><p>DFS算法是一一个递归算法，需要借助一个递归工作栈，故它的空间复杂度为O(N)。<br>遍历图的过程实质上是对每个顶点查找其邻接点的过程，其耗费的时间取决于所采用结构。</p>
<p>邻接表表示时，查找所有顶点的邻接点所需时间为O(E)，访问顶点的邻接点所花时间为O(N),此时，总的时间复杂度为O(N+E)。</p>
<p>邻接矩阵表示时，查找每个顶点的邻接点所需时间为O(N)，要查找整个矩阵，故总的时间度为O(N^2)。<br><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/difference-between-bfs-and-dfs/" >ref</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
</ul>

        <h4 id="空间复杂度"   >
          <a href="#空间复杂度" class="heading-link"><i class="fas fa-link"></i></a><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4>
      <ul>
<li>DFS算法是一一个递归算法，需要借助一个递归工作栈，故它的空问复杂度为O(V）。</li>
</ul>

        <h2 id="BFS"   >
          <a href="#BFS" class="heading-link"><i class="fas fa-link"></i></a><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2>
      <ul>
<li>After visiting a given vertex v, the breadth-first traversal algorithm visits every vertex adjacent to v before visiting any other vertex.</li>
<li>The breath-first traversal algorithm does not completely specify the order in which it should visit the vertices adjacent to v.</li>
<li>It is similar to level traversal.</li>
</ul>

        <h3 id="steps-1"   >
          <a href="#steps-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#steps-1" class="headerlink" title="steps"></a>steps</h3>
      
        <h3 id="实现-1"   >
          <a href="#实现-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3>
      <ul>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://stackoverflow.com/questions/2549541/performing-breadth-first-search-recursively" >trick-不能使用递归进行BFS queue与stack</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ul>

        <h4 id="use-queue"   >
          <a href="#use-queue" class="heading-link"><i class="fas fa-link"></i></a><a href="#use-queue" class="headerlink" title="use queue"></a>use queue</h4>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">graphm::BFS</span><span class="params">(graphm&amp; gt,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numvertex;i++)&#123;</span><br><span class="line">		mark[i]=UNVISITED;</span><br><span class="line">	&#125;</span><br><span class="line">	q.<span class="built_in">push</span>(v);</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> v;</span><br><span class="line">        <span class="comment">// dequeue front node and print it</span></span><br><span class="line">        v = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(mark[v]==UNVISITED)</span><br><span class="line">        	<span class="built_in">visite</span>(v);</span><br><span class="line">        mark[v]=VISITED;</span><br><span class="line">        <span class="keyword">for</span>(Edge e = <span class="built_in">FirstEdge</span>(v),<span class="built_in">IsEdge</span>(e);e=<span class="built_in">NextEdge</span>(e))&#123;</span><br><span class="line">        	<span class="keyword">if</span>(mark[e.to]==UNVISITED)</span><br><span class="line">        		q.<span class="built_in">push</span>(e.to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="pseudo-code-1"   >
          <a href="#pseudo-code-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#pseudo-code-1" class="headerlink" title="pseudo code"></a>pseudo code</h4>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bft(in v:Vertex) &#123;</span><br><span class="line">// Traverses a graph beginning at vertex v </span><br><span class="line">// by using breath-first strategy: Iterative Version</span><br><span class="line">q.createQueue();</span><br><span class="line">// add v to the queue and mark it</span><br><span class="line">q.enqueue(v);</span><br><span class="line">Mark v as visited;</span><br><span class="line">while (!q.isEmpty()) &#123;</span><br><span class="line">	   q.dequeue(w);</span><br><span class="line">	   for (each unvisited vertex u adjacent to w) &#123;</span><br><span class="line">	      Mark u as visited;</span><br><span class="line">	      q.enqueue(u);</span><br><span class="line">	   &#125;	   </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></div></figure>




        <h3 id="复杂度分析-1"   >
          <a href="#复杂度分析-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3>
      
        <h4 id="时间复杂度-1"   >
          <a href="#时间复杂度-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4>
      <ul>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%82%BB%E6%8E%A5%E8%A1%A8&spm=1001.2101.3001.7020" >邻接表</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>形式存储时，每个顶点均需搜索一次，时间复杂度T1&#x3D;O（v），从一个顶点开始搜索时，开始搜索，访问未被访问过的节点。最坏的情况下，每个顶点至少访问一次，每条边至少访问1次，这是因为在搜索的过程中，若某结点向下搜索时，其子结点都访问过了，这时候就会回退，故时间复 杂度为O(E)，算法总的时间复 度为O(|V|+|E|)。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5&spm=1001.2101.3001.7020" >邻接矩阵</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>存储方式时，查找每个顶点的邻接点所需时间为O(V)，即该节点所在的该行该列。又有n个顶点，故算总的时间复杂度为O(|V|^2)。</p>
</li>
<li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211172322430.png" alt="image-20221117211701421"></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://stackoverflow.com/questions/11468621/why-is-the-time-complexity-of-both-dfs-and-bfs-o-v-e" >ref</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
</ul>

        <h4 id="空间复杂度-1"   >
          <a href="#空间复杂度-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h4>
      <ul>
<li>BFS是一种借用<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%98%9F%E5%88%97&spm=1001.2101.3001.7020" >队列</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>来存储的过程，分层查找，优先考虑距离出发点近的点。无论是在邻接表还是邻接矩阵中存储，都需要借助一个辅助队列，v个顶点均需入队，最坏的情况下，空间复杂度为O（v）。</li>
</ul>

        <h3 id="对比"   >
          <a href="#对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#对比" class="headerlink" title="对比"></a>对比</h3>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/difference-between-bfs-and-dfs/" >ref</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<div class="table-container"><table>
<thead>
<tr>
<th align="left">14.</th>
<th align="left">Memory</th>
<th align="left">BFS requires more memory.</th>
<th align="left">DFS requires less memory.</th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table></div>
<div class="table-container"><table>
<thead>
<tr>
<th align="left">17.</th>
<th align="left">Speed</th>
<th align="left">BFS is slow as compared to DFS.</th>
<th align="left">DFS is fast as compared to BFS.</th>
</tr>
</thead>
<tbody><tr>
<td align="left">18.</td>
<td align="left">When to use?</td>
<td align="left">When the target is close to the source, BFS performs better.</td>
<td align="left">When the target is far from the source, DFS is preferable.</td>
</tr>
</tbody></table></div>
<ul>
<li>注意空间复杂度需要考虑原本图的类内成员存储结点和边（如果是邻接矩阵n^2 如果是邻接表n+2m)</li>
</ul>

        <h2 id="树的遍历使用BFS-DFS"   >
          <a href="#树的遍历使用BFS-DFS" class="heading-link"><i class="fas fa-link"></i></a><a href="#树的遍历使用BFS-DFS" class="headerlink" title="树的遍历使用BFS DFS"></a>树的遍历使用BFS DFS</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/mengmengdajuanjuan/article/details/84313361" >reference</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>中序遍历：按照从小到大</p>
<p>kruskal 算法</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/11/19/01/">[ 文章无标题 ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-11-19</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-11-19</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="graph"   >
          <a href="#graph" class="heading-link"><i class="fas fa-link"></i></a><a href="#graph" class="headerlink" title="graph"></a>graph</h1>
      
        <h2 id="basics概念"   >
          <a href="#basics概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#basics概念" class="headerlink" title="basics概念"></a>basics概念</h2>
      <ul>
<li><p>弧：指的是<strong>有向图</strong>里面的<strong>边，</strong>他是有明确方向的。如果是无向图的边，直接叫做“边”。比如有向图的 v1 结点到 v2 结点的弧可能是：&lt;v1, v2&gt;；</p>
</li>
<li><p>路径：指的是图（包括有向图和无向图）里面连接两个结点之间的边的集合，也就是一个顶点序列。比如：v1 到 v3 的路径可能这样表示：&lt;v1, v2&gt;、&lt;v2, v3&gt;；</p>
</li>
<li><p>如果是有向图，那么路径里面是用弧来组成。如果是无向图，路径是用边来组成。</p>
</li>
<li><p>edge&#x3D;arc</p>
</li>
<li><p>vertex(pl: vertices) &#x3D;node</p>
</li>
<li><p>degree: The degree of a vertex is the number of edges incident to it. </p>
</li>
<li><p>path: A path in a graph is a sequence of vertices connected by edges. </p>
<p>​		 A sequence of vertices v1,v2,. . .vk  such that consecutive vertices vi and vi+1 are adjacent.</p>
</li>
<li><p>simple path:  no repeated vertices</p>
</li>
<li><p>cycle: simple path, except that the last vertex is the same as the first vertex</p>
</li>
<li><p>simple cycle</p>
</li>
</ul>

        <h4 id="无向图-undirected-graph"   >
          <a href="#无向图-undirected-graph" class="heading-link"><i class="fas fa-link"></i></a><a href="#无向图-undirected-graph" class="headerlink" title="无向图 undirected graph"></a><strong>无向图 undirected graph</strong></h4>
      <ul>
<li>(v1,v2)</li>
<li>边数推导 &lt;&#x3D; n*(n-1)&#x2F;2</li>
<li>degree: The degree of vertex i is the number of edges incident on vertex i.</li>
<li>Sum of degrees &#x3D; 2e where e is the number of edges</li>
</ul>

        <h4 id="有向图-directed-graph"   >
          <a href="#有向图-directed-graph" class="heading-link"><i class="fas fa-link"></i></a><a href="#有向图-directed-graph" class="headerlink" title="有向图 directed graph"></a><strong>有向图 directed graph</strong></h4>
      <ul>
<li>&lt;v1,v2&gt;</li>
<li>边数推导 &lt;&#x3D; n*(n-1)</li>
<li>in degree: In-degree of vertex i is the number of edges incident to i (i.e., the number of incoming edges).</li>
<li>out degree: Out-degree of vertex i is the number of edges incident from i  (i.e., the number of outgoing edges).</li>
<li>Sum of in-degrees &#x3D; sum of out-degrees &#x3D; e,where e is the number of edges in the digraph.</li>
</ul>

        <h4 id="connected-graph"   >
          <a href="#connected-graph" class="heading-link"><i class="fas fa-link"></i></a><a href="#connected-graph" class="headerlink" title="connected graph"></a>connected graph</h4>
      <ul>
<li>A Connected graph has only one connected component.</li>
<li>Connected graph: G is connected iff there is a path between every pair of vertices in G</li>
<li>Subgraph: A subgraph S is formed from graph G by selecting a subset V of G’s vertices and a subset E of G’s edges such that for every edge e in E, both of e’s  vertices are in V. </li>
<li>Connected component: the maximally connected subgraphs of an undirected graph.</li>
</ul>

        <h4 id="spanning-tree"   >
          <a href="#spanning-tree" class="heading-link"><i class="fas fa-link"></i></a><a href="#spanning-tree" class="headerlink" title="spanning tree"></a>spanning tree</h4>
      <ul>
<li><p>acyclic graph: graph without circles</p>
</li>
<li><p>A tree is an acyclic connected graph.</p>
</li>
<li><p>A disjoint set of trees is called a forest. </p>
</li>
<li><p>A spanning tree of a connected graph is a subgraph that contains all of that graph’s vertices and is a single tree. </p>
</li>
<li><p>A spanning forest of a graph is the union of spanning trees of its connected components.</p>
</li>
<li><p>A graph is a tree if it is connected and there is a unique path between any two vertices</p>
<p><strong>The number of edges is |E| &#x3D; |V| – 1</strong> </p>
<p><strong>A spanning tree for a connected graph is not unique.</strong></p>
<p>The graph is acyclic, that is, it does not contain any cycles</p>
<p>Adding one more edge must create a cycle</p>
<p>Removing any one edge creates two disjoint non-empty sub-graphs</p>
</li>
</ul>

        <h3 id="表示图的方法"   >
          <a href="#表示图的方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#表示图的方法" class="headerlink" title="表示图的方法"></a>表示图的方法</h3>
      <ul>
<li>Binary-relation list Adjacency matrix Adjacency list</li>
<li>adjacency matrix<ul>
<li>对于undirected graph只需要存储一个upper三角形或者lower三角形n*(n-1)&#x2F;2</li>
</ul>
</li>
<li>adjacency list<ul>
<li>most efficient</li>
</ul>
</li>
<li>orthogonal list</li>
</ul>

        <h4 id="复杂度分析"   >
          <a href="#复杂度分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4>
      <ul>
<li>space</li>
<li></li>
</ul>

        <h2 id="theorem"   >
          <a href="#theorem" class="heading-link"><i class="fas fa-link"></i></a><a href="#theorem" class="headerlink" title="theorem"></a>theorem</h2>
      <p>- </p>
<ul>
<li><p>无向图或有向图中所有结点的度数之和&#x3D;边数的两倍</p>
<ul>
<li>每条边贡献两个度</li>
</ul>
</li>
<li><p>无向图或有向图中 度数为奇数的结点个数为偶数</p>
<ul>
<li><img   src="https://img-blog.csdnimg.cn/20191229113456512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RlYW1fc3dhbl9nb29zZQ==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RlYW1fc3dhbl9nb29zZQpx;"  alt="img"></li>
</ul>
</li>
<li><p><img   src="https://img-blog.csdnimg.cn/20191229150529228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RlYW1fc3dhbl9nb29zZQ==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RlYW1fc3dhbl9nb29zZQpx;"  alt="img"></p>
</li>
<li><p><strong>完全图一定属于连通图, 而连通图不一定属于完全图</strong></p>
<p>完全图要求任意一对顶点间均有边连接，而连通图只要求任意顶点间连通即有路径即可，并不一定有边连接这两顶点！</p>
</li>
</ul>

        <h2 id="mooc"   >
          <a href="#mooc" class="heading-link"><i class="fas fa-link"></i></a><a href="#mooc" class="headerlink" title="mooc"></a>mooc</h2>
      <ul>
<li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191610155.png" alt="image-20220908130814983"></p>
</li>
<li><p>无向的连通图就是或者有向的强连通图通过任意一个顶点都能够（直接或者通过其他顶点间接地）访问到其他所有顶点,自然一次深度优先遍历就可以访问到所有顶点<br>无向非连通图一次遍历只能访问到起点所在的连通分量,一个非连通无向图中有几个连通分量就需要从各个分量分别开始遍历才能访问到所有的顶点<br>有向的非强连通图则需要看起点如何,可能有些起点可以访问到其他顶点,可能有些不能</p>
</li>
<li><p>简单回路：除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路</p>
<p>回路：第一个顶点和最后一个顶点相同的路径</p>
<p>简单路径：顶点不重复出现的路径</p>
<p>路径：由顶点和相邻路径序列构成的边的序列</p>
<p>简单路径限制了顶点不能重复出现，简单回路限制了除了第一个顶点和最后一个顶点外的其余顶点不能重复出现</p>
</li>
<li><p>首先，不是所有的有向图都是有拓扑序的，只有 有向无环图 才有拓扑序，所以 有向无环图又被称为拓扑图 。</p>
</li>
<li><p>在n个结点的无向图中，若该图是连通图,则其边数大于等于n-1，<br>在n个结点的无向图中，若边数大于(n-2)(n-1)&#x2F;2，则该图必是连通图</p>
</li>
<li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191610329.png" alt="image-20220909183524489"></p>
</li>
<li><p>出和入2* 剩下n-1个点 2*(n-1)</p>
</li>
<li><p>对图中任意顶点u,v,都存在路径使u、v连通。由于是无向图故为n-1，若是有向图为n</p>
</li>
<li></li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhidao.baidu.com/question/206530163.html" >有n个顶点的强连通图最多有多少条边,最少有多少条边_百度知道 (baidu.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/92e10613145b4ee0a25f2d6b8699a81c" >下列关于无向连通图特性的叙述中，正确的是 Ⅰ.所有顶点的度_阿里巴巴笔试题_牛客网 (nowcoder.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
</ul>
<ol>
<li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191610434.png" alt="image-20220909192641993" style="zoom:50%;" />

<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/Deam_swan_goose/article/details/103751863" >reference</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p>n个顶点，最多的情况是每两个点有一条边，所以用Cn2，结果是n(n-1)&#x2F;2</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/853066cc75dd4e7a8ac3529e39db418f" >reference</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p>()</p>
</li>
<li><p>无向的连通图就是或者有向的强连通图通过任意一个顶点都能够（直接或者通过其他顶点间接地）访问到其他所有顶点,自然一次深度优先遍历就可以访问到所有顶点<br>无向非连通图一次遍历只能访问到起点所在的连通分量,一个非连通无向图中有几个连通分量就需要从各个分量分别开始遍历才能访问到所有的顶点<br>有向的非强连通图则需要看起点如何,可能有些起点可以访问到其他顶点,可能有些不能</p>
</li>
<li><p>简单回路：除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路</p>
<p>回路：第一个顶点和最后一个顶点相同的路径</p>
<p>简单路径：顶点不重复出现的路径</p>
<p>路径：由顶点和相邻路径序列构成的边的序列</p>
<p>简单路径限制了顶点不能重复出现，简单回路限制了除了第一个顶点和最后一个顶点外的其余顶点不能重复出现</p>
<p>首先，不是所有的有向图都是有拓扑序的，只有 <strong>有向无环图 才有拓扑序</strong>，所以 有向无环图又被称为拓扑图 。</p>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/92e10613145b4ee0a25f2d6b8699a81c" >下列关于无向连通图特性的叙述中，正确的是 Ⅰ.所有顶点的度_阿里巴巴笔试题_牛客网 (nowcoder.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>  答案：A </p>
<p>  1，每条边连接两个顶点，所有顶点的度之和等于边数的2倍，是偶数，正确 </p>
<p>  2，如两个顶点一条边的图就不满足这个条件，错 </p>
<p>  3，如三个顶点三条边连成一个三角形的图每个顶点度为2，错 </p>
</li>
<li><p>强连通有向图的任何顶点到其他所有顶点都有路径但未必有弧 无向图任意顶点入度&#x3D;出度 有向图不一定</p>
<p>有向图边集的子集和顶点集的子集无法构成子图</p>
<p>有向完全图一定是强连通有向图</p>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/1966baf847db4f66900f0bed40f5f905" >reference</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/af3696696d694fc288a5bf639e5342ae?source=relative" >无向图G有23条边，度为4的顶点有5个，度为3的顶点有4个，__牛客网 (nowcoder.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191610747.png" alt="image-20220909194949393"></p>
<ol>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/545dbf92b60c4e209fc8e8b4e441bb9a" >reference</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.jianshu.com/p/f174c97e626b" >reference1</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ol>
<p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191610107.png" alt="image-20220909200405207"></p>
<p>- </p>
<p>邻接表：只存储实际存在的信息</p>
<p>邻接矩阵：潜在的边也需要存 但是不用指针的开销</p>
<p>图的边很多 dense图 密集图 需要选邻接矩阵</p>
<p>系数图（sparse） 选择邻接表</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/11/19/06/">[ 文章无标题 ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-11-19</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-11-19</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="Shortest-Path-Problem"   >
          <a href="#Shortest-Path-Problem" class="heading-link"><i class="fas fa-link"></i></a><a href="#Shortest-Path-Problem" class="headerlink" title="Shortest Path Problem"></a>Shortest Path Problem</h1>
      
        <h2 id="Dijkstra’s-Algorithm"   >
          <a href="#Dijkstra’s-Algorithm" class="heading-link"><i class="fas fa-link"></i></a><a href="#Dijkstra’s-Algorithm" class="headerlink" title="Dijkstra’s Algorithm"></a>Dijkstra’s Algorithm</h2>
      
        <h3 id="适用范围"   >
          <a href="#适用范围" class="heading-link"><i class="fas fa-link"></i></a><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3>
      <ul>
<li><p>单源最短路径：求s到图中各顶带你的最短路径</p>
</li>
<li><p>relaxation：</p>
<p>Dijkstra’s and <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.baeldung.com/cs/bellman-ford" >Bellmann Ford’s</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> algorithm use a technique called edge relaxation. This means that during traversing our graph and finding our shortest path, we update the paths we have for already known nodes as soon as we find a shorter path to reach it.</p>
</li>
</ul>

        <h4 id="if-weights-of-all-edges-are-the-same"   >
          <a href="#if-weights-of-all-edges-are-the-same" class="heading-link"><i class="fas fa-link"></i></a><a href="#if-weights-of-all-edges-are-the-same" class="headerlink" title="if weights of all edges are the same"></a>if weights of all edges are the same</h4>
      <ul>
<li>Breadth-first search can be used to solve the single-source shortest path problem. Indeed, the tree rooted at s in the BFS tree is the solution</li>
</ul>

        <h3 id="code"   >
          <a href="#code" class="heading-link"><i class="fas fa-link"></i></a><a href="#code" class="headerlink" title="code"></a>code</h3>
      <ul>
<li><p>&#96;&#96;&#96;<br>int map[1005][1005];<br>int vis[1005],dis[1005];<br>int n,m;&#x2F;&#x2F;n个点，m条边<br>void Init ()<br>{<br>memset(map,Inf,sizeof(map));<br>for(int i&#x3D;1;i&lt;&#x3D;n;i++)<br>{<br>    map[i][i]&#x3D;0;<br>}<br>}<br>void Getmap()<br>{<br>int u,v,w;<br>for(int t&#x3D;1;t&lt;&#x3D;m;t++)<br>{<br>      scanf(“%d%d%d”,&amp;u,&amp;v,&amp;w);<br>      if(map[u][v]&gt;w)<br>      {<br>      map[u][v]&#x3D;w;<br>      map[v][u]&#x3D;w;<br>      }<br>}	<br>}<br>void Dijkstra(int u)<br>{<br>memset(vis,0,sizeof(vis));<br>for(int t&#x3D;1;t&lt;&#x3D;n;t++)<br>{<br>    dis[t]&#x3D;map[u][t];<br>}<br>vis[u]&#x3D;1;<br>for(int t&#x3D;1;t&lt;n;t++)<br>{<br>    int minn&#x3D;Inf,temp;<br>    for(int i&#x3D;1;i&lt;&#x3D;n;i++)<br>    {<br>        if(!vis[i]&amp;&amp;dis[i]&lt;minn)<br>        {<br>            minn&#x3D;dis[i];<br>            temp&#x3D;i;<br>        }<br>    }<br>    vis[temp]&#x3D;1;<br>    for(int i&#x3D;1;i&lt;&#x3D;n;i++)<br>    {<br>        if(map[temp][i]+dis[temp]&lt;dis[i])<br>        {<br>            dis[i]&#x3D;map[temp][i]+dis[temp];<br>        }<br>    }<br>}	<br>}</p>
<p>int main()<br>{<br>scanf(“%d%d”,&amp;m,&amp;n);<br>Init();<br>Getmap();<br>Dijkstra(n);<br>printf(“%d\n”,dis[1]);	<br>return 0;<br>}</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  [ref](https://blog.csdn.net/lbperfect123/article/details/84281300)</span><br><span class="line"></span><br><span class="line">### 复杂度分析</span><br><span class="line"></span><br><span class="line">- use a brute-force algorithm and spend 𝑂(|𝑉|) to look at all edges 𝑒=(𝑢,𝑣) (𝑢∈𝑆 and 𝑣∈𝑆′) for finding the minimum one, which takes 𝑂(|𝑉|^2) (because each time you are looking at the same edge that are not in the shortest path).</span><br><span class="line">- use a min-heap and spend 𝑂(log|𝑉|)for finding that edge, and achieve 𝑂((|𝑉|+|𝐸|)⋅log|𝑉|) overall running time.</span><br><span class="line"></span><br><span class="line">## Floyd&#x27;s algorithm</span><br><span class="line"></span><br><span class="line">### 适用范围</span><br><span class="line"></span><br><span class="line">- 顶点对之间的最短路径问题：任意顶点对&lt;vi,vj&gt;之间最短路径</span><br><span class="line">- 动态规划 自底向上</span><br><span class="line"></span><br><span class="line">### steps</span><br><span class="line"></span><br><span class="line">- [速通推导](https://www.youtube.com/watch?v=oNI0rf2P9gE)</span><br><span class="line">  - ![image-20221119141335481](https://raw.githubusercontent.com/pinkyrie/pic/main/202211191608177.png)</span><br><span class="line"></span><br><span class="line">- ![image-20221119142345476](https://raw.githubusercontent.com/pinkyrie/pic/main/202211191608587.png)</span><br><span class="line">- Floyd 算法是一个基于「贪心」、「动态规划」求一个图中 **所有点到所有点** 最短路径的算法，时间复杂度 O(n3)</span><br><span class="line">- 从任意节点i到任意节点j的最短路径不外乎2种可能，1是直接从i到j，2是从i经过若干个节点k到j。所以，我们假设Dis(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，我们检查Dis(i,k) + Dis(k,j) &lt; Dis(i,j)是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，我们便设置Dis(i,j) = Dis(i,k) + Dis(k,j)，这样一来，当我们遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。![image-20221119135257709](https://raw.githubusercontent.com/pinkyrie/pic/main/202211191608516.png)</span><br><span class="line"></span><br><span class="line">### code</span><br><span class="line"></span><br><span class="line">- ![image-20221119143235934](https://raw.githubusercontent.com/pinkyrie/pic/main/202211191608786.png)</span><br><span class="line"></span><br></pre></td></tr></table></div></figure></li>
</ul>
<p>for(int k&#x3D;0;k&lt;n;k++){<br>    for(int i&#x3D;0;i&lt;n;i++){<br>        for(int j&#x3D;0;j&lt;n;j++){<br>            A[i,j] &#x3D; min{A[i,j],A[i,k]+A[k,j]}; &#x2F;&#x2F;内层的两次for循环是对上一个k-1矩阵进行整个矩阵的更新 因此最外层共有k次据则矩阵的更新<br>        }<br>    }<br>}</p>
<p>&#96;&#96;&#96;</p>
<p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191609458.png" alt="image-20221119141125140"></p>
<p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191609098.png" alt="image-20221119141229306"></p>
<p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211191609529.png" alt="image-20221119142814197"></p>

        <h3 id="复杂度分析"   >
          <a href="#复杂度分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3>
      <ul>
<li>Time Complexity: O(V3) where V is the number of vertices</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/11/16/13/">[ 文章无标题 ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-11-16</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-11-19</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="hash"   >
          <a href="#hash" class="heading-link"><i class="fas fa-link"></i></a><a href="#hash" class="headerlink" title="hash"></a>hash</h2>
      <ul>
<li>A hash function maps key values to positions.</li>
</ul>

        <h3 id="basics"   >
          <a href="#basics" class="heading-link"><i class="fas fa-link"></i></a><a href="#basics" class="headerlink" title="basics"></a>basics</h3>
      <ul>
<li>Load factor lambda λ&#x3D; (number of keys &#x2F; Table Size)</li>
<li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211162323021.png" alt="image-20221113220132476"></li>
</ul>

        <h3 id="构造方法"   >
          <a href="#构造方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3>
      
        <h4 id="folding"   >
          <a href="#folding" class="heading-link"><i class="fas fa-link"></i></a><a href="#folding" class="headerlink" title="folding"></a>folding</h4>
      <ul>
<li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211162323599.png" alt="image-20221113223514997"></li>
</ul>

        <h2 id="开放定址法（不使用链表-也叫闭散列法）"   >
          <a href="#开放定址法（不使用链表-也叫闭散列法）" class="heading-link"><i class="fas fa-link"></i></a><a href="#开放定址法（不使用链表-也叫闭散列法）" class="headerlink" title="开放定址法（不使用链表 也叫闭散列法）"></a>开放定址法（不使用链表 也叫闭散列法）</h2>
      <ul>
<li>包括</li>
<li>线性探查法</li>
<li>二次探查法</li>
<li>伪随机探查法</li>
<li>二次散列法</li>
</ul>

        <h2 id="linear-probing"   >
          <a href="#linear-probing" class="heading-link"><i class="fas fa-link"></i></a><a href="#linear-probing" class="headerlink" title="linear probing"></a>linear probing</h2>
      
        <h3 id="unsuccessful-ASL"   >
          <a href="#unsuccessful-ASL" class="heading-link"><i class="fas fa-link"></i></a><a href="#unsuccessful-ASL" class="headerlink" title="unsuccessful ASL"></a>unsuccessful ASL</h3>
      <ul>
<li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211162323273.png" alt="image-20221027112336074"></li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/calculate23/article/details/100577469" >ref</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ul>

        <h3 id="primary-clustering"   >
          <a href="#primary-clustering" class="heading-link"><i class="fas fa-link"></i></a><a href="#primary-clustering" class="headerlink" title="primary clustering"></a>primary clustering</h3>
      <ul>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://stackoverflow.com/questions/27742285/what-is-primary-and-secondary-clustering-in-hash" >ref</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p>In computer programming, primary clustering is one of two major failure modes of open addressing based hash tables, especially those using linear probing. It occurs after a hash collision causes two of the records in the hash table to hash to the same position, and causes one of the records to be moved to the next location in its probe sequence. Once this happens, the cluster formed by this pair of records is more likely to grow by the addition of even more colliding records, regardless of whether the new records hash to the same location as the first two. This phenomenon causes searches for keys within the cluster to be longer.[1]</p>
<p>For instance, in linear probing, a record involved in a collision is always moved to the next available hash table cell subsequent to the position given by its hash function, creating a contiguous cluster of occupied hash table cells. Whenever another record is hashed to anywhere within the cluster, it grows in size by one cell. Because of this phenomenon, it is likely that a linear-probing hash table with a constant load factor (that is, with the size of the table proportional to the </p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Primary_clustering" >ref</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
</ul>

        <h2 id="quadratic-probing"   >
          <a href="#quadratic-probing" class="heading-link"><i class="fas fa-link"></i></a><a href="#quadratic-probing" class="headerlink" title="quadratic probing"></a>quadratic probing</h2>
      <ul>
<li>插入新元素：查找一次插入不成功 则i++ 而且要从最初的插入点开始+i^2 而不是上一次的插入点</li>
<li>解决了一次聚集</li>
<li>产生二次聚集</li>
</ul>
<p>奇怪的理论：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">If the table size is prime and load factor is not larger than 0.5, all probes will be to different locations and an item can always be inserted.</span><br><span class="line">==</span><br><span class="line">If quadratic probing is used, and the table size is prime, then a new element can always be inserted if the table is at least half empty.</span><br></pre></td></tr></table></div></figure>


        <h2 id="伪随机探查法"   >
          <a href="#伪随机探查法" class="heading-link"><i class="fas fa-link"></i></a><a href="#伪随机探查法" class="headerlink" title="伪随机探查法"></a>伪随机探查法</h2>
      <ul>
<li>解决二次聚集</li>
<li>但是</li>
</ul>

        <h2 id="double-hashing"   >
          <a href="#double-hashing" class="heading-link"><i class="fas fa-link"></i></a><a href="#double-hashing" class="headerlink" title="double hashing"></a>double hashing</h2>
      <ul>
<li>Techniques that eliminate secondary clustering are available. The most popular is <strong>double hashing.</strong></li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/double-hashing/" >Double Hashing - GeeksforGeeks</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ul>

        <h2 id="链接法-x2F-开散列法-x2F-拉链法"   >
          <a href="#链接法-x2F-开散列法-x2F-拉链法" class="heading-link"><i class="fas fa-link"></i></a><a href="#链接法-x2F-开散列法-x2F-拉链法" class="headerlink" title="链接法&#x2F;开散列法&#x2F;拉链法"></a>链接法&#x2F;开散列法&#x2F;拉链法</h2>
      <ul>
<li>不会出现冲突的聚集情况</li>
<li>如果散列表储存在内存中 链接法容易实现</li>
<li>如果散列表再磁盘中 一个同义词的链表可能存储在不同的磁盘块 导致查询一个特定记录时多次访问磁盘 增加查找时间</li>
<li></li>
</ul>

        <h2 id="桶定址法"   >
          <a href="#桶定址法" class="heading-link"><i class="fas fa-link"></i></a><a href="#桶定址法" class="headerlink" title="桶定址法"></a>桶定址法</h2>
      <ul>
<li>每个槽位不一定放一个元素 可以放多个（类似于拉链）</li>
<li>但是一个槽位满了就线性探查（或开放寻址）</li>
<li>会有冲突聚集</li>
</ul>
<p>装填因子决定平均查找长度（不是存储的记录个数或散列长度）</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> key_type, <span class="keyword">typename</span> hash_func, <span class="keyword">typename</span> key_equal&gt;</span><br><span class="line"><span class="type">bool</span> HashSet&lt;key_type, hash_func, key_equal&gt;::<span class="built_in">search</span>(<span class="type">const</span> key_type&amp; k) &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> pos = <span class="built_in">hf</span>(k) % prime_list[prime];</span><br><span class="line">    <span class="keyword">while</span> ((*ht)[pos].used == <span class="number">1</span> &amp;&amp; (*ht)[pos].key != k) &#123;</span><br><span class="line">        pos = <span class="built_in">probe</span>(k, ++i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((*ht)[pos].used == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> key_type, <span class="keyword">typename</span> hash_func, <span class="keyword">typename</span> key_equal&gt;</span><br><span class="line"><span class="type">void</span> HashSet&lt;key_type, hash_func, key_equal&gt;::<span class="built_in">remove</span>(<span class="type">const</span> key_type&amp; k) &#123;</span><br><span class="line">    <span class="type">int</span> pos = <span class="built_in">hf</span>(k) % prime_list[prime];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((*ht)[pos].used == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">eq</span>((*ht)[pos].key, k)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pos = <span class="built_in">probe</span>(k, ++i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((*ht)[pos].used == <span class="number">1</span>) &#123;</span><br><span class="line">        (*ht)[pos] = <span class="built_in">Entry</span>();</span><br><span class="line">        entries--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No element found in set&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> key_type, <span class="keyword">typename</span> hash_func, <span class="keyword">typename</span> key_equal&gt;</span><br><span class="line"><span class="type">void</span> HashSet&lt;key_type, hash_func, key_equal&gt;::<span class="built_in">insert</span>(<span class="type">const</span> key_type&amp; k) &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> pos = <span class="built_in">hf</span>(k) % prime_list[prime];</span><br><span class="line">    Entry item&#123; k,<span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*   if (entries != 0 &amp;&amp; entries &gt; prime_list[prime] * load_factor) &#123;</span></span><br><span class="line"><span class="comment">        resize();</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">load_factor</span>() &gt; <span class="number">0.75</span>) &#123;</span><br><span class="line">        <span class="built_in">resize</span>(); <span class="comment">// emmm</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((*ht)[pos].used == <span class="number">1</span> &amp;&amp; !<span class="built_in">eq</span>((*ht)[pos].key,k)) &#123;</span><br><span class="line">        pos = <span class="built_in">probe</span>(k, ++i);</span><br><span class="line">    &#125;</span><br><span class="line">    (*ht)[pos] = item;</span><br><span class="line">    entries++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> key_type, <span class="keyword">typename</span> hash_func, <span class="keyword">typename</span> key_equal&gt;</span><br><span class="line"><span class="type">int</span> HashSet&lt;key_type, hash_func, key_equal&gt;::<span class="built_in">resize</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prime == num_primes - <span class="number">1</span>) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;maximal table size reached, aborting ... &quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mm = prime_list[prime];</span><br><span class="line">    prime++;</span><br><span class="line">    <span class="type">int</span> m = prime_list[prime];</span><br><span class="line">    vector&lt;Entry&gt;* ptr = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;Entry&gt;(m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mm; ++i) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((*ht)[i].used == <span class="number">1</span>) &#123;</span><br><span class="line">            key_type kk = (*ht)[i].key;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> p = <span class="built_in">hf</span>(kk) % m; <span class="comment">//Ê¹ÓÃhash_func</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (p &lt; m &amp;&amp; (*ptr)[p].used == <span class="number">1</span>) &#123;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p == m) &#123;</span><br><span class="line">                p = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ((*ptr)[p].used == <span class="number">1</span>) &#123;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            (*ptr)[p].key = kk;</span><br><span class="line">            (*ptr)[p].used = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> ht;</span><br><span class="line">    ht = ptr;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/11/16/12/">[ 文章无标题 ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-11-16</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-11-19</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="sequential-search"   >
          <a href="#sequential-search" class="heading-link"><i class="fas fa-link"></i></a><a href="#sequential-search" class="headerlink" title="sequential search"></a>sequential search</h2>
      <p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211192214030.png" alt="image-20221119221445097"></p>

        <h2 id="binary-search"   >
          <a href="#binary-search" class="heading-link"><i class="fas fa-link"></i></a><a href="#binary-search" class="headerlink" title="binary search"></a>binary search</h2>
      
        <h3 id="binary-search-tree（区分我们要学的判定树）"   >
          <a href="#binary-search-tree（区分我们要学的判定树）" class="heading-link"><i class="fas fa-link"></i></a><a href="#binary-search-tree（区分我们要学的判定树）" class="headerlink" title="binary search tree（区分我们要学的判定树）"></a>binary search tree（区分我们要学的判定树）</h3>
      <ul>
<li><p>[树的高度](<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree" >Self-balancing binary search tree - Wikipedia</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>)</p>
</li>
<li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211162324256.png" alt="image-20221114205329151"></p>
</li>
<li><p>Binary Search Tree is a node-based binary tree data structure which has the following properties:</p>
<p>The left subtree of a node contains only nodes with keys lesser than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>The left and right subtree each must also be a binary search tree.</p>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/BST.html" >构建过程的动画</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
</ul>

        <h3 id="折半查找判定树"   >
          <a href="#折半查找判定树" class="heading-link"><i class="fas fa-link"></i></a><a href="#折半查找判定树" class="headerlink" title="折半查找判定树"></a>折半查找判定树</h3>
      <ul>
<li><img src="/assets/image-20221119222033400.png" alt="image-20221119222033400"></li>
</ul>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/zipeilu/p/14626027.html" >计算ASL</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ul>
<li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211192218737.png" alt="image-20221119221824327"></p>
<p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211192218415.png" alt="image-20221119221854558"></p>
</li>
</ul>

        <h2 id="B-tree-x2F-多分树"   >
          <a href="#B-tree-x2F-多分树" class="heading-link"><i class="fas fa-link"></i></a><a href="#B-tree-x2F-多分树" class="headerlink" title="B-tree&#x2F;多分树"></a>B-tree&#x2F;多分树</h2>
      
        <h3 id="basics"   >
          <a href="#basics" class="heading-link"><i class="fas fa-link"></i></a><a href="#basics" class="headerlink" title="basics"></a>basics</h3>
      <ul>
<li><p>balanced search tree</p>
</li>
<li><p>用途：disks or other direct access secondary storage devices (和红黑树相似 但是better at minimizing disk I&#x2F;O operations)</p>
<p>many database systems use B-trees or B树的变种 store information</p>
</li>
<li><p>如果一个node x有 n 个keys 那么 node x有n+1个children</p>
</li>
<li><p>the keys in node x serve as dividing points separating the range of keys handled by x into x.n+1 subranges, each handled by one child of x</p>
</li>
<li><p>树的高度是随着结点个数logarithmatically grow</p>
</li>
</ul>

        <h3 id="特征"   >
          <a href="#特征" class="heading-link"><i class="fas fa-link"></i></a><a href="#特征" class="headerlink" title="特征"></a>特征</h3>
      <ul>
<li>所有叶子结点出现在同一层</li>
<li>m阶的B树每个结点至多有m棵子树（All non-leaf nodes (except the root) have at most m and at least m&#x2F;2 children.）</li>
<li>key的个数比该结点的孩子个数少1（隔板比分割区域少1）</li>
<li>根结点至少有两棵子树</li>
</ul>

        <h3 id="基本信息"   >
          <a href="#基本信息" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3>
      
        <h4 id="order-vs-degree"   >
          <a href="#order-vs-degree" class="heading-link"><i class="fas fa-link"></i></a><a href="#order-vs-degree" class="headerlink" title="order vs degree"></a>order vs degree</h4>
      <p>Degree represents the lower bound on the number of children. i.e the minimum number possible. Whereas the Order represents the upper bound on the number of children.</p>
<ul>
<li><p>minimum degree: </p>
<ul>
<li><p>Nodes have lower and upper bounds on the number of keys they can contain. We express these bounds in terms of a fixed integer t &gt;&#x3D;2 called the <strong>minimum degree</strong> of the B-tree:</p>
<p>a. Every node other than the root must have at least t -1 keys. Every internal node other than the root thus has at least t children. If the tree is nonempty, the root must have at least one key.</p>
<p>b. Every node may contain at most 2t-1 keys. Therefore, an internal node may have at most 2t children. We say that a node is <strong>full</strong> if it contains exactly 2t -1 keys.</p>
</li>
</ul>
</li>
<li><p>t度的B树就是2t阶的B树 (这也是B树的分裂机制决定的)</p>
<p>因为t度的B树节点最多有2t个孩子，2t-1个关键字；m阶的B树最多有m个孩子，其实通过度定义的B树和通过阶数定义的B树，区别就是一个是用的这个B树节点的最小度数一个是用的这个树节点的最大度数。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.quora.com/Why-is-the-maximum-number-of-keys-in-a-B-tree-equal-to-2-t-1-where-t-is-the-minimum-degree" >reference: 为什么是2t-1</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p>[pointer,key,pointer,key,pointer]: pointer的个数就是degree 所以至少有t-1个key 如果最多的话 就是 2t-1（全都是key）</p>
</li>
<li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211162324799.png" alt="image-20221115203019698"></p>
<ul>
<li>为什么b-tree优于红黑树？</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211162326275.png" alt="image-20221115203845142"></p>
<ul>
<li><p>注意h是base t的log函数 我们通过调整t可以使得h的增长变得很慢 从而提高了访问效率</p>
<ul>
<li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211162326940.png" alt="image-20221115203945028"></li>
<li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211162324621.png" alt="image-20221022120147376" style="zoom:50%;" /></li>
<li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211162324305.png" alt="image-20221022120405193"></li>
</ul>
</li>
<li><p>order</p>
</li>
</ul>
<p>一棵m阶的B树满足下列条件：</p>
<p>1.树中每个结点至多有m个孩子。</p>
<p>2.除根结点和叶子结点外，其它每个结点至少有m&#x2F;2个孩子。</p>
<p>3.根结点至少有2个孩子（如果B树只有一个结点除外）,这条性质是由B树的插入分裂策略决定的。</p>
<p>4.所有叶结点在同一层，B树的叶结点可以看成一种外部节点，不包含任何信息。</p>
<p>4.有k个关键字(关键字按递增次序排列)的非叶结点恰好有k+1个孩子。</p>
<p>5.一个节点如果由n个关键字，则节点内数据结构为P0，K1，P1，K2，P2………Pn-1 Kn Pn 其中 p为指向其子节点的指针，因为父子的大小 关系和节点内大小关系，满足Kj 大于Pj指针所指向的子树上的所有关键字小雨Pj+1指针所指向子树上的所有关键字</p>
<ul>
<li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211162324077.png" alt="image-20221021112043966"></li>
</ul>

        <h3 id="opeartion-search-x2F-insert"   >
          <a href="#opeartion-search-x2F-insert" class="heading-link"><i class="fas fa-link"></i></a><a href="#opeartion-search-x2F-insert" class="headerlink" title="opeartion search&#x2F;insert"></a>opeartion search&#x2F;insert</h3>
      <ul>
<li>The procedures we present are all “one-pass” algorithms that proceed downward from the root of the tree, without having to back up.</li>
</ul>

        <h4 id="insert"   >
          <a href="#insert" class="heading-link"><i class="fas fa-link"></i></a><a href="#insert" class="headerlink" title="insert"></a>insert</h4>
      <ul>
<li><p>non-split insert</p>
</li>
<li><p>split insert</p>
<ul>
<li>普通split</li>
<li>root也满了需要h+1的split</li>
</ul>
</li>
<li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211162324189.png" alt="image-20221115205201747"></p>
</li>
</ul>

        <h4 id="delete"   >
          <a href="#delete" class="heading-link"><i class="fas fa-link"></i></a><a href="#delete" class="headerlink" title="delete"></a>delete</h4>
      <ul>
<li>Delete one record from a leaf node with two records.</li>
<li>Delete one record from a leaf node with one record. <ul>
<li>Borrow a record from a brother，modify the record of parent node. </li>
<li>Brother node does not have enough record，merge two nodes by deleting empty leaf and moving 21 down.</li>
<li>Brother node does not have enough record，merge two nodes by deleting the empty leaf and moving 12 down. Modify the parent nodes based on the similar process.</li>
<li>Brother node does not have enough record，merge two nodes，modify parent node. This may reduce the height of the tree.</li>
</ul>
</li>
<li>Delete a record from internal node. The least key Y of right subtree replace the deleted key. Y must be in a leaf node. Then delete it.</li>
</ul>

        <h3 id="拓展：磁盘读取"   >
          <a href="#拓展：磁盘读取" class="heading-link"><i class="fas fa-link"></i></a><a href="#拓展：磁盘读取" class="headerlink" title="拓展：磁盘读取"></a>拓展：磁盘读取</h3>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://tech.meituan.com/2017/05/19/about-desk-io.html" >re1</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ul>
<li>main memory vs secondary storage(disks)</li>
<li>增加磁盘platter(硬盘盘片)只是增加disk drive’s capacity not its performance</li>
</ul>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://medium.com/@andrewjmarkham1/disk-storage-data-indexing-and-a-use-case-for-b-trees-608ff56bffdd" >re2</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ul>
<li><p>数据库应用b-tree metadata 即寻找data 的index是利用b tree储存索引查找</p>
</li>
<li><p>the running time of a B-tree algorithm depends primarily on the number of DISK-READ and DISK-WRITE operations it performs, we typically want each of these operations to read or write as much information aspossible. Thus, a B-tree node is usually <strong>as large as a whole disk page</strong>, and this size limits the number of children a B-tree node can have.</p>
</li>
<li><p>branching factor指的是这个结点下有多少个孩子 则factor<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%88%86%E6%94%AF%E5%9B%A0%E5%AD%90" >就是几</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
</ul>

        <h3 id="exercise"   >
          <a href="#exercise" class="heading-link"><i class="fas fa-link"></i></a><a href="#exercise" class="headerlink" title="exercise"></a>exercise</h3>
      <ul>
<li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211162324586.png" alt="image-20221115204159554"></li>
<li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211162324143.png" alt="image-20221115204217841"></li>
</ul>

        <h2 id="2-3树"   >
          <a href="#2-3树" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h2>
      <ul>
<li>平衡树：任意节点的子树的高度差都小于等于1 2-3树的叶子结点都在同一层因此是平衡树</li>
<li>Comparison times are not larger than the height of 2-3 tree.</li>
</ul>

        <h2 id="B-tree"   >
          <a href="#B-tree" class="heading-link"><i class="fas fa-link"></i></a><a href="#B-tree" class="headerlink" title="B+ tree"></a>B+ tree</h2>
      <ul>
<li><strong>B+ -tree</strong>, stores all the satellite information in the leaves and stores only keys and child pointers in the internal nodes, thus maximizing the branching factor of the internal nodes.</li>
<li>Special cases: <ul>
<li>If the root is not a leaf, it has at least 2 children.</li>
<li>If the root is a leaf (that is, there are no other nodes in the tree), it can have between 0 and (n–1) values.</li>
</ul>
</li>
</ul>
<p><img src="/assets/image-20221119221136727.png" alt="image-20221119221136727"></p>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/2/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://github.com/pinkyrie/pic/blob/main/202204272046093.JPG?raw=true" alt="avatar"></div><p class="sidebar-ov-author__text">be happy</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/pinkyrie" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="954365771" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">42</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">4</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">3</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2024</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>rye</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>