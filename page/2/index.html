<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="过期的jk">
<meta property="og:type" content="website">
<meta property="og:title" content="rye is coding">
<meta property="og:url" content="https://pinkyrie.github.io/page/2/index.html">
<meta property="og:site_name" content="rye is coding">
<meta property="og:description" content="过期的jk">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="rye">
<meta name="twitter:card" content="summary"><title>rye is coding</title><link ref="canonical" href="https://pinkyrie.github.io/page/2/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fa fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">rye is coding</div><div class="header-banner-info__subtitle"></div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/01/30/post/">tetris开发笔记</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-01-30</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2023-01-30</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="多个头文件-定义类的h文件中的全局变量的问题"   >
          <a href="#多个头文件-定义类的h文件中的全局变量的问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#多个头文件-定义类的h文件中的全局变量的问题" class="headerlink" title="多个头文件 定义类的h文件中的全局变量的问题"></a>多个头文件 定义类的h文件中的全局变量的问题</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br></pre></td></tr></table></div></figure>

<p>为什么.h文件中不能定义全局变量</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/01/27/DS-0/">DS-0</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-01-27</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2023-01-27</span></span></div></header><div class="post-body"><div class="post-excerpt"></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/01/09/vue-3/">vue-3</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-01-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2023-05-31</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h3 id="键盘事件"   >
          <a href="#键盘事件" class="heading-link"><i class="fas fa-link"></i></a><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3>
      <p><img src="/assets/image-20230110160411408.png" alt="image-20230110160411408"></p>

        <h3 id="定时器的函数不是vue管理的"   >
          <a href="#定时器的函数不是vue管理的" class="heading-link"><i class="fas fa-link"></i></a><a href="#定时器的函数不是vue管理的" class="headerlink" title="定时器的函数不是vue管理的"></a>定时器的函数不是vue管理的</h3>
      <ul>
<li>不是vue管理的</li>
<li>箭头函数的this和普通函数的this</li>
<li>箭头函数会寻找外面函数的this作为自己的this</li>
<li><img src="/assets/image-20230128113016137.png" alt="image-20230128113016137"></li>
</ul>

        <h3 id="不能亲自去修改dom"   >
          <a href="#不能亲自去修改dom" class="heading-link"><i class="fas fa-link"></i></a><a href="#不能亲自去修改dom" class="headerlink" title="不能亲自去修改dom"></a>不能亲自去修改dom</h3>
      <ul>
<li><p>引入vue的本意就是通过vue去修改dom</p>
</li>
<li><p><img src="/assets/image-20230128114224306.png" alt="image-20230128114224306"></p>
<p>这种方式是不可取的</p>
</li>
<li><p><img src="/assets/image-20230128132724077.png" alt="image-20230128132724077"></p>
</li>
<li><p><img src="/assets/image-20230128132836111.png" alt="image-20230128132836111"></p>
<p>template不会破坏结构 对比新建一个div把属性包裹起来 template不会新键div</p>
<p>template只能配合v-if使用</p>
</li>
</ul>
<p><img src="/assets/image-20230128132935691.png" alt="image-20230128132935691"></p>

        <h3 id="列表渲染"   >
          <a href="#列表渲染" class="heading-link"><i class="fas fa-link"></i></a><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3>
      <p><img src="/assets/image-20230201094926427.png" alt="image-20230201094926427"></p>
<p><img src="/assets/image-20230201095042094.png" alt="image-20230201095042094"></p>
<img src="assets/image-20230201103022263.png" alt="image-20230201103022263" style="zoom:50%;" />

<img src="assets/image-20230201103105598.png" alt="image-20230201103105598" style="zoom:50%;" />

<p><img src="/assets/image-20230201103245975.png" alt="image-20230201103245975"></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/01/07/Untitled/">[ 文章无标题 ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-01-07</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2023-01-09</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>导热系数也叫导热率（thermal conductivity），导热系数是指在稳定传热条件下，1m厚的材料，两侧表面的温差为1度（K,°C）,在1秒钟的时间内，通过1平方米面积传递的热量，单位为瓦&#x2F;米.度（W&#x2F;m.K，此处的K也可以用°C代替）。是表示材料热传导能力大小的物理量，使用傅立叶定律作为其导热系数的计算公式</p>
<p><img src="/assets/image-20230107163856272.png" alt="image-20230107163856272"></p>
<p><img src="/assets/image-20230107170411564.png" alt="image-20230107170411564"></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://webvpn.dlut.edu.cn/https/77726476706e69737468656265737421fbe5449d23357a1e7d0682a5d65b2621/Kreader/CatalogViewPage.aspx?dbCode=cdmd&filename=1021031498.nh&tablename=CMFD202102&compose=&first=1&uid=WEEvREcwSlJHSldSdmVqMVc3L25vSktXQmU0TWVXRXRUZk1rRWoyaG03MD0=$" >论文在线阅读—中国知网 (dlut.edu.cn)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>They have found that as the power input level increases, so does the rate of sensible heat accumulation. Hosseinizadeh et al. [14] reported a parametric study on a plate fin PCM heat sink and found that increasing the number and the height of fins results in a considerable improvement in the heat sink performance, whereas increasing fin thickness just leads to a slight enhancement.</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.sciencedirect.com/science/article/pii/S0196890415006548" >A numerical method for PCM-based pin fin heat sinks optimization - ScienceDirect</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ul>
<li><p>Phase change heat storage tanks with fins are designed to store thermal energy in the form of a phase change material (PCM). The fins on the outside of the tank help to increase the surface area of the tank, which allows for more efficient heat transfer.</p>
<p>Here’s how it works:</p>
<p>The PCM is charged by heating it up to its melting point. This can be done using a variety of methods, such as solar thermal energy, electricity, or a combination of both.</p>
<p>As the PCM melts, it absorbs a large amount of heat. This heat is stored in the PCM in the form of latent heat of fusion.</p>
<p>The heat stored in the PCM can then be used to meet a variety of thermal energy needs, such as space heating or hot water.</p>
<p>When the PCM needs to release its stored heat, it is cooled down below its melting point. This causes the PCM to solidify and release its stored heat in the form of sensible heat.</p>
<p>The fins on the outside of the tank help to dissipate the heat released by the PCM, making it more readily available for use.</p>
<p>Overall, phase change heat storage tanks with fins are a highly efficient way to store and release thermal energy, making them a valuable tool for meeting a variety of energy needs.</p>
</li>
<li></li>
<li><p>计算多个翅片的相变储热罐的传热量可以使用传热学方程来计算。这个方程的形式是：</p>
<p>Q &#x3D; U * A * ΔT</p>
<p>其中，Q是传热量，U是翅片的传热系数，A是翅片的面积，ΔT是温度差。</p>
<p>要计算多个翅片的传热量，可以将每个翅片的传热量求和。</p>
<p>例如，如果有三个翅片，则传热量为：</p>
<p>Q &#x3D; (U1 * A1 * ΔT1) + (U2 * A2 * ΔT2) + (U3 * A3 * ΔT3)</p>
<p>注意，传热系数U、面积A和温度差ΔT均为每个翅片的值。</p>
</li>
<li><p><img src="/assets/image-20230108114453503.png" alt="image-20230108114453503"></p>
</li>
</ul>
<p><img src="/assets/image-20230108114539639.png" alt="image-20230108114539639"></p>
<p>E:\codepractice\亚太杯&gt;echo %PATH%<br>C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\WINDOWS\System32\WindowsPowerShell\v1.0;C:\WINDOWS\System32\OpenSSH;C:\Program Files\NVIDIA Corporation\NVIDIA NvDLISR;</p>
<p>E:\soft\Nodejs;</p>
<p>E:\soft\nvm\v16.17.1\node_global\node_modules\hexo\bin;</p>
<p>D:\mingw\mingw64\bin;E:\soft\nvm\v16.17.1\node_global;</p>
<p>E:\soft\nvm;E:\soft\Nodejs;</p>
<p>D:\MySQL\bin;C:\Program Files (x86)\NVIDIA Corporation\PhysX\Common;C:\Program Files\Git\cmd;C:\Users\95436\AppData\Local\Microsoft\WindowsApps;</p>
<p>C:\Users\95436\AppData\Local\Programs\Microsoft VS Code\bin;E:\soft\nvm;</p>
<p>E:\soft\Nodejs;D:\PyCharm 2022.3\bin;</p>
<ul>
<li><p>For the numerical analysis of the thermal process, the following assumptions were made: (1) the melting was Newtonian and incompressible; (2) the flow in the melting process was laminar and unsteady, with negligible viscous dissipations; (3) the thermos-physical properties of the HTF and the PCM were independent of the temperature; (4) the heat-transfer was both conduction and convection-controlled. The three-dimensional convection is not considered, because a two-dimensional model is used.</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.sciencedirect.com/science/article/pii/S0038092X17305273" >reference</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p>The viscous dissipation term is neglected.</p>
<ul>
<li>The Boussinesq approximation is used to consider the effect of<br>natural convection</li>
<li></li>
</ul>
</li>
<li><p><img src="/assets/image-20230108181641124.png" alt="image-20230108181641124"></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.sciencedirect.com/science/article/pii/S092702482100444X" >reference</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p>对比</p>
<p>4.3.3. Total energy stored for PCM-fins<br>Fig. 15 illustrates the total energy stored for the PCM in TTHX-longitudinal&#x2F;triangular fins simulated using Fluent 15 software at different times of the melting process. PCM-longitudinal fins for the internal fins configuration has lower energy stored capacity, compared with the same PCM mass with triangular fins. In addition, Table 4 shows that the liquid fraction values for PCM-triangular fin models were higher than those of the PCM-longitudinal fin models. Consequently, the energy transfer rate by triangular fins takes shorter time than longitudinal fins. The PCM-triangular fins model exhibits effective energy storage because of the enhancement in heat-transfer.</p>
<p><a target="_blank" rel="noopener" href="https://www.sciencedirect.com/science/article/pii/S0038092X17305273"><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.sciencedirect.com/science/article/pii/S0038092X17305273" >Experimental and computational study of melting phase-change material in a triplex tube heat exchanger with longitudinal&#x2F;triangular fins - ScienceDirect</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></a></p>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.zhihu.com/question/20414508" >(99+ 封私信 &#x2F; 80 条消息) 物体的单位时间内能吸热多少怎么计算？ - 知乎 (zhihu.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhidao.baidu.com/question/135038522.html" >热传导率与比热容算物体升温时间_百度知道 (baidu.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
</ul>
<p>\frac{\partial H}{\partial t} &#x3D; \nabla(K_k(\nabla\ T))</p>
<ul>
<li>fins  are  introduced  to  enhance  heat  transfer</li>
</ul>
<p>Using the basic heat exchanger equation, we can determine the heat transfer area required for the design  basic heat exchanger.</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/01/03/vue-2/">vue-2</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-01-03</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2023-05-31</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h3 id="数据双向绑定"   >
          <a href="#数据双向绑定" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据双向绑定" class="headerlink" title="数据双向绑定"></a>数据双向绑定</h3>
      
        <h4 id="v-model"   >
          <a href="#v-model" class="heading-link"><i class="fas fa-link"></i></a><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h4>
      <ul>
<li><p>只能运用在表单类（输入类）元素上（input,select）</p>
<p>体现用户交互对数据产生影响 数据又重新渲染到页面</p>
</li>
<li><p>标签类（h1234）上不能使用</p>
<p>标签类元素并不接受用户输入 所以不会影响到数据</p>
</li>
</ul>

        <h3 id="用户自定义代码片段"   >
          <a href="#用户自定义代码片段" class="heading-link"><i class="fas fa-link"></i></a><a href="#用户自定义代码片段" class="headerlink" title="用户自定义代码片段"></a>用户自定义代码片段</h3>
      
        <h3 id="vue所管理的函数"   >
          <a href="#vue所管理的函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#vue所管理的函数" class="headerlink" title="vue所管理的函数"></a>vue所管理的函数</h3>
      <p>vue管理的函数（比如函数式的data）不能写成箭头式函数 否则他的this就不是vue而是window了</p>

        <h2 id="MVVM模型"   >
          <a href="#MVVM模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#MVVM模型" class="headerlink" title="MVVM模型"></a>MVVM模型</h2>
      <p>M:model(对应data中的数据)</p>
<p>V:view(模板)</p>
<p>VM:view model(vue实例对象)</p>

        <h2 id="dom结构"   >
          <a href="#dom结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#dom结构" class="headerlink" title="dom结构"></a>dom结构</h2>
      <p>DOM是Document Object Model(文档对象模型)的缩写，HTML DOM则是专门适用与HTML&#x2F;XHTML的文档对象模型。熟悉软件开发的人员可以将HTML DOM理解为网页的API。它将网页中的各个元素都看作一个个对象，从而使网页中的元素也可以被计算机语言获取或者编辑。 例如Javascript就可以利用HTML DOM动态的修改网页。</p>
<p>关于对象引用方式,一,DOM对象引用,二,自定义的对象引用</p>

        <h2 id="原型链（vm里面的所有属性）"   >
          <a href="#原型链（vm里面的所有属性）" class="heading-link"><i class="fas fa-link"></i></a><a href="#原型链（vm里面的所有属性）" class="headerlink" title="原型链（vm里面的所有属性）"></a>原型链（vm里面的所有属性）</h2>
      
        <h2 id="数据代理"   >
          <a href="#数据代理" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h2>
      <p><img src="/assets/image-20230105154311421.png" alt="image-20230105154311421"></p>
<ul>
<li>只有写在data中的元素（不论是数据还是函数）才都会进行数据代理 但是如果是函数用数据代理是没有意义的</li>
<li>数据代理会给该元素配置getter和setter 数据由于会随时改变所以需要读取和修改 但是函数只是被调用 因此不需要getter和setter</li>
<li>函数应该写在methods中</li>
</ul>

        <h3 id="mouse-event-x2F-pointer-event"   >
          <a href="#mouse-event-x2F-pointer-event" class="heading-link"><i class="fas fa-link"></i></a><a href="#mouse-event-x2F-pointer-event" class="headerlink" title="mouse event&#x2F;pointer event"></a>mouse event&#x2F;pointer event</h3>
      <p>目前绝大多数的 Web 内容都假设用户的指针定点设备为鼠标。然而，近年来的新兴设备支持更多不同方式的指针定点输入，如各类触控笔和触摸屏幕等。这就有必要扩展现存的定点设备事件模型，以有效追踪各类*<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Pointer_events#term_pointer_event" >指针事件</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>*。</p>
<p>指针事件 - Pointer events 是一类可以为定点设备所触发的 DOM 事件。它们被用来创建一个可以有效掌握各类输入设备（鼠标、触控笔和单点或多点的手指触摸）的统一的 DOM 事件模型。所谓 <em><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Pointer_events#term_pointer" >指针</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></em> 是指一个可以明确指向屏幕上某一组坐标的硬件设备。建立这样一个单独的事件模型可以有效的简化 Web 站点与应用所需的工作，同时也便于提供更加一致与良好的用户体验，无需关心不同用户和场景在输入硬件上的差异。另外，对于某些需要处理特定设备的场景，指针事件也定义了一个 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType"><code>pointerType</code> (en-US)</a> 属性用以查看触发事件的设备类型。</p>
<p>这些事件需要能够处理 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent"><code>mouse events</code></a> 之类较为通用的指针输入（<code>mousedown/pointerdown</code>, <code>mousemove/pointermove</code>, 等）。因此，指针事件的类型，很大程度上类似于当前的鼠标事件类型。</p>

        <h2 id="js事件冒泡"   >
          <a href="#js事件冒泡" class="heading-link"><i class="fas fa-link"></i></a><a href="#js事件冒泡" class="headerlink" title="js事件冒泡"></a>js事件冒泡</h2>
      <ul>
<li><p>js中的事件流分为捕获阶段和冒泡阶段</p>
</li>
<li><p>捕获事件 -&gt; 事件冒泡</p>
</li>
<li><p>由外到内 由内到外</p>
</li>
</ul>
<p>vue事件修饰符</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/01/03/vue-1/">vue-1</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-01-03</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2023-05-31</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="environment"   >
          <a href="#environment" class="heading-link"><i class="fas fa-link"></i></a><a href="#environment" class="headerlink" title="environment"></a>environment</h2>
      <ul>
<li>live server</li>
<li>vue snippet</li>
</ul>

        <h3 id="模板语法"   >
          <a href="#模板语法" class="heading-link"><i class="fas fa-link"></i></a><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3>
      
        <h4 id="插值语法"   >
          <a href="#插值语法" class="heading-link"><i class="fas fa-link"></i></a><a href="#插值语法" class="headerlink" title="插值语法"></a>插值语法</h4>
      <p>id选择器</p>
<p>类选择器</p>
<ul>
<li>解析标签体内容（注意<code>&#123;&#123;&#125;&#125;</code>是js表达式 区分 js语句）</li>
<li>hhh <code>两个&#123;&#125;</code>会引起hexo报错</li>
</ul>

        <h4 id="指令语法"   >
          <a href="#指令语法" class="heading-link"><i class="fas fa-link"></i></a><a href="#指令语法" class="headerlink" title="指令语法"></a>指令语法</h4>
      <ul>
<li>用于解析标签（包括标签属性，标签体内容，绑定事件…）</li>
<li>指令通常都是v-开头的</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/11/19/11/">[ 文章无标题 ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-11-19</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-11-19</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="顺序查找法"   >
          <a href="#顺序查找法" class="heading-link"><i class="fas fa-link"></i></a><a href="#顺序查找法" class="headerlink" title="顺序查找法"></a>顺序查找法</h1>
      <ul>
<li><p>如果查找的关键字不在线性表中 需要进行n+1次关键字的比较</p>
</li>
<li><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211192211924.png" alt="image-20221013134306357"></p>
</li>
</ul>

        <h3 id="sequential-search"   >
          <a href="#sequential-search" class="heading-link"><i class="fas fa-link"></i></a><a href="#sequential-search" class="headerlink" title="sequential search"></a>sequential search</h3>
      <ul>
<li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211192212152.png" alt="image-20221013135040886"></li>
</ul>

        <h2 id="折半查找"   >
          <a href="#折半查找" class="heading-link"><i class="fas fa-link"></i></a><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2>
      
        <h3 id="basics"   >
          <a href="#basics" class="heading-link"><i class="fas fa-link"></i></a><a href="#basics" class="headerlink" title="basics"></a>basics</h3>
      <ul>
<li>需要对数据元素进行编号访问 必须存储在数组中</li>
<li></li>
</ul>

        <h3 id="折半查找树"   >
          <a href="#折半查找树" class="heading-link"><i class="fas fa-link"></i></a><a href="#折半查找树" class="headerlink" title="折半查找树"></a>折半查找树</h3>
      <ul>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/zhupengqq/article/details/51837908" >计算平均查找长度（成功&#x2F;不成功</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><ul>
<li>成功：从根结点数到待查找结点一共经过的结点数</li>
<li>不成功：补缺失的结点</li>
</ul>
</li>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/zipeilu/p/14626027.html" >折半查找平均查找长度推导 - zipeilu - 博客园 (cnblogs.com)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li></li>
</ul>
<p>binary search</p>
<ul>
<li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211192212440.png" alt="image-20221013141320990"></li>
</ul>

        <h3 id="block-search-（linear-search的改进）"   >
          <a href="#block-search-（linear-search的改进）" class="heading-link"><i class="fas fa-link"></i></a><a href="#block-search-（linear-search的改进）" class="headerlink" title="block search （linear search的改进）"></a><strong>block search （linear search的改进）</strong></h3>
      <ul>
<li><p>不要求等分块儿（块儿里元素个数不要求都相等）</p>
</li>
<li><p>不限制顺序</p>
</li>
<li><p>前一块的最大键码 小于 第二块的最小键码</p>
</li>
</ul>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.tutorialspoint.com/implementing-block-search-in-javascript" >实现code</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="B-tree-–balanced-tree-amp-多分树"   >
          <a href="#B-tree-–balanced-tree-amp-多分树" class="heading-link"><i class="fas fa-link"></i></a><a href="#B-tree-–balanced-tree-amp-多分树" class="headerlink" title="B-tree –balanced tree&amp;多分树"></a>B-tree –balanced tree&amp;多分树</h3>
      
        <h4 id="basics-1"   >
          <a href="#basics-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#basics-1" class="headerlink" title="basics"></a>basics</h4>
      <ul>
<li>控制树的高度比较小 所以磁盘的读取比较少</li>
<li></li>
<li>所有叶子结点必须在同一层（方便查找失败的处理）</li>
<li>k个子节点的非叶子节点包含k-1个关键码</li>
<li></li>
</ul>

        <h3 id="2-3-tree"   >
          <a href="#2-3-tree" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-3-tree" class="headerlink" title="2-3 tree"></a>2-3 tree</h3>
      <ul>
<li><p>b-tree的延申</p>
</li>
<li></li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43305485/article/details/120619942" >二分查找 的 树的结构</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
</ul>
<p><img src="/assets/image-20221018104651165.png" alt="image-20221018104651165"></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/11/19/10/">[ 文章无标题 ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-11-19</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-13</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="二部图"   >
          <a href="#二部图" class="heading-link"><i class="fas fa-link"></i></a><a href="#二部图" class="headerlink" title="二部图"></a>二部图</h2>
      <ul>
<li>边的限制（两个顶点分别在两个子集）</li>
</ul>

        <h3 id="判断二部图"   >
          <a href="#判断二部图" class="heading-link"><i class="fas fa-link"></i></a><a href="#判断二部图" class="headerlink" title="判断二部图"></a>判断二部图</h3>
      
        <h4 id="染色法"   >
          <a href="#染色法" class="heading-link"><i class="fas fa-link"></i></a><a href="#染色法" class="headerlink" title="染色法"></a>染色法</h4>
      <ul>
<li>对于二分图的判断方法最常见的是染色法，顾名思义就是我们对每一个点进行染色操作，我们只用黑白两种颜色，问能不能使所有的点都染上了色，而且相邻两个点的颜色不同，如果可以那么这个图就是一个二分图，对于判断是否是一个二分图的方法可以用dfs和bfs两种方式去实现。</li>
<li>定理：<strong>一张图是二分图，当且仅当图中不存在奇环（长度为奇数的环）。一定不含有奇数环，可能包含长度为偶数的环， 不一定是连通图</strong>定理：</li>
<li><strong>当且仅当</strong>无向图G的<strong>每一个环</strong><br>的结点数<strong>均是偶数</strong>时，图G才是一个二分图。<strong>如果无环，相当于每的结点数为 0，故也视为二分图。</strong></li>
<li>使用深度优先搜索对图进行染色，共两种颜色。有边相连的两个点染成不同的颜色。若染色过程中出现冲突，则该图不是二分图。否则是二分图。</li>
<li>通过顶点的neighbor染色：BFS</li>
</ul>

        <h3 id="对于无权二部图的最大匹配"   >
          <a href="#对于无权二部图的最大匹配" class="heading-link"><i class="fas fa-link"></i></a><a href="#对于无权二部图的最大匹配" class="headerlink" title="对于无权二部图的最大匹配"></a>对于无权二部图的最大匹配</h3>
      <ul>
<li>matching是edges的子集 matching不能含有有共同顶点的边</li>
<li>Bipartite matching is the problem of finding a <strong>subgraph</strong> in a bipartite graph where no two edges share an endpoint.</li>
</ul>

        <h3 id="有权二部图的最大匹配"   >
          <a href="#有权二部图的最大匹配" class="heading-link"><i class="fas fa-link"></i></a><a href="#有权二部图的最大匹配" class="headerlink" title="有权二部图的最大匹配"></a>有权二部图的最大匹配</h3>
      <ul>
<li>如果权重有正有负-&gt;等价于找到最小化匹配（即不喜欢为正 喜欢为负）</li>
</ul>

        <h4 id="匈牙利算法"   >
          <a href="#匈牙利算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h4>
      <ul>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/smuxiaolei/p/8343472.html" >简单理解思想—-递归的腾位置</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ul>
<p>先把最大匹配转化为最小匹配然后使用匈牙利算法</p>
<ul>
<li>限制条件：必须二部图的两个子集是元素个数相等的</li>
<li>O(n^3)</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/11/19/09/">[ 文章无标题 ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-11-19</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-10-16</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h3 id="basics"   >
          <a href="#basics" class="heading-link"><i class="fas fa-link"></i></a><a href="#basics" class="headerlink" title="basics"></a>basics</h3>
      
        <h4 id="流网络"   >
          <a href="#流网络" class="heading-link"><i class="fas fa-link"></i></a><a href="#流网络" class="headerlink" title="流网络"></a>流网络</h4>
      <ul>
<li><p>flow network: the graph is connected and since each vertex other than s(source) has at least one entering edge</p>
<ul>
<li>so |E| &gt;&#x3D; |V| - 1</li>
</ul>
</li>
<li><p>两个constraints</p>
<ul>
<li>capacity constraint:</li>
<li>flow conservation: flow in equals flow out</li>
</ul>
</li>
<li><p>flow：实际流量</p>
</li>
<li><p>capacity：最大容量</p>
</li>
<li><p>residual：余量&#x3D;最大容量-实际流量</p>
</li>
<li><p>blocking flow: A blocking flow is a union of flows along admissible paths that <strong>saturate at least one arc</strong> on every admissible path. (也就是naive algorithm得到的解)</p>
</li>
</ul>

        <h4 id="最小割-min-cut"   >
          <a href="#最小割-min-cut" class="heading-link"><i class="fas fa-link"></i></a><a href="#最小割-min-cut" class="headerlink" title="最小割 min cut"></a>最小割 min cut</h4>
      <ul>
<li><p>a cut whose capacity is minimum over all cuts of the network</p>
<ul>
<li>区分一下capacity and flow</li>
<li>flow是有方向的 （向量）必须带符号进行加减</li>
<li>capacity是无方向（标量） 只考虑一个方向最大的即可</li>
</ul>
</li>
<li><p>最小割的capacity 会 限制最大流的值 因为最大流</p>
</li>
</ul>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/flying_coding/article/details/106973854" >reference</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ul>
<li>思考这样一个问题：在给定的图中，如何判断一个源点s到终点t是否有路径存在呢？<ul>
<li><strong>若从S到T的路径为零，则不存在s到t的路径，其中s∈S，t∈T。</strong></li>
<li><strong>一个图中从s到t的路径最多不超过其S,T最小割的数量,其中s∈S，t∈T。</strong></li>
</ul>
</li>
</ul>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/65793018" >reference</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ul>
<li>[对最大流最小割定理的证明]([Max-flow Min-cut Algorithm | Brilliant Math &amp; Science Wiki](<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://brilliant.org/wiki/max-flow-min-cut-algorithm/#:~:text=The" >https://brilliant.org/wiki/max-flow-min-cut-algorithm/#:~:text=The</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> max-flow min-cut theorem is a network flow,would totally disconnect the source from the sink.))</li>
<li></li>
</ul>

        <h3 id="Naive-algorithm"   >
          <a href="#Naive-algorithm" class="heading-link"><i class="fas fa-link"></i></a><a href="#Naive-algorithm" class="headerlink" title="Naive algorithm"></a>Naive algorithm</h3>
      
        <h4 id="步骤"   >
          <a href="#步骤" class="heading-link"><i class="fas fa-link"></i></a><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4>
      <ul>
<li>初始化的residual 图 &#x3D;&#x3D; original 图</li>
<li>选择Augmenting path（a path from 𝑠 to 𝑡 that does not contain cycles.）</li>
</ul>

        <h3 id="Ford-Fulkerson"   >
          <a href="#Ford-Fulkerson" class="heading-link"><i class="fas fa-link"></i></a><a href="#Ford-Fulkerson" class="headerlink" title="Ford-Fulkerson"></a>Ford-Fulkerson</h3>
      
        <h4 id="basics-1"   >
          <a href="#basics-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#basics-1" class="headerlink" title="basics"></a>basics</h4>
      <ul>
<li><p>核心：residual networks, augmenting paths, cuts</p>
</li>
<li><p>although each iteration of the method increases the value of the flow, we shall see that the flow on any particular edge of G may increase or decrease.</p>
<p>decreasing the flow on some edges may INCREASE the total flow from source to sink.</p>
</li>
<li><p>residual graph中引入了相反方向的edge是为了表达decrease这条边的流量（sending the flow back along an edge is equivalent to decreasing the flow on the edge)</p>
<p>residual graph中的edge数量小于等于原本edges数量的两倍</p>
</li>
<li><p>结束条件：residual network contains no augmenting path</p>
</li>
</ul>

        <h4 id="reference"   >
          <a href="#reference" class="heading-link"><i class="fas fa-link"></i></a><a href="#reference" class="headerlink" title="reference"></a>reference</h4>
      <ul>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.desgard.com/algo/docs/part4/ch03/2-ford-fulkerson/" >basics</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ul>
<li><strong>通过将流量推回这种操作，从而得到新的流</strong> 。为什么要这么做呢？其实原因就是 <strong>因为对一条增广路不一定输入这条增广路的上限流量就能保证全局的最大流量</strong> 。再提高一个维度来看我们之前的思路，<strong>其实一直是“贪心”思想在引导我们加流和拆边操作，但是贪心并不能获得全局最大流量，这也是之前动态规划能够解决贪心对于全局最优解无法实现的问题</strong> 。</li>
<li>贪心只能得到局部的最优解 因此naive算法得到的不会是最终的最大流解</li>
</ul>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://emory.gitbook.io/dsa-java/network-flow/ford-fulkerson-algorithm" >演示worst case为什么是f*m</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p>Ford-Fulkerson算法的时间复杂度取决于增广路径如何决定</p>
<p>如果所有的容量都是整数，有一个Ford-Fulkerson算法的直接实现的时间复杂度O(|E||f*|),其中f*由算法决定</p>
</li>
</ul>

        <h4 id="步骤-1"   >
          <a href="#步骤-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4>
      <ul>
<li><p>允许undo path</p>
</li>
<li><p>最后删除所有的undo path</p>
</li>
<li><p>时间复杂度</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://stackoverflow.com/questions/33565995/time-complexity-of-the-ford-fulkerson-method-in-a-flow-network-with-unit-capacit" >algorithm - Time complexity of the Ford-Fulkerson method in a flow network with unit capacity edges - Stack Overflow</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
</ul>

        <h3 id="Edmonds-Karp-algorithm"   >
          <a href="#Edmonds-Karp-algorithm" class="heading-link"><i class="fas fa-link"></i></a><a href="#Edmonds-Karp-algorithm" class="headerlink" title="Edmonds-Karp algorithm"></a>Edmonds-Karp algorithm</h3>
      
        <h4 id="基本思想"   >
          <a href="#基本思想" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4>
      <ul>
<li><p><strong>Edmonds–Karp algorithm</strong> is an optimized implementation of the Ford–Fulkerson method for computing the maximum flow in a flow network in <strong>O(V E^2)</strong> time instead of <strong>O(E |max_flow|)</strong> in case of Ford-Fulkerson algorithm.</p>
</li>
<li><p>The algorithm is identical to the Ford–Fulkerson algorithm, except that the search order when finding the augmenting path is defined. The path found must be a shortest path that has available capacity.</p>
</li>
<li><p><img src="/assets/image-20221006221449948.png" alt="image-20221006221449948"></p>
</li>
<li><p>This can be found by a <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Breadth-first_search" >breadth-first search</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>, where we apply a weight of 1 to each edge. The running time of {\displaystyle O(|V||E|^{2})}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ae5bc5dfaecce53a04efd47719ac640aa983e706" alt="{\displaystyle O(|V||E|^{2})}"> is found by showing that each augmenting path can be found in {\displaystyle O(|E|)}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/976fe7f1e011d0dcdb3d6163754c877aaad5187f" alt="O(|E|)"> time, that every time at least one of the {\displaystyle E}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4232c9de2ee3eec0a9c0a19b15ab92daa6223f9b" alt="E"> edges becomes saturated (an edge which has the maximum possible flow), that the distance from the saturated edge to the source along the augmenting path must be longer than last time it was saturated, and that the length is at most {\displaystyle |V|}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9ddcffc28643ac01a14dd0fb32c3157859e365a7" alt="|V|">.</p>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/11/19/07/">[ 文章无标题 ]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-11-19</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-11-19</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="拓扑排序"   >
          <a href="#拓扑排序" class="heading-link"><i class="fas fa-link"></i></a><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1>
      
        <h2 id="basics"   >
          <a href="#basics" class="heading-link"><i class="fas fa-link"></i></a><a href="#basics" class="headerlink" title="basics"></a>basics</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">小明有 2 个小时的作业，回家一共有 4 个小时做作业的时间。他可以选择一开始就做，或者因为「ddl 综合征」最后 2 小时才开始做。此时「做作业最早的时间」和「做作业的最晚时间」是不等的。</span><br><span class="line">老师知道小明的情况后将小明的作业增加到了 4 个小时的量，小明做作业的时间还是 4 个小时。小明只能回家就开始做作业才能做完。此时「做作业最早的时间」和「做作业的最晚时间」是相等的。</span><br><span class="line">「做作业最早的时间」和「做作业的最晚时间」是相等的说明：如果做作业的时间延误，将会导致整个工期延误，做作业的时间缩短，整个工期的最短时间就会缩短。</span><br><span class="line">我们将「做作业」抽象为「活动」Activity，「作业完成」抽象为「事件」Event</span><br><span class="line">关键路径定义：活动的最早发生时间和最晚发生时间相等的路径就是关键路径</span><br></pre></td></tr></table></div></figure>

<ul>
<li>DAG（Directed Acyclic Graph简称DAG），就是有向无环图，DAG这种图中的所有边都是有向边，而且从任意一个顶点开始，都找不到回到起始点的环路。当且仅当一个有向图为有向无环图（directed acyclic graph，或称DAG）时，才能得到对应于该图的拓扑排序。每一个有向无环图都至少存在一种拓扑排序</li>
<li>一个可以进行拓扑排序的DAG图的基本特征，必然存在至少一个入度为0的节点，如此才可以排序。有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。</li>
<li>顶点表示事件 边表示活动 边的权值表示活动所需要的时间</li>
<li>边的方向表示活动可以在起点事件之后开始 在终点事件之前完成</li>
<li>AOE网</li>
<li>完成工程的最短时间是从源点到汇点的最长路径的长度 称为关键路径</li>
</ul>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://tiemchart.com/blogs/training/forward-pass-and-backward-pass/#:~:text=Forward%20pass%20is%20a%20technique%20to%20move%20forward,if%20there%20is%20any%20slack%20in%20the%20activity." >reference</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ul>
<li><p>forward pass：计算最早结束时间</p>
<p>In order to calculate Early Finish, we use forward pass. Means moving from Early Start towards right to come up with Early Finish of the project.</p>
</li>
<li><p>backward pass：计算最晚开始时间</p>
<p>Late Start (LS) is the latest date that the activity can finish without causing a delay to the project completion date.</p>
</li>
</ul>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/337438327" >reference</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ul>
<li><strong>最早发生时间：从前往后，前驱结点到当前结点所需时间，取最大值。</strong></li>
<li><strong>最迟发生时间：从后往前，后继结点的最迟发生时间-边权值，取最小值。</strong></li>
</ul>
<p>1  3 2 4 5 6</p>
<p>13246</p>
<p>13256</p>

        <h2 id="steps"   >
          <a href="#steps" class="heading-link"><i class="fas fa-link"></i></a><a href="#steps" class="headerlink" title="steps"></a>steps</h2>
      <ul>
<li>Identify vertices that have no incoming edges （The “in-degree” of these vertices is zero）<ul>
<li>If no such vertices, graph has only cycle(s) (cyclic graph) Topological sort not possible – Halt.</li>
</ul>
</li>
<li>Delete this vertex of in-degree 0 and all its outgoing edges from the graph. Place it in the output.</li>
<li>Repeat Step 1 and Step 2 until graph is empty</li>
</ul>

        <h3 id="判断是否为有向图"   >
          <a href="#判断是否为有向图" class="heading-link"><i class="fas fa-link"></i></a><a href="#判断是否为有向图" class="headerlink" title="判断是否为有向图"></a>判断是否为有向图</h3>
      <ul>
<li>在图论中，如果一个<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%89%E5%90%91%E5%9B%BE?fromModule=lemma_inlink" >有向图</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>无法从某个顶点出发经过若干条边回到该点，则这个图是一个<strong>有向无环图</strong>（DAG图）。</li>
<li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211192229111.png" alt="image-20221119150809245"></li>
</ul>
<p>这是有向无环图</p>

        <h3 id="code"   >
          <a href="#code" class="heading-link"><i class="fas fa-link"></i></a><a href="#code" class="headerlink" title="code"></a>code</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; adj;</span><br><span class="line">vector&lt;int&gt; indegree(n,0);</span><br><span class="line">int n,m;</span><br><span class="line">int cnt=0;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">	int u,v;</span><br><span class="line">	cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">	adj[u].push_back(v);</span><br><span class="line">	indeg[v]++</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;int&gt; pq;</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">	if(indeg[i]==0)&#123;</span><br><span class="line">		pq.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">while(!pq.empty())&#123;</span><br><span class="line">	cnt++;</span><br><span class="line">	int x = pq.front();</span><br><span class="line">	pq.pop();</span><br><span class="line">	cout&lt;&lt;x&lt;&lt;&quot; &quot;;</span><br><span class="line">	for(auto it:adj[x])&#123;</span><br><span class="line">		indeg[it]--;</span><br><span class="line">		if(indeg[it]==0)</span><br><span class="line">			pq.push(it);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/cpp-program-for-topological-sorting/" >stack实现</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ul>
<p>复杂度分析</p>
<ul>
<li><p>version 1</p>
<ul>
<li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211192229814.png" alt="image-20221119160556133"></li>
</ul>
</li>
<li><p>version 2 Initialize and maintain a queue (or stack) of vertices with In-Degree 0</p>
<ul>
<li>Store each vertex’s In-Degree in an array Initialize a queue with all in-degree zero vertices While there are vertices remaining in the queue:       ➭ Dequeue and output a vertex       ➭ Reduce In-Degree of all vertices adjacent to it by 1       ➭ Enqueue any of these vertices whose In-Degree became zero</li>
<li><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202211192229866.png" alt="image-20221119160658194"></li>
<li><img src="/assets/image-20221119160731648.png" alt="image-20221119160731648"></li>
</ul>
</li>
</ul>
<p>​		</p>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://github.com/pinkyrie/pic/blob/main/202204272046093.JPG?raw=true" alt="avatar"></div><p class="sidebar-ov-author__text">be happy</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/pinkyrie" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="954365771" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">43</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">6</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">4</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2023</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>rye</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>