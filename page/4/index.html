<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/ryenney/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/ryenney/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="过期的jk">
<meta property="og:type" content="website">
<meta property="og:title" content="rye is coding">
<meta property="og:url" content="http://gitee.com/ryenney/page/4/index.html">
<meta property="og:site_name" content="rye is coding">
<meta property="og:description" content="过期的jk">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="rye">
<meta name="twitter:card" content="summary"><title>rye is coding</title><link ref="canonical" href="http://gitee.com/ryenney/page/4/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" type="text/css"><link rel="stylesheet" href="/ryenney/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/ryenney/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.2"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fa fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">rye is coding</div><div class="header-banner-info__subtitle"></div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/ryenney/2022/05/09/DS-3.1/">heap</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-05-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-05-09</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="define"   >
          <a href="#define" class="heading-link"><i class="fas fa-link"></i></a><a href="#define" class="headerlink" title="define"></a>define</h2>
      <ul>
<li>堆这种数据结构本质是一个完全二叉树（完全二叉树（Complete Binary Tree）：在满足满二叉树的性质后，最后一层的叶子节点均需在最左边）</li>
</ul>

        <h2 id="mooc"   >
          <a href="#mooc" class="heading-link"><i class="fas fa-link"></i></a><a href="#mooc" class="headerlink" title="mooc"></a>mooc</h2>
      <ul>
<li><p>建堆时，最坏情况下需要挪动元素次数是等于树中各结点的高度和。问：对于元素个数为12的堆，其各结点的高度之和是多少？</p>
<ul>
<li><pre><code>建堆的话，主要考虑下沉的次数，以此定义高度。
这样的话，8,9,10,11,12都是已经沉底的，要注意的是7也是在最底了。这些节点高度都是0。
4,5,6都是最多可以沉1次的，高度为1.
2,3最多能沉2次，高度为2.
1可以沉3次，高度为3.
1*3+2*2+3*1=3+4+3=10
</code></pre>
</li>
</ul>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/u011240877/article/details/47706923" >判断一个序列是否是堆</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p><img src="/ryenney/heap.assets/image-20220509142051599.png" alt="image-20220509142051599"></p>
</li>
<li><p><img src="/ryenney/heap.assets/image-20220509142112582.png" alt="image-20220509142112582"></p>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.toolsou.com/en/article/220262987" >顺序存储和线性存储</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p>linear data <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/overview-of-data-structures-set-1-linear-data-structures/" >structure</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p>优先队列：</p>
<p>一种先进先出的数据结构，元素在队列尾追加，而从队列头删除 通常采用<strong>堆数据结构</strong></p>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/ryenney/2022/05/09/DS-3.2/">heap</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-05-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-05-25</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="define"   >
          <a href="#define" class="heading-link"><i class="fas fa-link"></i></a><a href="#define" class="headerlink" title="define"></a>define</h2>
      <ul>
<li>堆这种数据结构本质是一个完全二叉树（完全二叉树（Complete Binary Tree）：在满足满二叉树的性质后，最后一层的叶子节点均需在最左边）</li>
</ul>

        <h2 id="mooc"   >
          <a href="#mooc" class="heading-link"><i class="fas fa-link"></i></a><a href="#mooc" class="headerlink" title="mooc"></a>mooc</h2>
      <ul>
<li><p>建堆时，最坏情况下需要挪动元素次数是等于树中各结点的高度和。问：对于元素个数为12的堆，其各结点的高度之和是多少？</p>
<ul>
<li><pre><code>建堆的话，主要考虑下沉的次数，以此定义高度。
这样的话，8,9,10,11,12都是已经沉底的，要注意的是7也是在最底了。这些节点高度都是0。
4,5,6都是最多可以沉1次的，高度为1.
2,3最多能沉2次，高度为2.
1可以沉3次，高度为3.
1*3+2*2+3*1=3+4+3=10
</code></pre>
</li>
</ul>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/u011240877/article/details/47706923" >判断一个序列是否是堆</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p><img src="/ryenney/heap.assets/image-20220509142051599.png" alt="image-20220509142051599"></p>
</li>
<li><p><img src="/ryenney/heap.assets/image-20220509142112582.png" alt="image-20220509142112582"></p>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.toolsou.com/en/article/220262987" >顺序存储和线性存储</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p>linear data <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/overview-of-data-structures-set-1-linear-data-structures/" >structure</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p>优先队列：</p>
<p>一种先进先出的数据结构，元素在队列尾追加，而从队列头删除 通常采用<strong>堆数据结构</strong></p>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/ryenney/2022/05/09/huawei_cloud/">huaweicloud</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-05-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-05-25</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="DS-1"   >
          <a href="#DS-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#DS-1" class="headerlink" title="DS-1"></a>DS-1</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">Reverse</span><span class="params">(Node* first)</span></span>&#123;</span><br><span class="line">	Node *p1=<span class="literal">nullptr</span>;</span><br><span class="line">	Node *p2=<span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">while</span>(first)&#123;</span><br><span class="line">        p2=first-&gt;next;</span><br><span class="line">        first-&gt;next=p1;</span><br><span class="line">        p1=first;</span><br><span class="line">        first=p2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p1;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Node* Merge（Node* a, Node* b)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!a) <span class="keyword">return</span> b;</span><br><span class="line">	<span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">	Node *A,*B,*head;</span><br><span class="line">	<span class="keyword">if</span>(a-&gt;value&lt;b-&gt;value)</span><br><span class="line">		A=a,B=b;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		A=b,B=a;</span><br><span class="line">	head=A;</span><br><span class="line">	<span class="keyword">while</span>(A-&gt;next &amp;&amp; B)&#123;</span><br><span class="line">		<span class="keyword">if</span>(B-&gt;value&lt;=A-&gt;value)&#123;</span><br><span class="line">			Node* Anext=A-&gt;next;</span><br><span class="line">			Node* Bnext=B-&gt;next;</span><br><span class="line">			A-&gt;next=B;</span><br><span class="line">			B-&gt;bext=Anext;</span><br><span class="line">			A=A-&gt;next;</span><br><span class="line">			B=Bnext;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			A=A-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(A-&gt;next==<span class="literal">NULL</span> &amp;&amp; B)</span><br><span class="line">		A-&gt;next=B;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(<span class="type">const</span> T item)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">IsFull</span>())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        queue[rear] = item;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(T&amp; item)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">IsEmpty</span>())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        item = queue[front];</span><br><span class="line">        front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetFront</span><span class="params">(T&amp; item)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">IsEmpty</span>())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        item = queue[front];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (front == rear) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;队列为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsFull</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((rear + <span class="number">1</span>) % maxSize == front) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;队列已满，溢出&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>




        <h2 id="DS-2"   >
          <a href="#DS-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#DS-2" class="headerlink" title="DS-2"></a>DS-2</h2>
      <ul>
<li>&#96;&#96;&#96;c++<br>bool Push(const T item);<br>bool Pop(T&amp; item);<br>bool Top(T&amp; item);<br>bool Push(const T item){<br>if(IsFull()){<br>    return false;<br>}<br>else{<br>    st[++top]&#x3D;item;<br>    return true;<br>}<br>}<br>bool Pop(T&amp; item){<br>if(IsEmpty()){<br>    return false;<br>}<br>else{<br>    item&#x3D;st[top–];<br>    return true;<br>}<br>}<br>bool Top(T&amp;item){<br>if(IsEmpty()){<br>    return false;<br>}<br>else{<br>    item&#x3D;st[top];<br>    return true;<br>}<br>}<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- ```c++</span><br><span class="line">  string Bracketmatch(const char* c) //括号匹配</span><br><span class="line">  &#123;</span><br><span class="line">      string res = &quot;111&quot;;</span><br><span class="line">      int size = sizeof(c);</span><br><span class="line">      stack st[3] = &#123; size,size,size &#125;;//每一种括号分配一个栈</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">      for (int i = 0; c[i] != &#x27;\0&#x27;; i++) &#123;</span><br><span class="line">          if (c[i] == &#x27;(&#x27;) &#123;</span><br><span class="line">              st[0].push(c[i]);</span><br><span class="line">          &#125;//左括号入栈</span><br><span class="line">          else if (c[i] == &#x27;)&#x27;) &#123;</span><br><span class="line">              //右括号需要判断栈</span><br><span class="line">              if (!st[0].empty()) &#123;</span><br><span class="line">                  st[0].pop();//栈不为空则pop</span><br><span class="line">              &#125;</span><br><span class="line">              else//栈为空则不匹配</span><br><span class="line">                  res[0] = 0;</span><br><span class="line">          &#125;</span><br><span class="line">          else if (c[i] == &#x27;[&#x27;) &#123;</span><br><span class="line">              st[1].push(c[i]);</span><br><span class="line">          &#125;</span><br><span class="line">          else if (c[i] == &#x27;]&#x27;) &#123;</span><br><span class="line">              if (!st[1].empty()) &#123;</span><br><span class="line">                  st[1].pop();</span><br><span class="line">              &#125;</span><br><span class="line">              else</span><br><span class="line">                  res[1] = 0;</span><br><span class="line">          &#125;</span><br><span class="line">          else if (c[i] == &#x27;&#123;&#x27;) &#123;</span><br><span class="line">              st[2].push(c[i]);</span><br><span class="line">          &#125;</span><br><span class="line">          else if (c[i] == &#x27;&#125;&#x27;) &#123;</span><br><span class="line">              if (!st[2].empty()) &#123;</span><br><span class="line">                  st[2].pop();</span><br><span class="line">              &#125;</span><br><span class="line">              else</span><br><span class="line">                  res[2] = 0;</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">      &#125;</span><br><span class="line">      for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">          if (!st[i].empty())</span><br><span class="line">              res[i] = 0;//string的下标操作</span><br><span class="line">      &#125;//不要忘了最后需要对所有栈检查有没有剩余 有剩余则不匹配</span><br><span class="line">      return res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h2 id="DS-3"   >
          <a href="#DS-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#DS-3" class="headerlink" title="DS-3"></a>DS-3</h2>
      <ul>
<li>&#96;&#96;&#96;c++<br>   bool EnQueue(const T item)<br>{<br>    if ((rear+1)%maxSize &#x3D;&#x3D; front) {<br>        cout &lt;&lt; “队列已满，溢出” &lt;&lt; endl;<br>        return false;<br>    }<br>    else {<br>        queue[rear] &#x3D; item;<br>        rear&#x3D;(rear+1)%maxSize;<br>        return true;<br>    }<br>}<br>bool DeQueue(T&amp; item)<br>{<br>    if (front &#x3D;&#x3D; rear) {<br>        cout &lt;&lt; “队列为空” &lt;&lt; endl;<br>        return false;<br>    }<br>    item &#x3D; queue[front];<br>    front &#x3D; (front + 1) % maxSize;<br>    return true;<br>}<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```c++</span><br><span class="line">  void LinkQueue&lt;ElemType&gt;::Clear()</span><br><span class="line">  // 操作结果：清空队列</span><br><span class="line">  &#123;</span><br><span class="line">      if (!Empty()) &#123;</span><br><span class="line">          while (front != nullptr) &#123;</span><br><span class="line">              rear = front;</span><br><span class="line">              front = front-&gt;next;</span><br><span class="line">              delete rear;</span><br><span class="line">          &#125;</span><br><span class="line">          rear = nullptr;</span><br><span class="line">          count = 0;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  bool LinkQueue&lt;ElemType&gt;::OutQueue(ElemType&amp; e)</span><br><span class="line">  // 操作结果：如果队列非空，那么删除队头元素，并用e返回其值，返回true,</span><br><span class="line">  //	否则返回false，</span><br><span class="line">  &#123;</span><br><span class="line">      Node&lt;ElemType&gt;* temp;</span><br><span class="line">  </span><br><span class="line">      if (!Empty()) &#123;</span><br><span class="line">          e = front-&gt;data;</span><br><span class="line">          temp = front;</span><br><span class="line">          front = front-&gt;next;</span><br><span class="line">          delete temp;</span><br><span class="line">          count--;</span><br><span class="line">          return true;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">          return false;</span><br><span class="line">  &#125;</span><br><span class="line">  bool LinkQueue&lt;ElemType&gt;::InQueue(const ElemType&amp; e)</span><br><span class="line">  // 操作结果：插入元素e为新的队尾，返回true</span><br><span class="line">  &#123;//判断rear为null</span><br><span class="line">      if (rear == nullptr) &#123;</span><br><span class="line">          front = rear = new Node&lt;ElemType&gt;(e, nullptr);</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">      rear-&gt;next = new Node&lt;ElemType&gt;(e, nullptr);</span><br><span class="line">      rear = rear-&gt;next;</span><br><span class="line">      </span><br><span class="line">      &#125;</span><br><span class="line">      count++;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h2 id="DS-4"   >
          <a href="#DS-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#DS-4" class="headerlink" title="DS-4"></a>DS-4</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">next</span><span class="params">(string P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> m = P.<span class="built_in">size</span>();</span><br><span class="line">	<span class="built_in">assert</span>(m &gt; <span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span>* N = <span class="keyword">new</span> <span class="type">int</span>[m];</span><br><span class="line">	N[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (i != <span class="number">0</span> &amp;&amp; P[i] != P[j]) &#123;<span class="comment">//&amp;&amp; not ||</span></span><br><span class="line">			i = N[i - <span class="number">1</span>];<span class="comment">//如果之前有成功匹配就需要进入while循环 回退状态到0或者匹配 j永远不回退</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (P[i] == P[j]) &#123;</span><br><span class="line">			N[j] = i + <span class="number">1</span>;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			N[j] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">KMPStrMatching</span><span class="params">(string T, string P, <span class="type">int</span>* N, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> lastIndex = T.<span class="built_in">size</span>() - P.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (lastIndex - startIndex &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;<span class="comment">//i T j P</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; T.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (T[i] != P[j] &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			j = N[j - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (P[j] == T[i]) &#123;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">if</span> (j == P.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>





        <h2 id="DS-9"   >
          <a href="#DS-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#DS-9" class="headerlink" title="DS-9"></a>DS-9</h2>
      <ul>
<li><pre><code class="c++">void MaxHeap&lt;T&gt;::BuildHeap()&#123;
    for(int i=CurrentSize/2-1;i&gt;=0;i--)&#123;
        SiftDown(i);
    &#125;
&#125;
void MaxHeap&lt;T&gt;::SiftDown(int left)&#123;
    int i=left;
    int j=2*i+1;
    T temp=HeapArray[i];
    while(j&lt;CurrentSize)&#123;
        j++;
        if(temp&lt;heapArray[i])&#123;
            heapArray[i]=heapArray[j];
            i=j;
            j=2*j+1;
        &#125;
        else break;
    &#125;
    heapArray[i]=temp;    
&#125;
void MaxHeap&lt;T&gt;::SiftUp(int pos)&#123;
    int p=parent(pos);
    while(p&gt;-1&amp;&amp;heapArray[p]&lt;heapArray[pos])&#123;
        temp=heapArray[p];
        heapArray[p]=heapArray[pos];
        heapArray[pos]=temp;
        p=parent(p);
    &#125;
&#125;
</code></pre>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/ryenney/2022/05/09/heap/">heap</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-05-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-05-25</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="define"   >
          <a href="#define" class="heading-link"><i class="fas fa-link"></i></a><a href="#define" class="headerlink" title="define"></a>define</h2>
      <ul>
<li>堆这种数据结构本质是一个完全二叉树（完全二叉树（Complete Binary Tree）：在满足满二叉树的性质后，最后一层的叶子节点均需在最左边）</li>
</ul>

        <h2 id="mooc"   >
          <a href="#mooc" class="heading-link"><i class="fas fa-link"></i></a><a href="#mooc" class="headerlink" title="mooc"></a>mooc</h2>
      <ul>
<li><p>建堆时，最坏情况下需要挪动元素次数是等于树中各结点的高度和。问：对于元素个数为12的堆，其各结点的高度之和是多少？</p>
<ul>
<li><pre><code>建堆的话，主要考虑下沉的次数，以此定义高度。
这样的话，8,9,10,11,12都是已经沉底的，要注意的是7也是在最底了。这些节点高度都是0。
4,5,6都是最多可以沉1次的，高度为1.
2,3最多能沉2次，高度为2.
1可以沉3次，高度为3.
1*3+2*2+3*1=3+4+3=10
</code></pre>
</li>
</ul>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/u011240877/article/details/47706923" >判断一个序列是否是堆</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p><img src="/ryenney/heap.assets/image-20220509142051599.png" alt="image-20220509142051599"></p>
</li>
<li><p><img src="/ryenney/heap.assets/image-20220509142112582.png" alt="image-20220509142112582"></p>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.toolsou.com/en/article/220262987" >顺序存储和线性存储</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p>linear data <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/overview-of-data-structures-set-1-linear-data-structures/" >structure</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p>优先队列：</p>
<p>一种先进先出的数据结构，元素在队列尾追加，而从队列头删除 通常采用<strong>堆数据结构</strong></p>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/ryenney/2022/05/06/0414-physicalmath-1/">0414_physicalmath</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-05-06</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-05-31</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="series-级数"   >
          <a href="#series-级数" class="heading-link"><i class="fas fa-link"></i></a><a href="#series-级数" class="headerlink" title="series 级数"></a>series 级数</h2>
      
        <h3 id="定义"   >
          <a href="#定义" class="heading-link"><i class="fas fa-link"></i></a><a href="#定义" class="headerlink" title="定义"></a>定义</h3>
      <ul>
<li><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205311547404.png" alt="image-20220531154742849"></li>
<li>绝对收敛：模收敛 原级数收敛</li>
<li>条件收敛：模不收敛 原级数收敛</li>
</ul>

        <h3 id="性质"   >
          <a href="#性质" class="heading-link"><i class="fas fa-link"></i></a><a href="#性质" class="headerlink" title="性质"></a>性质</h3>
      
        <h4 id="幂级数"   >
          <a href="#幂级数" class="heading-link"><i class="fas fa-link"></i></a><a href="#幂级数" class="headerlink" title="幂级数"></a>幂级数</h4>
      <ul>
<li><p>Abel定理：至少z&#x3D;0的时候一定是收敛的 所以收敛的集合是非空的 z0收敛 则小于z0的都收敛 z发散 则大于z0的都发散</p>
</li>
<li><p>幂级数收敛范围是原点为中心 R为半径的收敛域（圆周上的收敛性是无法判断的）</p>
</li>
<li><p>根值判别法 和 比值判别法</p>
</li>
<li><p>逐项可导 逐项积分 前提：收敛半径R&gt;0 则可以交换求和与积分&#x2F;求导的顺序</p>
<ul>
<li>证明：证明逐项后的新的幂级数在收敛域内是收敛的 且 与f(z)求得导数是相等得</li>
</ul>
</li>
<li><p>对幂级数进行逐项求导 求高阶导数 k阶导数 z&#x3D;0时可以求出cn 系数</p>
</li>
<li><p>从零点推广到z0</p>
</li>
</ul>

        <h2 id="幂级数-1"   >
          <a href="#幂级数-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#幂级数-1" class="headerlink" title="幂级数"></a>幂级数</h2>
      
        <h2 id="talor级数"   >
          <a href="#talor级数" class="heading-link"><i class="fas fa-link"></i></a><a href="#talor级数" class="headerlink" title="talor级数"></a>talor级数</h2>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/ryenney/2022/05/06/0412-physicalmath/">0412_physicalmath</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-05-06</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-05-31</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="Morera定理"   >
          <a href="#Morera定理" class="heading-link"><i class="fas fa-link"></i></a><a href="#Morera定理" class="headerlink" title="Morera定理"></a>Morera定理</h2>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205190916748.png" alt="image-20220519091607121"></p>
<ul>
<li>cauchy积分定理 如果闭曲线内可导积分&#x3D;0</li>
<li>Morera：如果积分等于0推导出解析</li>
</ul>

        <h2 id="Cauchy不等式"   >
          <a href="#Cauchy不等式" class="heading-link"><i class="fas fa-link"></i></a><a href="#Cauchy不等式" class="headerlink" title="Cauchy不等式"></a>Cauchy不等式</h2>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205190918890.png" alt="image-20220519091805569"></p>
<ul>
<li>对积分的估算 -&gt;对函数的估算</li>
<li>f是一个解析函数 如果f有界小于等于M则f的高阶导数也是有界的</li>
</ul>

        <h2 id="刘维尔定理"   >
          <a href="#刘维尔定理" class="heading-link"><i class="fas fa-link"></i></a><a href="#刘维尔定理" class="headerlink" title="刘维尔定理"></a>刘维尔定理</h2>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205190925668.png" alt="image-20220519092505540"></p>
<ul>
<li><p>整函数：在整个复平面上解析 若f是整函数而且有界 必然是一个常数</p>
</li>
<li><p>如果一个n次多项式 有n个根（一定只有n个 考虑重根 两根一样记为两次）</p>
</li>
</ul>

        <h2 id="解析函数和调和函数关系"   >
          <a href="#解析函数和调和函数关系" class="heading-link"><i class="fas fa-link"></i></a><a href="#解析函数和调和函数关系" class="headerlink" title="解析函数和调和函数关系"></a>解析函数和调和函数关系</h2>
      
        <h3 id="harmonic-function"   >
          <a href="#harmonic-function" class="heading-link"><i class="fas fa-link"></i></a><a href="#harmonic-function" class="headerlink" title="harmonic function"></a>harmonic function</h3>
      <ul>
<li><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205302158977.png" alt="image-20220530215811195"></li>
</ul>

        <h3 id="harmonic-conjugate-共轭调和"   >
          <a href="#harmonic-conjugate-共轭调和" class="heading-link"><i class="fas fa-link"></i></a><a href="#harmonic-conjugate-共轭调和" class="headerlink" title="harmonic conjugate 共轭调和"></a>harmonic conjugate 共轭调和</h3>
      <ul>
<li><p>满足u和v都是harmonic</p>
</li>
<li><p>而且满足柯西黎曼方程</p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205302201202.png" alt="image-20220530220127049"></p>
</li>
<li><p>称v是u的共轭调和函数 u和v的负号注意（）不能说u是v的共轭调和</p>
</li>
<li><p>注意u和v都是解析 而且满足柯西黎曼则 &#x3D;&#x3D; f(z)&#x3D;u+iv是解析函数</p>
</li>
<li><p>如果v是u的共轭调和 则可以得到f(z)是解析函数</p>
</li>
</ul>

        <h2 id="eg"   >
          <a href="#eg" class="heading-link"><i class="fas fa-link"></i></a><a href="#eg" class="headerlink" title="eg"></a>eg</h2>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/ryenney/2022/05/06/0407-physicalmath/">0407_physicalmath</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-05-06</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-05-19</span></span></div></header><div class="post-body"><div class="post-excerpt"><ul>
<li>闭曲线c可以经过a点</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205121634542.png" alt="image-20220512163451686"></p>
<ul>
<li>纠正上次的公式录入错误：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205121642709.png" alt="image-20220512164214827"></p>

        <h2 id="解析函数导数"   >
          <a href="#解析函数导数" class="heading-link"><i class="fas fa-link"></i></a><a href="#解析函数导数" class="headerlink" title="解析函数导数"></a>解析函数导数</h2>
      <ul>
<li>解析函数有任意阶导数</li>
</ul>

        <h3 id="证明"   >
          <a href="#证明" class="heading-link"><i class="fas fa-link"></i></a><a href="#证明" class="headerlink" title="证明"></a>证明</h3>
      <ul>
<li>证明：需要找到上界</li>
</ul>

        <h3 id="记忆一阶导数公式"   >
          <a href="#记忆一阶导数公式" class="heading-link"><i class="fas fa-link"></i></a><a href="#记忆一阶导数公式" class="headerlink" title="记忆一阶导数公式"></a>记忆一阶导数公式</h3>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205121719091.png" alt="image-20220512171933981"></p>
<ul>
<li>对f(a)左右侧同时求导</li>
</ul>

        <h3 id="高阶导数"   >
          <a href="#高阶导数" class="heading-link"><i class="fas fa-link"></i></a><a href="#高阶导数" class="headerlink" title="高阶导数"></a>高阶导数</h3>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205121742913.png" alt="image-20220512174256936"></p>
<ul>
<li><p>区别只是把分母的次幂换成了n+1</p>
</li>
<li><p>是反过来 通过求高阶导数来求闭曲线的积分</p>
</li>
</ul>

        <h3 id="例题"   >
          <a href="#例题" class="heading-link"><i class="fas fa-link"></i></a><a href="#例题" class="headerlink" title="例题"></a>例题</h3>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/ryenney/2022/05/06/0331-physicalmath/">0331_physicalmath</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-05-06</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-05-12</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="原函数"   >
          <a href="#原函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#原函数" class="headerlink" title="原函数"></a>原函数</h2>
      <ul>
<li><p>不告诉积分路径时考虑与积分路径无关</p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205101530231.png" alt="image-20220510153019906"></p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205101546900.png" alt="image-20220510154626412"></p>
</li>
<li><p>一个函数时可解析的则拥有原函数 且该函数的积分之间相差常数</p>
</li>
<li><p>一个解析函数求导后仍然解析</p>
</li>
</ul>

        <h3 id="积分基本定理"   >
          <a href="#积分基本定理" class="heading-link"><i class="fas fa-link"></i></a><a href="#积分基本定理" class="headerlink" title="积分基本定理"></a>积分基本定理</h3>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205101550277.png" alt="image-20220510155017327"></p>
<ul>
<li>求积分若判定与路径无关 只需要找到原函数然后代入起点终点就ok</li>
</ul>

        <h2 id="柯西基本公式"   >
          <a href="#柯西基本公式" class="heading-link"><i class="fas fa-link"></i></a><a href="#柯西基本公式" class="headerlink" title="柯西基本公式"></a>柯西基本公式</h2>
      <ul>
<li>若f(z)在D内解析—&gt;积分f(z)&#x3D;0</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205101601849.png" alt="image-20220510160111855"></p>
<ul>
<li>函数在c内部a一点的值可以由边界表示</li>
</ul>

        <h3 id="证明"   >
          <a href="#证明" class="heading-link"><i class="fas fa-link"></i></a><a href="#证明" class="headerlink" title="证明"></a>证明</h3>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205101609557.png" alt="image-20220510160901386"></p>

        <h3 id="均值定理"   >
          <a href="#均值定理" class="heading-link"><i class="fas fa-link"></i></a><a href="#均值定理" class="headerlink" title="均值定理"></a>均值定理</h3>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205101616560.png" alt="image-20220510161621479"></p>
<ul>
<li>将柯西定理的z进行换元即可证</li>
<li>表达圆上的值求平均可以得到f(a)</li>
</ul>

        <h3 id="拓展到多联通区域"   >
          <a href="#拓展到多联通区域" class="heading-link"><i class="fas fa-link"></i></a><a href="#拓展到多联通区域" class="headerlink" title="拓展到多联通区域"></a>拓展到多联通区域</h3>
      <ul>
<li>从外侧的曲线进入内部曲线 需要保证解析的点都落在左手侧</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205101632869.png" alt="image-20220510163236955"></p>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205101634330.png" alt="image-20220510163424462"></p>

        <h3 id="example"   >
          <a href="#example" class="heading-link"><i class="fas fa-link"></i></a><a href="#example" class="headerlink" title="example"></a>example</h3>
      <ul>
<li>若单连通区域时 点a在区域外部 则区域内全部解析 所以积分&#x3D;0</li>
<li></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205121629351.png" alt="image-20220512162928309"></p>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205121629415.png" alt="image-20220512162947612"></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/ryenney/2022/05/06/qt-draft/">感兴趣的词典</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-05-06</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-06-28</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="file-读写操作"   >
          <a href="#file-读写操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#file-读写操作" class="headerlink" title="file 读写操作"></a>file 读写操作</h2>
      <ul>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://stackoverflow.com/questions/9460539/how-to-save-application-data" >https://stackoverflow.com/questions/9460539/how-to-save-application-data</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> </p>
</li>
<li><p>XML Qsettings Qdatabase</p>
</li>
</ul>

        <h3 id="bug"   >
          <a href="#bug" class="heading-link"><i class="fas fa-link"></i></a><a href="#bug" class="headerlink" title="bug"></a>bug</h3>
      <ul>
<li><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/signalsandslots-syntaxes.html" >ref</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li>两种信号连接方式：</li>
</ul>
<p>The <strong><em>string-based</em> connection syntax</strong> and the <strong><em>functor-based</em> connection syntax.</strong> </p>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202206281533570.png" alt="image-20220628153357863"></p>
<p>signal and slot arguments are not compatible</p>
<ul>
<li><p>function pointer-based syntax compiler can help us detect type mismatches </p>
</li>
<li><p>string-based SIGNAL and SLOT syntax will detect type mismatches at runtime. </p>
</li>
<li><p>Signals are automatically generated by the <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/moc.html" >moc</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> and must not be implemented in the <code>.cpp</code> file. They can never have return types (i.e. use <code>void</code>).</p>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/signalsandslots.html" >ref</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p>basic about singal and slots</p>
</li>
<li><p>The signature of a signal must match the signature of the receiving  slot. (In fact a <strong>slot may have a shorter</strong> signature than the signal it  receives because it can ignore extra arguments.)</p>
</li>
</ul>

        <h3 id="lambda-function"   >
          <a href="#lambda-function" class="heading-link"><i class="fas fa-link"></i></a><a href="#lambda-function" class="headerlink" title="lambda function"></a>lambda function</h3>
      <ul>
<li><p>General syntax:</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Capture List] (Parameter List)</span><br><span class="line">&#123;</span><br><span class="line">    Function Body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>The <code>Capture List</code> tells the compiler that a lambda function is created.</p>
<p>To use any variable inside the function body, first, we need to capture it inside the capture list. Without doing so, it will be out of the scope  of the function body.</p>
<p>The variable captured can be accessed either as a copy or as a reference. Capturing the variable is not considered  the passing of an argument in a normal function.</p>
<p>Here, <code>a</code> is captured by value:</p>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/ryenney/2022/05/06/test/">随手抄抄</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-05-06</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-05-06</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="the-economist"   >
          <a href="#the-economist" class="heading-link"><i class="fas fa-link"></i></a><a href="#the-economist" class="headerlink" title="the economist"></a>the economist</h2>
      <ul>
<li><p>It will grow by a robust 7% or more for the next several years, helped by free-spending consumers.</p>
</li>
<li><p>She was almost 90, but still very robust.</p>
</li>
<li><p>Teeming and vital, the city reminded me of the rain forest, the only other habitat that could support such extreme and robust variation among life-forms.</p>
</li>
<li><p>The rain was teeming down.</p>
</li>
<li><p>The island was teeming with tourists.</p>
</li>
<li><p>the teeming streets of the city</p>
</li>
</ul>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/ryenney/page/3/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/ryenney/">1</a><span class="space">&hellip;</span><a class="page-number" href="/ryenney/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/ryenney/page/5/">5</a><a class="page-number" href="/ryenney/page/6/">6</a><a class="extend next" rel="next" href="/ryenney/page/5/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://github.com/pinkyrie/pic/blob/main/202204272046093.JPG?raw=true" alt="avatar"></div><p class="sidebar-ov-author__text">be happy</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/pinkyrie" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="954365771" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">58</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">9</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">5</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/ryenney/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>rye</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.4.2</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><script src="/ryenney/js/utils.js?v=2.6.2"></script><script src="/ryenney/js/stun-boot.js?v=2.6.2"></script><script src="/ryenney/js/scroll.js?v=2.6.2"></script><script src="/ryenney/js/header.js?v=2.6.2"></script><script src="/ryenney/js/sidebar.js?v=2.6.2"></script></body></html>