<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/ryenney/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/ryenney/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="过期的jk">
<meta property="og:type" content="website">
<meta property="og:title" content="rye is coding">
<meta property="og:url" content="http://gitee.com/ryenney/page/4/index.html">
<meta property="og:site_name" content="rye is coding">
<meta property="og:description" content="过期的jk">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="rye">
<meta name="twitter:card" content="summary"><title>rye is coding</title><link ref="canonical" href="http://gitee.com/ryenney/page/4/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" type="text/css"><link rel="stylesheet" href="/ryenney/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/ryenney/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.2.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fa fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">rye is coding</div><div class="header-banner-info__subtitle"></div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/ryenney/2022/05/09/effectiveC++/">effective-c++ chap1</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-05-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-06-26</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="C11-C14-C98-C03"   >
          <a href="#C11-C14-C98-C03" class="heading-link"><i class="fas fa-link"></i></a><a href="#C11-C14-C98-C03" class="headerlink" title="C11 C14 C98 C03"></a>C11 C14 C98 C03</h2>
      
        <h2 id="rvalue-reference-不代表就是rvalue"   >
          <a href="#rvalue-reference-不代表就是rvalue" class="heading-link"><i class="fas fa-link"></i></a><a href="#rvalue-reference-不代表就是rvalue" class="headerlink" title="rvalue reference 不代表就是rvalue"></a>rvalue reference 不代表就是rvalue</h2>
      <ul>
<li><p>to determine whether an expression is an lvalue is to ask if you can take its address.</p>
</li>
<li><p><img src="C:\Users\rye\AppData\Roaming\Typora\typora-user-images\image-20220328090241796.png" alt="image-20220328090241796">  </p>
</li>
<li><p>be perfectly valid  to take  rhs’s  address  inside  Widget’s  move  constructor, so rhs is an lvalue, even though its type is an rvalue reference. (By similar reasoning, <strong>all parameters are lvalues</strong>.)</p>
</li>
<li><p>Regrettably,  there’s  no  terminology  in  C++  that  distinguishes  between an object that’s a copy-constructed copy and one that’s a move-constructed copy:</p>
</li>
<li><p>Copies of rvalues are generally move constructed, while copies of lvalues are usually<br>copy constructed.</p>
</li>
</ul>

        <h2 id="区分argument和parameter"   >
          <a href="#区分argument和parameter" class="heading-link"><i class="fas fa-link"></i></a><a href="#区分argument和parameter" class="headerlink" title="区分argument和parameter"></a>区分argument和parameter</h2>
      <ul>
<li>the expressions passed at the call site are the function’s <strong>arguments</strong>.<br>The  arguments  are  used  to  initialize  the  function’s  parameters.</li>
<li>copy的代价高的定义在于：only that an <strong>object</strong> is a copy of another object, it’s not possible to say how expensive it was to construct the copy.</li>
<li>The  distinction  between  arguments  and  parameters  is  important,  because  <strong>parameters  are  lvalues</strong>,  but  the  arguments  with  which  <strong>they  are  initialized</strong>  may  be  <strong>rvalues  or  lvalues.</strong>  </li>
<li>例子：This  is  especially relevant  during  the  process  of  <em>perfect  forwarding</em>,  whereby  an  argument  passed  to  a function  is  passed  to  a  second  function  such  that  the  original  argument’s  rvalueness or lvalueness is preserved.</li>
</ul>

        <h2 id="好的函数是什么"   >
          <a href="#好的函数是什么" class="heading-link"><i class="fas fa-link"></i></a><a href="#好的函数是什么" class="headerlink" title="好的函数是什么"></a>好的函数是什么</h2>
      <ul>
<li>需要保证在call这个函数之后 即使有exception throw了 也没有data structure的corrupt或者data的leak</li>
<li>Functions  offering  the  strong exception  safety  guarantee  (i.e.,  the  strong  guarantee)  assure  callers  that  if  an  exception arises, the state of the program remains as it was prior to the call.</li>
</ul>

        <h2 id="function-object"   >
          <a href="#function-object" class="heading-link"><i class="fas fa-link"></i></a><a href="#function-object" class="headerlink" title="function object"></a>function object</h2>
      <ul>
<li><p>function  object,  I  usually  mean  an  object  of  a  type  supporting  an operator()  member  function. </p>
</li>
<li><p>an object that acts like a function</p>
</li>
<li><p>This broader definition covers not just objects supporting <code>operator()</code>,  but  also  functions  and  C-like  function  pointers.</p>
</li>
<li><p>Function  objects  created  through  <strong>lambda  expressions</strong>  are  known  as  <strong>closures</strong>.</p>
</li>
<li><p>a function’s <strong>signature</strong> to be the part of its declaration that specifies parameter and return types.  (official  definition  sometimes  omits  return types.)</p>
</li>
</ul>

        <h2 id="feature"   >
          <a href="#feature" class="heading-link"><i class="fas fa-link"></i></a><a href="#feature" class="headerlink" title="feature"></a>feature</h2>
      <ul>
<li><p>用官方推荐的feature</p>
<p><code>std::auto_ptr</code>  is deprecated in C++11, because <code>std::unique_ptr</code> does the same job, only better.</p>
</li>
</ul>

        <h2 id="常见ub-undefined-behavior"   >
          <a href="#常见ub-undefined-behavior" class="heading-link"><i class="fas fa-link"></i></a><a href="#常见ub-undefined-behavior" class="headerlink" title="常见ub undefined behavior"></a>常见ub undefined behavior</h2>
      <ul>
<li>That means  that  runtime  behavior  is  unpredictable,  and  it  should  go  without  saying  that<br>you  want  to  steer  clear  of  such  uncertainty.  Examples  of  actions  with  undefined behavior  include  using  square  brackets  (“[]”)  to index  beyond  the  bounds  of  astd::vector, dereferencing an uninitialized iterator, or engaging in a data race (i.e.,having  two  or  more  threads,  at  least  one  of  which  is  a  writer,  simultaneously  access the same memory location).</li>
</ul>

        <h1 id="chap-1"   >
          <a href="#chap-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#chap-1" class="headerlink" title="chap 1"></a>chap 1</h1>
      
        <h2 id="deduce-type"   >
          <a href="#deduce-type" class="heading-link"><i class="fas fa-link"></i></a><a href="#deduce-type" class="headerlink" title="deduce type"></a>deduce type</h2>
      <ul>
<li><p>type  deduction  takes  place:  in  calls  to  function  templates,  in  most  situations  where<br>auto  appears,  in  decltype  expressions,  and,  as  of  C++14,  where  the  decltype(auto) construct is employed.</p>
</li>
<li><pre><code class="c++">template&lt;typename T&gt;
void f(ParamType param);
//A call can look like this:
f(expr);                    // call f with some expression
//During  compilation,  compilers  use  expr  to  deduce  two  types:  one  for  T  and  one  for
//ParamType.  These  types  are  frequently  different,  because  ParamType  often  contains
//adornments,  e.g.,  const  or  reference  qualifiers.

<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 3 cases of deduction</span><br><span class="line"></span><br><span class="line">- **ParamType** is a pointer or reference type, but not a universal reference. (Universal references are described in Item 24. At this point, all you need to know is that they exist and that they’re **not the same as lvalue references or rvalue references.**)</span><br><span class="line"></span><br><span class="line">- **ParamType** is a universal reference.</span><br><span class="line"></span><br><span class="line">- **ParamType** is neither a pointer nor a reference.</span><br><span class="line"></span><br><span class="line">- case 1</span><br><span class="line"></span><br><span class="line">  ``` c++</span><br><span class="line">  template&lt;typename T&gt;</span><br><span class="line">  void f(T&amp; param);       // param is a reference</span><br><span class="line">  //and we have these variable declarations,</span><br><span class="line">  int x = 27;             // x is an int</span><br><span class="line">  const int cx = x;       // cx is a const int</span><br><span class="line">  const int&amp; rx = x;      // rx is a reference to x as a const int</span><br><span class="line">  //the deduced types for param and T in various calls are as follows:</span><br><span class="line">  f(x);                   // T is int, param&#x27;s type is int&amp;</span><br><span class="line">  f(cx);                  // T is const int,</span><br><span class="line">                          // param&#x27;s type is const int&amp;</span><br><span class="line">  f(rx);                  // T is const int,</span><br><span class="line">                          // param&#x27;s type is const int&amp;</span><br><span class="line">  </span><br></pre></td></tr></table></div></figure>
</code></pre>
</li>
<li><p>only  rvalue  arguments may be passed to rvalue reference parameters, but that restriction has nothing<br>to do with type deduction.</p>
</li>
<li><p>case 2</p>
<ul>
<li>parameters  are  declared  like  rvalue  references  (i.e.,  in  a  function  template  taking  a type parameter T, a universal reference’s declared type is T&amp;&amp;), but they behave differently when lvalue arguments are passed in.</li>
<li>函数定义是右值引用 然而传入了左值时（如果传入右值对应右值引用 符合case1）</li>
</ul>
</li>
</ul>

        <h1 id="item-3"   >
          <a href="#item-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#item-3" class="headerlink" title="item 3"></a>item 3</h1>
      <ul>
<li><code>decltype</code> tells the name or the expression 的 type</li>
</ul>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;    <span class="comment">// works, but</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">authAndAccess</span><span class="params">(Container&amp; c, Index i)</span>       <span class="comment">// requires</span></span></span><br><span class="line"><span class="function">  -&gt; <span class="title">decltype</span><span class="params">(c[i])</span>                             <span class="comment">// refinement</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">authenticateUser</span>();</span><br><span class="line">  <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>





<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/wanghongyang/p/14876038.html" >https://www.cnblogs.com/wanghongyang/p/14876038.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>the first <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cplusplus.com/sub_match" >sub_match</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> element corresponds to the entire match, and, if the <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cplusplus.com/regex" >regex</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> expression contained sub-expressions to be matched (i.e.,  parentheses-delimited groups), their corresponding sub-matches are  stored as successive <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.cplusplus.com/sub_match" >sub_match</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> elements in the <code>match_results</code> object.</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/ryenney/2022/05/09/%E6%9B%B2%E9%9D%A28-Weingarten%20map/">Weingarten map</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-05-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-05-22</span></span></div></header><div class="post-body"><div class="post-excerpt"><span id="more"></span>


        <h2 id="Gauss-map"   >
          <a href="#Gauss-map" class="heading-link"><i class="fas fa-link"></i></a><a href="#Gauss-map" class="headerlink" title="Gauss map"></a>Gauss map</h2>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205091632211.png" alt="image-20220509163219231"></p>
<ul>
<li>将曲面s上的单位法向量起点移动到原点 向量的终点都落在单位球上</li>
<li>将曲面的法向量 –&gt;单位球面上</li>
<li>曲面弯曲很大 则法向量变化也会很大</li>
<li>通过法向量的变化课衡量弯曲程度</li>
</ul>

        <h2 id="切映射"   >
          <a href="#切映射" class="heading-link"><i class="fas fa-link"></i></a><a href="#切映射" class="headerlink" title="切映射"></a>切映射</h2>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205091635334.png" alt="image-20220509163533988"></p>
<ul>
<li>从s曲面切空间到球面的切空间</li>
<li>切映射是将一个切向量 映射成另一个切向量</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205091638436.png" alt="image-20220509163812058"></p>
<ul>
<li>切映射是线性的映射 只作用在切向量上</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205091736082.png" alt="image-20220509173611422"></p>
<ul>
<li>由于切平面的映射没有作旋转 只是平移 所以法向量是平行的 单位球面的法向量是n n也是曲面s的单位法向量 所以p点处的切平面和球面的切平面是平行的 所以球面和曲面s上的切空间是一样的 球面和曲面的切向量是一样的（nu&#x3D;ru nv&#x3D;rv 向量不看位置只看方向 起点不同但方向一样）</li>
<li>所以g*是自己对自己的映射</li>
</ul>

        <h2 id="第二基本型和w映射"   >
          <a href="#第二基本型和w映射" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二基本型和w映射" class="headerlink" title="第二基本型和w映射"></a>第二基本型和w映射</h2>
      <ul>
<li>映射dr后再和dr内积得到第二基本型</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205091743421.png" alt="image-20220509174353021"></p>

        <h2 id="w映射是自共轭映射"   >
          <a href="#w映射是自共轭映射" class="heading-link"><i class="fas fa-link"></i></a><a href="#w映射是自共轭映射" class="headerlink" title="w映射是自共轭映射"></a>w映射是自共轭映射</h2>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205091745271.png" alt="image-20220509174553131"></p>
<ul>
<li>自共轭即满足W(dr)δr&#x3D;drW(δr) 交换位置后值不变</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205091747138.png" alt="image-20220509174735688"></p>
<ul>
<li>w是一个矩阵 求w的特征值和特征向量 则λ是特征值 dr是特征向量</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205110951306.png" alt="image-20220511095152035"></p>
<ul>
<li>λ是特征值法曲率 dr是切向量 </li>
<li>w映射对应两个特征值 λ1和λ2如果相等（A&#x3D;0） 则特征向量无法确定 即这一点处任意一个切向量都是特征向量 如果λ1和λ2不相等 则可以确定两个线性无关且正交的特征向量</li>
</ul>

        <h3 id="证明特征值λ1-2对应法曲率"   >
          <a href="#证明特征值λ1-2对应法曲率" class="heading-link"><i class="fas fa-link"></i></a><a href="#证明特征值λ1-2对应法曲率" class="headerlink" title="证明特征值λ1,2对应法曲率"></a>证明特征值λ1,2对应法曲率</h3>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205111007482.png" alt="image-20220511100732973"></p>
<ul>
<li>去一组正交基底 并且使其成为该点的特征向量</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205111008066.png" alt="image-20220511100854589"></p>
<ul>
<li>利用w映射的线性 可以把e表示成cos+sin形式 然后法曲率公式(e.e&#x3D;1 单位向量) e1和e2正交没有交叉项</li>
<li>任一点法曲率等于两个主曲率的组合 所以λ1和λ2对应的是主曲率（即法曲率的最大和最小值）</li>
</ul>

        <h3 id="Euler-formula-2-第二个欧拉公式"   >
          <a href="#Euler-formula-2-第二个欧拉公式" class="heading-link"><i class="fas fa-link"></i></a><a href="#Euler-formula-2-第二个欧拉公式" class="headerlink" title="Euler formula 2 第二个欧拉公式"></a>Euler formula 2 第二个欧拉公式</h3>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205111114680.png" alt="image-20220511111411872"></p>
<ul>
<li>θ的意义不一样 <ul>
<li>θ表示切向量与e1的夹角</li>
<li>θ-θ0 切向量与u曲线的夹角-主方向与u曲线的夹角</li>
</ul>
</li>
<li>脐点：法曲率与切方向无关（主曲率相等的点；第二基本型与第一基本型成比例的点） 任意du dv下恒成立得出L&#x2F;E&#x3D;M&#x2F;F&#x3D;N&#x2F;G&#x3D;Kn<ul>
<li>分为两类：平点 第二基本型&#x3D;0即平面 局部是平面</li>
<li>圆点：局部是球面</li>
</ul>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205111120155.png" alt="image-20220511112017808"></li>
</ul>

        <h3 id="关于脐点的定理"   >
          <a href="#关于脐点的定理" class="heading-link"><i class="fas fa-link"></i></a><a href="#关于脐点的定理" class="headerlink" title="关于脐点的定理"></a>关于脐点的定理</h3>
      <ul>
<li>判定平面：全是平点</li>
<li>判定球面：全是圆点</li>
</ul>

        <h2 id="曲率线"   >
          <a href="#曲率线" class="heading-link"><i class="fas fa-link"></i></a><a href="#曲率线" class="headerlink" title="曲率线"></a>曲率线</h2>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205111123520.png" alt="image-20220511112307269"></p>
<ul>
<li>每个点处的切方向&#x3D;主方向</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205111127626.png" alt="image-20220511112715283"></p>
<ul>
<li>主方向满足w映射的方程</li>
<li>w映射的定义 是-g*(曲面上的切向量到单位球面的映射)</li>
</ul>

        <h3 id="曲率线第一个判定标准："   >
          <a href="#曲率线第一个判定标准：" class="heading-link"><i class="fas fa-link"></i></a><a href="#曲率线第一个判定标准：" class="headerlink" title="曲率线第一个判定标准："></a>曲率线第一个判定标准：</h3>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205111129731.png" alt="image-20220511112903563"></p>
<ul>
<li>曲线法向量的导数和曲线切向量的关系</li>
</ul>

        <h3 id="曲率线第二个判定标准"   >
          <a href="#曲率线第二个判定标准" class="heading-link"><i class="fas fa-link"></i></a><a href="#曲率线第二个判定标准" class="headerlink" title="曲率线第二个判定标准"></a>曲率线第二个判定标准</h3>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205111141380.png" alt="image-20220511114140471"></p>
<ul>
<li><p><strong>当且仅当曲面沿着c的法线所构成的曲面是一个可展曲面</strong></p>
</li>
<li><p>由法线形成的一定是一个直纹面（法线当作母线 曲线c当作准线 法线沿着母线扫过一定形成一个直纹面）c的方程是r(s)</p>
<ul>
<li>得到直纹面的方程r&#x3D;r(s)+tn(s)</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205111141378.png" alt="image-20220511114107048"></p>
<ul>
<li>注意判断直纹面方程是否可展平面的条件：</li>
<li>r’是曲线切向量 垂直 n</li>
<li>n 垂直n‘ n是单位法向量场（对于一个常数向量函数）n同时垂直r’和n’所以n垂直r’和n’形成的平面（它们的外积）</li>
<li>混合积交换依次顺序加一个负号</li>
<li>λ&#x3D;0 即两个向量的外积&#x3D;0 r‘平行n’ 根据第一个判定定理 r’如果平行n’ 则是曲率线</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205111146358.png" alt="image-20220511114643867"></p>
<ul>
<li>必要性证明：<ul>
<li>通过r’平行n’可以得到三个向量的外积&#x3D;0 满足直纹面是可展曲面的条件</li>
</ul>
</li>
</ul>

        <h3 id="example"   >
          <a href="#example" class="heading-link"><i class="fas fa-link"></i></a><a href="#example" class="headerlink" title="example"></a>example</h3>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205111214963.png" alt="image-20220511121343551"></p>
<ul>
<li>纬线：曲面上初始的点绕z周旋转一周得到</li>
<li>经线：经过旋转轴的平面与曲面求交线得到的 经线上的法向量都在平面上</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205111216309.png" alt="image-20220511121638337"></p>
<ul>
<li>可展曲面一定是直纹面 直母线是一组曲率线<ul>
<li>沿着直母线的法向量是不变的 所以导数&#x3D;0 而零向量和dr&#x2F;dt（任何向量）都平行</li>
<li>可展曲面的另一组曲率线是：和直母线正交的的直线</li>
</ul>
</li>
</ul>

        <h2 id="主曲率主方向的具体计算公式"   >
          <a href="#主曲率主方向的具体计算公式" class="heading-link"><i class="fas fa-link"></i></a><a href="#主曲率主方向的具体计算公式" class="headerlink" title="主曲率主方向的具体计算公式"></a>主曲率主方向的具体计算公式</h2>
      
        <h3 id="Mean-curvature-and-Gauss-curvature"   >
          <a href="#Mean-curvature-and-Gauss-curvature" class="heading-link"><i class="fas fa-link"></i></a><a href="#Mean-curvature-and-Gauss-curvature" class="headerlink" title="Mean curvature and Gauss curvature"></a>Mean curvature and Gauss curvature</h3>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205111225217.png" alt="image-20220511122519634"></p>
<ul>
<li>δr是曲面s的一个主方向 主方向满足w映射等式</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205111229885.png" alt="image-20220511122939594"></p>
<ul>
<li>上面的方程组有非零解的话 当且仅当<strong>行列式&#x3D;0</strong>（由线性代数）</li>
<li>正则曲面的w映射一定有两个特征值 所以行列式&#x3D;0的方程一定有两个根（不同讨论b^2-4ac&lt;0 的情况）<ul>
<li>λ1+λ2&#x3D;2H</li>
<li>λ1*λ2&#x3D;K</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205111232369.png" alt="image-20220511123227995"></p>
<ul>
<li>H 是平均曲率 K是高斯曲率 由主曲率构成</li>
<li>可以由平均曲率（描述细节）和高斯曲率（有一个等于0则等于0 平面的主曲率都是0 高斯曲率都是0）求主曲率 </li>
<li>用高斯曲率判断光滑平坦<ul>
<li>高斯曲率还有离散化求法</li>
</ul>
</li>
<li><strong>高斯曲率和平均曲率也是参数变换的不变量</strong></li>
</ul>

        <h3 id="主曲率性质"   >
          <a href="#主曲率性质" class="heading-link"><i class="fas fa-link"></i></a><a href="#主曲率性质" class="headerlink" title="主曲率性质"></a>主曲率性质</h3>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205111653327.png" alt="image-20220511165348807"></p>
<ul>
<li>主曲率是连续函数 不会突变 在非脐点邻域内连续可微</li>
</ul>

        <h3 id="计算步骤："   >
          <a href="#计算步骤：" class="heading-link"><i class="fas fa-link"></i></a><a href="#计算步骤：" class="headerlink" title="计算步骤："></a>计算步骤：</h3>
      
        <h4 id="从主曲率求主方向"   >
          <a href="#从主曲率求主方向" class="heading-link"><i class="fas fa-link"></i></a><a href="#从主曲率求主方向" class="headerlink" title="从主曲率求主方向"></a>从主曲率求主方向</h4>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205111656751.png" alt="image-20220511165655563"></p>
<ul>
<li>（如果是两个主曲率不相等&#x3D;&#x3D;非脐点）求第一基本型和第二基本型 利用高斯曲率和平均曲率公式解关于主曲率的二次方程 求的的解代入δu和δv的等式 可以得到δu和δv</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205111657549.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205111658718.png" alt="image-20220511165843527"></p>
<ul>
<li>（相等&#x3D;&#x3D;脐点）</li>
</ul>

        <h4 id="从主方向求主曲率"   >
          <a href="#从主方向求主曲率" class="heading-link"><i class="fas fa-link"></i></a><a href="#从主方向求主曲率" class="headerlink" title="从主方向求主曲率"></a>从主方向求主曲率</h4>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205111659723.png" alt="image-20220511165957617"></p>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205111702736.png" alt="image-20220511170258680"></p>
<ul>
<li>如果把u,v看成变量 点在移动 则上面式子也是曲率线的方程</li>
<li>重点※ 怎么求主曲率主方向和高斯曲率</li>
</ul>

        <h3 id="定理"   >
          <a href="#定理" class="heading-link"><i class="fas fa-link"></i></a><a href="#定理" class="headerlink" title="定理"></a>定理</h3>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205111708172.png" alt="image-20220511170807074"></p>
<ul>
<li>参数曲线方向（u曲线和v曲线）正好是主曲率方向的条件</li>
<li>u曲线和v曲线不一定是曲面的主方向</li>
</ul>

        <h4 id="证明："   >
          <a href="#证明：" class="heading-link"><i class="fas fa-link"></i></a><a href="#证明：" class="headerlink" title="证明："></a>证明：</h4>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205111715039.png" alt="image-20220511171519427"></p>
<ul>
<li>参数曲线网正交&#x3D;&#x3D;F&#x3D;0</li>
<li>假设u曲线的单位向量（方向）是(1,0)</li>
<li>ru不是零向量 所以E!&#x3D;0</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205111717407.png" alt="image-20220511171726996"></p>
<ul>
<li>当F和M&#x3D;0时可以得到上式是成立的</li>
</ul>

        <h4 id="推论"   >
          <a href="#推论" class="heading-link"><i class="fas fa-link"></i></a><a href="#推论" class="headerlink" title="推论"></a>推论</h4>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205120907782.png" alt="image-20220512090740574"></p>
<ul>
<li><p>参数曲线网正好是正交的曲率线的条件是 F&#x3D;M&#x3D;0 </p>
<p>此时 第一基本型可以写成：</p>
<p>第二基本型写成：k1E+k2G (只需代入k1&#x3D;L&#x2F;E，k2&#x3D;N&#x2F;G)</p>
</li>
</ul>

        <h3 id="脐点处找正交曲率线网"   >
          <a href="#脐点处找正交曲率线网" class="heading-link"><i class="fas fa-link"></i></a><a href="#脐点处找正交曲率线网" class="headerlink" title="脐点处找正交曲率线网"></a>脐点处找正交曲率线网</h3>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205120911040.png" alt="image-20220512091150945"></p>
<ul>
<li>正则曲面s上一定存在<strong>非脐点</strong>处的邻域内 有一个参数系u,v 这个参数系可形成一个正交的曲率线网<ul>
<li>uv曲线可通过参数变换形成正交的曲率现网</li>
</ul>
</li>
<li>如果不是孤立的<strong>脐点</strong> 则这个脐点的邻域可以形成平面或者球面 平面和球面都可以找到正交曲率线网</li>
<li>如果是孤立<strong>脐点</strong> 邻域内没有脐点 找不到曲率线（不能保证一定存在正交的曲率线网）</li>
</ul>

        <h3 id="w映射的矩阵"   >
          <a href="#w映射的矩阵" class="heading-link"><i class="fas fa-link"></i></a><a href="#w映射的矩阵" class="headerlink" title="w映射的矩阵"></a>w映射的矩阵</h3>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205120931558.png" alt="image-20220512093129083"></p>
<ul>
<li>nu和nv可以由ru和rv线性表达 求{E,F,F,G}的逆矩阵</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205120932480.png" alt="image-20220512093224130"></p>
<ul>
<li>迹和行列式在线性变化中保持不变</li>
<li>w映射变换矩阵的trace(迹)&#x3D;对角元素的和&#x3D;2倍平均曲率</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205120938882.png" alt="image-20220512093841725"></p>
<ul>
<li>行列式&#x3D;高斯曲率</li>
<li>高斯曲率的几何意义：两个切向量的外积&#x3D;高斯曲率*两个切向量外积</li>
<li>面积元&#x3D;du x dv 所以可以用高斯曲率表示面积元的映射</li>
<li><strong>映射之后（单位球面积）&#x2F; 原始的面积 &#x3D; 高斯曲率</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205120939661.png" alt="image-20220512093925550"></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/ryenney/2022/05/09/%E6%9B%B2%E9%9D%A29-%E7%AC%AC%E4%B8%89%E5%9F%BA%E6%9C%AC%E5%9E%8B/">Weingarten map</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-05-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-05-21</span></span></div></header><div class="post-body"><div class="post-excerpt"><p><img src="/ryenney/%E6%9B%B2%E9%9D%A29-%E7%AC%AC%E4%B8%89%E5%9F%BA%E6%9C%AC%E5%9E%8B.assets/image-20220518194558136.png" alt="image-20220518194558136"></p>
<ul>
<li>第三基本型是dn和dn的内积</li>
</ul>

        <h2 id="第一基本型第二基本型关系"   >
          <a href="#第一基本型第二基本型关系" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一基本型第二基本型关系" class="headerlink" title="第一基本型第二基本型关系"></a>第一基本型第二基本型关系</h2>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205212309753.png" alt="image-20220521230957711"></p>
<ul>
<li><p>类比求主曲率的公式</p>
</li>
<li><p>u方向和v方向（两个参数方向）是正交的主方向充分必要条件：F&#x3D;M&#x3D;0</p>
<p>此时k1&#x3D;L&#x2F;E k2&#x3D;N&#x2F;G</p>
</li>
<li><p>法向作偏导数得到系数 求第三基本型</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205212315870.png" alt="image-20220521231528098"></p>

        <h2 id="dupin标形"   >
          <a href="#dupin标形" class="heading-link"><i class="fas fa-link"></i></a><a href="#dupin标形" class="headerlink" title="dupin标形"></a>dupin标形</h2>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205212320730.png" alt="image-20220521232057956"></p>
<ul>
<li>法曲率的欧拉公式</li>
<li>把e1和e2作为一个局部标架的基向量</li>
<li>找到一点q 使得pq的值等于（）则可以写出q的坐标</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205212325600.png" alt="image-20220521232533969"></p>
<ul>
<li>满足该点处高斯曲率大于零 两个主曲率符号一样 法曲率的负号也是一样的 则得到椭圆</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205212327657.png" alt="image-20220521232700127"></p>
<ul>
<li>满足该点高斯曲率小于零 得到共轭双曲线</li>
<li>使得法曲率等于零的方向是渐进方向 共轭双曲线的渐近线对应的方向就是法曲率等于零的方向 也即渐进方向</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205212329971.png" alt="image-20220521232902599"></p>
<ul>
<li>法曲率&#x3D;0 是两条直线</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205212329374.png" alt="image-20220521232922009"></p>

        <h3 id="dupin标形定义"   >
          <a href="#dupin标形定义" class="heading-link"><i class="fas fa-link"></i></a><a href="#dupin标形定义" class="headerlink" title="dupin标形定义"></a>dupin标形定义</h3>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205212330283.png" alt="image-20220521233054614"></p>
<ul>
<li><strong>一个方程 由主曲率和法曲率组成的</strong></li>
<li>通过gauss曲率</li>
<li>椭圆点没有渐进方向</li>
<li>k不是同时为0 e1轴方向是渐进方向</li>
<li>k同时是0 没有对应的近似曲面</li>
</ul>

        <h2 id="曲面的标准展开"   >
          <a href="#曲面的标准展开" class="heading-link"><i class="fas fa-link"></i></a><a href="#曲面的标准展开" class="headerlink" title="曲面的标准展开"></a>曲面的标准展开</h2>
      
        <h3 id="近似曲面的形式"   >
          <a href="#近似曲面的形式" class="heading-link"><i class="fas fa-link"></i></a><a href="#近似曲面的形式" class="headerlink" title="近似曲面的形式"></a>近似曲面的形式</h3>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205212336210.png" alt="image-20220521233646148"></p>
<ul>
<li>相同主曲率 主方向 任意方向下相同的法曲率</li>
<li>主曲率一样则高斯曲率法曲率都一样</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205212341019.png" alt="image-20220521234132488"></p>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205212341757.png" alt="image-20220521234150203"></p>
<ul>
<li>讨论cosu的取值</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205212344387.png" alt="image-20220521234413591"></p>
<ul>
<li>通过高斯曲率判断点的类型 cosu决定高斯曲率的符号</li>
</ul>

        <h2 id="特殊曲面"   >
          <a href="#特殊曲面" class="heading-link"><i class="fas fa-link"></i></a><a href="#特殊曲面" class="headerlink" title="特殊曲面"></a>特殊曲面</h2>
      
        <h3 id="高斯曲率为常数"   >
          <a href="#高斯曲率为常数" class="heading-link"><i class="fas fa-link"></i></a><a href="#高斯曲率为常数" class="headerlink" title="高斯曲率为常数"></a>高斯曲率为常数</h3>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205212347008.png" alt="image-20220521234711168"></p>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205212348415.png" alt="image-20220521234826986"></p>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205212348121.png" alt="image-20220521234857530"></p>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205212349064.png" alt="image-20220521234948461"></p>
<ul>
<li><p>旋转曲面 平面 锥面 圆柱面</p>
</li>
<li><p>伪球面 高斯曲率恒小于0</p>
</li>
</ul>

        <h3 id="平均曲率-x3D-0"   >
          <a href="#平均曲率-x3D-0" class="heading-link"><i class="fas fa-link"></i></a><a href="#平均曲率-x3D-0" class="headerlink" title="平均曲率&#x3D;0"></a>平均曲率&#x3D;0</h3>
      <ul>
<li>极小曲面</li>
<li>注意平均曲率怎么算？ 通过第一基本型和第二基本型</li>
<li><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205212355465.png" alt="image-20220521235506586"></li>
<li>悬链面是极小曲面 每个点处平均曲率等于0</li>
<li></li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/ryenney/2022/05/09/DS-3.1/">heap</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-05-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-05-09</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="define"   >
          <a href="#define" class="heading-link"><i class="fas fa-link"></i></a><a href="#define" class="headerlink" title="define"></a>define</h2>
      <ul>
<li>堆这种数据结构本质是一个完全二叉树（完全二叉树（Complete Binary Tree）：在满足满二叉树的性质后，最后一层的叶子节点均需在最左边）</li>
</ul>

        <h2 id="mooc"   >
          <a href="#mooc" class="heading-link"><i class="fas fa-link"></i></a><a href="#mooc" class="headerlink" title="mooc"></a>mooc</h2>
      <ul>
<li><p>建堆时，最坏情况下需要挪动元素次数是等于树中各结点的高度和。问：对于元素个数为12的堆，其各结点的高度之和是多少？</p>
<ul>
<li><pre><code>建堆的话，主要考虑下沉的次数，以此定义高度。
这样的话，8,9,10,11,12都是已经沉底的，要注意的是7也是在最底了。这些节点高度都是0。
4,5,6都是最多可以沉1次的，高度为1.
2,3最多能沉2次，高度为2.
1可以沉3次，高度为3.
1*3+2*2+3*1=3+4+3=10
</code></pre>
</li>
</ul>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/u011240877/article/details/47706923" >判断一个序列是否是堆</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p><img src="/ryenney/heap.assets/image-20220509142051599.png" alt="image-20220509142051599"></p>
</li>
<li><p><img src="/ryenney/heap.assets/image-20220509142112582.png" alt="image-20220509142112582"></p>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.toolsou.com/en/article/220262987" >顺序存储和线性存储</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p>linear data <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/overview-of-data-structures-set-1-linear-data-structures/" >structure</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p>优先队列：</p>
<p>一种先进先出的数据结构，元素在队列尾追加，而从队列头删除 通常采用<strong>堆数据结构</strong></p>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/ryenney/2022/05/09/DS-3.2/">heap</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-05-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-05-25</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="define"   >
          <a href="#define" class="heading-link"><i class="fas fa-link"></i></a><a href="#define" class="headerlink" title="define"></a>define</h2>
      <ul>
<li>堆这种数据结构本质是一个完全二叉树（完全二叉树（Complete Binary Tree）：在满足满二叉树的性质后，最后一层的叶子节点均需在最左边）</li>
</ul>

        <h2 id="mooc"   >
          <a href="#mooc" class="heading-link"><i class="fas fa-link"></i></a><a href="#mooc" class="headerlink" title="mooc"></a>mooc</h2>
      <ul>
<li><p>建堆时，最坏情况下需要挪动元素次数是等于树中各结点的高度和。问：对于元素个数为12的堆，其各结点的高度之和是多少？</p>
<ul>
<li><pre><code>建堆的话，主要考虑下沉的次数，以此定义高度。
这样的话，8,9,10,11,12都是已经沉底的，要注意的是7也是在最底了。这些节点高度都是0。
4,5,6都是最多可以沉1次的，高度为1.
2,3最多能沉2次，高度为2.
1可以沉3次，高度为3.
1*3+2*2+3*1=3+4+3=10
</code></pre>
</li>
</ul>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/u011240877/article/details/47706923" >判断一个序列是否是堆</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p><img src="/ryenney/heap.assets/image-20220509142051599.png" alt="image-20220509142051599"></p>
</li>
<li><p><img src="/ryenney/heap.assets/image-20220509142112582.png" alt="image-20220509142112582"></p>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.toolsou.com/en/article/220262987" >顺序存储和线性存储</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p>linear data <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/overview-of-data-structures-set-1-linear-data-structures/" >structure</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p>优先队列：</p>
<p>一种先进先出的数据结构，元素在队列尾追加，而从队列头删除 通常采用<strong>堆数据结构</strong></p>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/ryenney/2022/05/09/heap/">heap</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-05-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-05-25</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="define"   >
          <a href="#define" class="heading-link"><i class="fas fa-link"></i></a><a href="#define" class="headerlink" title="define"></a>define</h2>
      <ul>
<li>堆这种数据结构本质是一个完全二叉树（完全二叉树（Complete Binary Tree）：在满足满二叉树的性质后，最后一层的叶子节点均需在最左边）</li>
</ul>

        <h2 id="mooc"   >
          <a href="#mooc" class="heading-link"><i class="fas fa-link"></i></a><a href="#mooc" class="headerlink" title="mooc"></a>mooc</h2>
      <ul>
<li><p>建堆时，最坏情况下需要挪动元素次数是等于树中各结点的高度和。问：对于元素个数为12的堆，其各结点的高度之和是多少？</p>
<ul>
<li><pre><code>建堆的话，主要考虑下沉的次数，以此定义高度。
这样的话，8,9,10,11,12都是已经沉底的，要注意的是7也是在最底了。这些节点高度都是0。
4,5,6都是最多可以沉1次的，高度为1.
2,3最多能沉2次，高度为2.
1可以沉3次，高度为3.
1*3+2*2+3*1=3+4+3=10
</code></pre>
</li>
</ul>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/u011240877/article/details/47706923" >判断一个序列是否是堆</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p><img src="/ryenney/heap.assets/image-20220509142051599.png" alt="image-20220509142051599"></p>
</li>
<li><p><img src="/ryenney/heap.assets/image-20220509142112582.png" alt="image-20220509142112582"></p>
</li>
<li><p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.toolsou.com/en/article/220262987" >顺序存储和线性存储</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p>linear data <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/overview-of-data-structures-set-1-linear-data-structures/" >structure</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
<li><p>优先队列：</p>
<p>一种先进先出的数据结构，元素在队列尾追加，而从队列头删除 通常采用<strong>堆数据结构</strong></p>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/ryenney/2022/05/09/huawei_cloud/">huaweicloud</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-05-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-05-25</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="DS-1"   >
          <a href="#DS-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#DS-1" class="headerlink" title="DS-1"></a>DS-1</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">Reverse</span><span class="params">(Node* first)</span></span>&#123;</span><br><span class="line">	Node *p1=<span class="literal">nullptr</span>;</span><br><span class="line">	Node *p2=<span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">while</span>(first)&#123;</span><br><span class="line">        p2=first-&gt;next;</span><br><span class="line">        first-&gt;next=p1;</span><br><span class="line">        p1=first;</span><br><span class="line">        first=p2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p1;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Node* Merge（Node* a, Node* b)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!a) <span class="keyword">return</span> b;</span><br><span class="line">	<span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">	Node *A,*B,*head;</span><br><span class="line">	<span class="keyword">if</span>(a-&gt;value&lt;b-&gt;value)</span><br><span class="line">		A=a,B=b;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		A=b,B=a;</span><br><span class="line">	head=A;</span><br><span class="line">	<span class="keyword">while</span>(A-&gt;next &amp;&amp; B)&#123;</span><br><span class="line">		<span class="keyword">if</span>(B-&gt;value&lt;=A-&gt;value)&#123;</span><br><span class="line">			Node* Anext=A-&gt;next;</span><br><span class="line">			Node* Bnext=B-&gt;next;</span><br><span class="line">			A-&gt;next=B;</span><br><span class="line">			B-&gt;bext=Anext;</span><br><span class="line">			A=A-&gt;next;</span><br><span class="line">			B=Bnext;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			A=A-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(A-&gt;next==<span class="literal">NULL</span> &amp;&amp; B)</span><br><span class="line">		A-&gt;next=B;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(<span class="type">const</span> T item)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">IsFull</span>())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        queue[rear] = item;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(T&amp; item)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">IsEmpty</span>())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        item = queue[front];</span><br><span class="line">        front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetFront</span><span class="params">(T&amp; item)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">IsEmpty</span>())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        item = queue[front];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (front == rear) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;队列为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsFull</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((rear + <span class="number">1</span>) % maxSize == front) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;队列已满，溢出&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>




        <h2 id="DS-2"   >
          <a href="#DS-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#DS-2" class="headerlink" title="DS-2"></a>DS-2</h2>
      <ul>
<li>&#96;&#96;&#96;c++<br>bool Push(const T item);<br>bool Pop(T&amp; item);<br>bool Top(T&amp; item);<br>bool Push(const T item){<br>if(IsFull()){<br>    return false;<br>}<br>else{<br>    st[++top]&#x3D;item;<br>    return true;<br>}<br>}<br>bool Pop(T&amp; item){<br>if(IsEmpty()){<br>    return false;<br>}<br>else{<br>    item&#x3D;st[top–];<br>    return true;<br>}<br>}<br>bool Top(T&amp;item){<br>if(IsEmpty()){<br>    return false;<br>}<br>else{<br>    item&#x3D;st[top];<br>    return true;<br>}<br>}<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- ```c++</span><br><span class="line">  string Bracketmatch(const char* c) //括号匹配</span><br><span class="line">  &#123;</span><br><span class="line">      string res = &quot;111&quot;;</span><br><span class="line">      int size = sizeof(c);</span><br><span class="line">      stack st[3] = &#123; size,size,size &#125;;//每一种括号分配一个栈</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">      for (int i = 0; c[i] != &#x27;\0&#x27;; i++) &#123;</span><br><span class="line">          if (c[i] == &#x27;(&#x27;) &#123;</span><br><span class="line">              st[0].push(c[i]);</span><br><span class="line">          &#125;//左括号入栈</span><br><span class="line">          else if (c[i] == &#x27;)&#x27;) &#123;</span><br><span class="line">              //右括号需要判断栈</span><br><span class="line">              if (!st[0].empty()) &#123;</span><br><span class="line">                  st[0].pop();//栈不为空则pop</span><br><span class="line">              &#125;</span><br><span class="line">              else//栈为空则不匹配</span><br><span class="line">                  res[0] = 0;</span><br><span class="line">          &#125;</span><br><span class="line">          else if (c[i] == &#x27;[&#x27;) &#123;</span><br><span class="line">              st[1].push(c[i]);</span><br><span class="line">          &#125;</span><br><span class="line">          else if (c[i] == &#x27;]&#x27;) &#123;</span><br><span class="line">              if (!st[1].empty()) &#123;</span><br><span class="line">                  st[1].pop();</span><br><span class="line">              &#125;</span><br><span class="line">              else</span><br><span class="line">                  res[1] = 0;</span><br><span class="line">          &#125;</span><br><span class="line">          else if (c[i] == &#x27;&#123;&#x27;) &#123;</span><br><span class="line">              st[2].push(c[i]);</span><br><span class="line">          &#125;</span><br><span class="line">          else if (c[i] == &#x27;&#125;&#x27;) &#123;</span><br><span class="line">              if (!st[2].empty()) &#123;</span><br><span class="line">                  st[2].pop();</span><br><span class="line">              &#125;</span><br><span class="line">              else</span><br><span class="line">                  res[2] = 0;</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">      &#125;</span><br><span class="line">      for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">          if (!st[i].empty())</span><br><span class="line">              res[i] = 0;//string的下标操作</span><br><span class="line">      &#125;//不要忘了最后需要对所有栈检查有没有剩余 有剩余则不匹配</span><br><span class="line">      return res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h2 id="DS-3"   >
          <a href="#DS-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#DS-3" class="headerlink" title="DS-3"></a>DS-3</h2>
      <ul>
<li>&#96;&#96;&#96;c++<br>   bool EnQueue(const T item)<br>{<br>    if ((rear+1)%maxSize &#x3D;&#x3D; front) {<br>        cout &lt;&lt; “队列已满，溢出” &lt;&lt; endl;<br>        return false;<br>    }<br>    else {<br>        queue[rear] &#x3D; item;<br>        rear&#x3D;(rear+1)%maxSize;<br>        return true;<br>    }<br>}<br>bool DeQueue(T&amp; item)<br>{<br>    if (front &#x3D;&#x3D; rear) {<br>        cout &lt;&lt; “队列为空” &lt;&lt; endl;<br>        return false;<br>    }<br>    item &#x3D; queue[front];<br>    front &#x3D; (front + 1) % maxSize;<br>    return true;<br>}<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```c++</span><br><span class="line">  void LinkQueue&lt;ElemType&gt;::Clear()</span><br><span class="line">  // 操作结果：清空队列</span><br><span class="line">  &#123;</span><br><span class="line">      if (!Empty()) &#123;</span><br><span class="line">          while (front != nullptr) &#123;</span><br><span class="line">              rear = front;</span><br><span class="line">              front = front-&gt;next;</span><br><span class="line">              delete rear;</span><br><span class="line">          &#125;</span><br><span class="line">          rear = nullptr;</span><br><span class="line">          count = 0;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  bool LinkQueue&lt;ElemType&gt;::OutQueue(ElemType&amp; e)</span><br><span class="line">  // 操作结果：如果队列非空，那么删除队头元素，并用e返回其值，返回true,</span><br><span class="line">  //	否则返回false，</span><br><span class="line">  &#123;</span><br><span class="line">      Node&lt;ElemType&gt;* temp;</span><br><span class="line">  </span><br><span class="line">      if (!Empty()) &#123;</span><br><span class="line">          e = front-&gt;data;</span><br><span class="line">          temp = front;</span><br><span class="line">          front = front-&gt;next;</span><br><span class="line">          delete temp;</span><br><span class="line">          count--;</span><br><span class="line">          return true;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">          return false;</span><br><span class="line">  &#125;</span><br><span class="line">  bool LinkQueue&lt;ElemType&gt;::InQueue(const ElemType&amp; e)</span><br><span class="line">  // 操作结果：插入元素e为新的队尾，返回true</span><br><span class="line">  &#123;//判断rear为null</span><br><span class="line">      if (rear == nullptr) &#123;</span><br><span class="line">          front = rear = new Node&lt;ElemType&gt;(e, nullptr);</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">      rear-&gt;next = new Node&lt;ElemType&gt;(e, nullptr);</span><br><span class="line">      rear = rear-&gt;next;</span><br><span class="line">      </span><br><span class="line">      &#125;</span><br><span class="line">      count++;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h2 id="DS-4"   >
          <a href="#DS-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#DS-4" class="headerlink" title="DS-4"></a>DS-4</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">next</span><span class="params">(string P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> m = P.<span class="built_in">size</span>();</span><br><span class="line">	<span class="built_in">assert</span>(m &gt; <span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span>* N = <span class="keyword">new</span> <span class="type">int</span>[m];</span><br><span class="line">	N[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (i != <span class="number">0</span> &amp;&amp; P[i] != P[j]) &#123;<span class="comment">//&amp;&amp; not ||</span></span><br><span class="line">			i = N[i - <span class="number">1</span>];<span class="comment">//如果之前有成功匹配就需要进入while循环 回退状态到0或者匹配 j永远不回退</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (P[i] == P[j]) &#123;</span><br><span class="line">			N[j] = i + <span class="number">1</span>;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			N[j] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">KMPStrMatching</span><span class="params">(string T, string P, <span class="type">int</span>* N, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> lastIndex = T.<span class="built_in">size</span>() - P.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (lastIndex - startIndex &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;<span class="comment">//i T j P</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; T.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (T[i] != P[j] &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			j = N[j - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (P[j] == T[i]) &#123;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">if</span> (j == P.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>





        <h2 id="DS-9"   >
          <a href="#DS-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#DS-9" class="headerlink" title="DS-9"></a>DS-9</h2>
      <ul>
<li><pre><code class="c++">void MaxHeap&lt;T&gt;::BuildHeap()&#123;
    for(int i=CurrentSize/2-1;i&gt;=0;i--)&#123;
        SiftDown(i);
    &#125;
&#125;
void MaxHeap&lt;T&gt;::SiftDown(int left)&#123;
    int i=left;
    int j=2*i+1;
    T temp=HeapArray[i];
    while(j&lt;CurrentSize)&#123;
        j++;
        if(temp&lt;heapArray[i])&#123;
            heapArray[i]=heapArray[j];
            i=j;
            j=2*j+1;
        &#125;
        else break;
    &#125;
    heapArray[i]=temp;    
&#125;
void MaxHeap&lt;T&gt;::SiftUp(int pos)&#123;
    int p=parent(pos);
    while(p&gt;-1&amp;&amp;heapArray[p]&lt;heapArray[pos])&#123;
        temp=heapArray[p];
        heapArray[p]=heapArray[pos];
        heapArray[pos]=temp;
        p=parent(p);
    &#125;
&#125;
</code></pre>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/ryenney/2022/05/06/0414-physicalmath-1/">0414_physicalmath</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-05-06</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-05-31</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="series-级数"   >
          <a href="#series-级数" class="heading-link"><i class="fas fa-link"></i></a><a href="#series-级数" class="headerlink" title="series 级数"></a>series 级数</h2>
      
        <h3 id="定义"   >
          <a href="#定义" class="heading-link"><i class="fas fa-link"></i></a><a href="#定义" class="headerlink" title="定义"></a>定义</h3>
      <ul>
<li><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205311547404.png" alt="image-20220531154742849"></li>
<li>绝对收敛：模收敛 原级数收敛</li>
<li>条件收敛：模不收敛 原级数收敛</li>
</ul>

        <h3 id="性质"   >
          <a href="#性质" class="heading-link"><i class="fas fa-link"></i></a><a href="#性质" class="headerlink" title="性质"></a>性质</h3>
      
        <h4 id="幂级数"   >
          <a href="#幂级数" class="heading-link"><i class="fas fa-link"></i></a><a href="#幂级数" class="headerlink" title="幂级数"></a>幂级数</h4>
      <ul>
<li><p>Abel定理：至少z&#x3D;0的时候一定是收敛的 所以收敛的集合是非空的 z0收敛 则小于z0的都收敛 z发散 则大于z0的都发散</p>
</li>
<li><p>幂级数收敛范围是原点为中心 R为半径的收敛域（圆周上的收敛性是无法判断的）</p>
</li>
<li><p>根值判别法 和 比值判别法</p>
</li>
<li><p>逐项可导 逐项积分 前提：收敛半径R&gt;0 则可以交换求和与积分&#x2F;求导的顺序</p>
<ul>
<li>证明：证明逐项后的新的幂级数在收敛域内是收敛的 且 与f(z)求得导数是相等得</li>
</ul>
</li>
<li><p>对幂级数进行逐项求导 求高阶导数 k阶导数 z&#x3D;0时可以求出cn 系数</p>
</li>
<li><p>从零点推广到z0</p>
</li>
</ul>

        <h2 id="幂级数-1"   >
          <a href="#幂级数-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#幂级数-1" class="headerlink" title="幂级数"></a>幂级数</h2>
      
        <h2 id="talor级数"   >
          <a href="#talor级数" class="heading-link"><i class="fas fa-link"></i></a><a href="#talor级数" class="headerlink" title="talor级数"></a>talor级数</h2>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/ryenney/2022/05/06/0412-physicalmath/">0412_physicalmath</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-05-06</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-05-31</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="Morera定理"   >
          <a href="#Morera定理" class="heading-link"><i class="fas fa-link"></i></a><a href="#Morera定理" class="headerlink" title="Morera定理"></a>Morera定理</h2>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205190916748.png" alt="image-20220519091607121"></p>
<ul>
<li>cauchy积分定理 如果闭曲线内可导积分&#x3D;0</li>
<li>Morera：如果积分等于0推导出解析</li>
</ul>

        <h2 id="Cauchy不等式"   >
          <a href="#Cauchy不等式" class="heading-link"><i class="fas fa-link"></i></a><a href="#Cauchy不等式" class="headerlink" title="Cauchy不等式"></a>Cauchy不等式</h2>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205190918890.png" alt="image-20220519091805569"></p>
<ul>
<li>对积分的估算 -&gt;对函数的估算</li>
<li>f是一个解析函数 如果f有界小于等于M则f的高阶导数也是有界的</li>
</ul>

        <h2 id="刘维尔定理"   >
          <a href="#刘维尔定理" class="heading-link"><i class="fas fa-link"></i></a><a href="#刘维尔定理" class="headerlink" title="刘维尔定理"></a>刘维尔定理</h2>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205190925668.png" alt="image-20220519092505540"></p>
<ul>
<li><p>整函数：在整个复平面上解析 若f是整函数而且有界 必然是一个常数</p>
</li>
<li><p>如果一个n次多项式 有n个根（一定只有n个 考虑重根 两根一样记为两次）</p>
</li>
</ul>

        <h2 id="解析函数和调和函数关系"   >
          <a href="#解析函数和调和函数关系" class="heading-link"><i class="fas fa-link"></i></a><a href="#解析函数和调和函数关系" class="headerlink" title="解析函数和调和函数关系"></a>解析函数和调和函数关系</h2>
      
        <h3 id="harmonic-function"   >
          <a href="#harmonic-function" class="heading-link"><i class="fas fa-link"></i></a><a href="#harmonic-function" class="headerlink" title="harmonic function"></a>harmonic function</h3>
      <ul>
<li><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205302158977.png" alt="image-20220530215811195"></li>
</ul>

        <h3 id="harmonic-conjugate-共轭调和"   >
          <a href="#harmonic-conjugate-共轭调和" class="heading-link"><i class="fas fa-link"></i></a><a href="#harmonic-conjugate-共轭调和" class="headerlink" title="harmonic conjugate 共轭调和"></a>harmonic conjugate 共轭调和</h3>
      <ul>
<li><p>满足u和v都是harmonic</p>
</li>
<li><p>而且满足柯西黎曼方程</p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205302201202.png" alt="image-20220530220127049"></p>
</li>
<li><p>称v是u的共轭调和函数 u和v的负号注意（）不能说u是v的共轭调和</p>
</li>
<li><p>注意u和v都是解析 而且满足柯西黎曼则 &#x3D;&#x3D; f(z)&#x3D;u+iv是解析函数</p>
</li>
<li><p>如果v是u的共轭调和 则可以得到f(z)是解析函数</p>
</li>
</ul>

        <h2 id="eg"   >
          <a href="#eg" class="heading-link"><i class="fas fa-link"></i></a><a href="#eg" class="headerlink" title="eg"></a>eg</h2>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/ryenney/2022/05/06/0407-physicalmath/">0407_physicalmath</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-05-06</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-05-19</span></span></div></header><div class="post-body"><div class="post-excerpt"><ul>
<li>闭曲线c可以经过a点</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205121634542.png" alt="image-20220512163451686"></p>
<ul>
<li>纠正上次的公式录入错误：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205121642709.png" alt="image-20220512164214827"></p>

        <h2 id="解析函数导数"   >
          <a href="#解析函数导数" class="heading-link"><i class="fas fa-link"></i></a><a href="#解析函数导数" class="headerlink" title="解析函数导数"></a>解析函数导数</h2>
      <ul>
<li>解析函数有任意阶导数</li>
</ul>

        <h3 id="证明"   >
          <a href="#证明" class="heading-link"><i class="fas fa-link"></i></a><a href="#证明" class="headerlink" title="证明"></a>证明</h3>
      <ul>
<li>证明：需要找到上界</li>
</ul>

        <h3 id="记忆一阶导数公式"   >
          <a href="#记忆一阶导数公式" class="heading-link"><i class="fas fa-link"></i></a><a href="#记忆一阶导数公式" class="headerlink" title="记忆一阶导数公式"></a>记忆一阶导数公式</h3>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205121719091.png" alt="image-20220512171933981"></p>
<ul>
<li>对f(a)左右侧同时求导</li>
</ul>

        <h3 id="高阶导数"   >
          <a href="#高阶导数" class="heading-link"><i class="fas fa-link"></i></a><a href="#高阶导数" class="headerlink" title="高阶导数"></a>高阶导数</h3>
      <p><img src="https://cdn.jsdelivr.net/gh/pinkyrie/pic@master/202205121742913.png" alt="image-20220512174256936"></p>
<ul>
<li><p>区别只是把分母的次幂换成了n+1</p>
</li>
<li><p>是反过来 通过求高阶导数来求闭曲线的积分</p>
</li>
</ul>

        <h3 id="例题"   >
          <a href="#例题" class="heading-link"><i class="fas fa-link"></i></a><a href="#例题" class="headerlink" title="例题"></a>例题</h3>
      </div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/ryenney/page/3/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/ryenney/">1</a><span class="space">&hellip;</span><a class="page-number" href="/ryenney/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/ryenney/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/ryenney/page/7/">7</a><a class="extend next" rel="next" href="/ryenney/page/5/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://github.com/pinkyrie/pic/blob/main/202204272046093.JPG?raw=true" alt="avatar"></div><p class="sidebar-ov-author__text">be happy</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/pinkyrie" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="954365771" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">61</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">9</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">5</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/ryenney/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2022</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>rye</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.2.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><script src="/ryenney/js/utils.js?v=2.6.2"></script><script src="/ryenney/js/stun-boot.js?v=2.6.2"></script><script src="/ryenney/js/scroll.js?v=2.6.2"></script><script src="/ryenney/js/header.js?v=2.6.2"></script><script src="/ryenney/js/sidebar.js?v=2.6.2"></script></body></html>